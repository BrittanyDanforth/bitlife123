-- RelationshipsScreen.lua
-- Premium BitLife-style Relationships screen
-- Triple AAA polished UI for family, friends, and romantic connections

local TweenService       = game:GetService("TweenService")
local ReplicatedStorage  = game:GetService("ReplicatedStorage")

local UI = require(ReplicatedStorage:WaitForChild("UIComponents"))
local C  = UI.Colors or {}
local F  = UI.Fonts or {}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FONT SAFETY - CRITICAL FIX #953 (REVISED)
-- Ensure ALL fonts exist so Font property never gets nil!
-- Error was: "Unable to assign property Font. EnumItem, number, or string expected, got nil"
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local DEFAULT_FONT = Enum.Font.SourceSans

-- CRITICAL FIX: Create a safe font getter function
local function safeFont(fontEnum)
	if fontEnum and type(fontEnum) == "userdata" then
		return fontEnum
	end
	return DEFAULT_FONT
end

-- CRITICAL FIX: Force-initialize F table - completely rebuild it
F = {}

-- CRITICAL FIX: Use pcall to safely try each font with multiple fallbacks
local function tryFont(...)
	local fonts = {...}
	for _, fontName in ipairs(fonts) do
		local success, font = pcall(function()
			return Enum.Font[fontName]
		end)
		if success and font then
			return font
		end
	end
	return DEFAULT_FONT
end

-- Set all fonts with safe fallback chain
F.Title  = tryFont("GothamBold", "GothamBlack", "SourceSansBold", "SourceSans")
F.Body   = tryFont("Gotham", "GothamMedium", "SourceSans")
F.Medium = tryFont("GothamMedium", "Gotham", "SourceSans")
F.Button = tryFont("GothamBold", "GothamSemibold", "SourceSansBold", "SourceSans")
F.Bold   = tryFont("GothamBold", "GothamBlack", "SourceSansBold", "SourceSans")

-- CRITICAL FIX: Triple-check all fonts are valid
for key, value in pairs(F) do
	if not value or type(value) ~= "userdata" then
		F[key] = DEFAULT_FONT
	end
end

-- CRITICAL FIX: Final fallback - directly assign if still nil
F.Bold = F.Bold or DEFAULT_FONT
F.Medium = F.Medium or DEFAULT_FONT
F.Body = F.Body or DEFAULT_FONT
F.Title = F.Title or DEFAULT_FONT
F.Button = F.Button or DEFAULT_FONT

-- BUG FIX: Create wrapper function to always return valid font
local function getFont(fontKey)
	local font = F[fontKey]
	if font and type(font) == "userdata" then
		return font
	end
	return DEFAULT_FONT
end

-- Apply safe fonts to F table (ensures all access is safe)
local SafeF = setmetatable({}, {
	__index = function(_, key)
		local font = rawget(F, key)
		if font and type(font) == "userdata" then
			return font
		end
		return DEFAULT_FONT
	end
})

-- Replace F with SafeF for all subsequent use
F = SafeF

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- COLOR SAFETY
-- Ensure ALL colors exist so TextColor3/BackgroundColor3 never get nil.
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Base colors
C.Pink       = C.Pink       or Color3.fromRGB(236, 72, 153)
C.Green      = C.Green      or Color3.fromRGB(34, 197, 94)
C.Red        = C.Red        or Color3.fromRGB(239, 68, 68)
C.Purple     = C.Purple     or Color3.fromRGB(139, 92, 246)
C.Cyan       = C.Cyan       or Color3.fromRGB(6, 182, 212)
C.Blue       = C.Blue       or Color3.fromRGB(59, 130, 246)
C.Orange     = C.Orange     or Color3.fromRGB(249, 115, 22)
C.Yellow     = C.Yellow     or Color3.fromRGB(234, 179, 8)
C.White      = C.White      or Color3.fromRGB(255, 255, 255)
C.Black      = C.Black      or Color3.fromRGB(0, 0, 0)

-- Dark variants
C.PinkDark   = C.PinkDark   or Color3.fromRGB(190, 24, 93)
C.GreenDark  = C.GreenDark  or Color3.fromRGB(22, 163, 74)
C.RedDark    = C.RedDark    or Color3.fromRGB(185, 28, 28)
C.PurpleDark = C.PurpleDark or Color3.fromRGB(109, 40, 217)
C.CyanDark   = C.CyanDark   or Color3.fromRGB(14, 116, 144)
C.BlueDark   = C.BlueDark   or Color3.fromRGB(29, 78, 216)
C.OrangeDark = C.OrangeDark or Color3.fromRGB(194, 65, 12)

-- Pale variants
C.PinkPale   = C.PinkPale   or Color3.fromRGB(252, 231, 243)
C.GreenPale  = C.GreenPale  or Color3.fromRGB(220, 252, 231)
C.RedPale    = C.RedPale    or Color3.fromRGB(254, 226, 226)
C.BluePale   = C.BluePale   or Color3.fromRGB(219, 234, 254)
C.PurplePale = C.PurplePale or Color3.fromRGB(237, 233, 254)
C.YellowPale = C.YellowPale or Color3.fromRGB(254, 249, 195)
C.OrangePale = C.OrangePale or Color3.fromRGB(255, 237, 213)
C.CyanPale   = C.CyanPale   or Color3.fromRGB(224, 242, 254)

-- Grays
C.Gray100    = C.Gray100    or Color3.fromRGB(243, 244, 246)
C.Gray200    = C.Gray200    or Color3.fromRGB(229, 231, 235)
C.Gray300    = C.Gray300    or Color3.fromRGB(209, 213, 219)
C.Gray400    = C.Gray400    or Color3.fromRGB(156, 163, 175)
C.Gray500    = C.Gray500    or Color3.fromRGB(107, 114, 128)
C.Gray600    = C.Gray600    or Color3.fromRGB(75, 85, 99)
C.Gray700    = C.Gray700    or Color3.fromRGB(55, 65, 81)
C.Gray800    = C.Gray800    or Color3.fromRGB(31, 41, 55)
C.Gray900    = C.Gray900    or Color3.fromRGB(17, 24, 39)

-- Extra safety colors
C.Bg         = C.Bg         or Color3.fromRGB(246, 248, 252)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MOBILE RESPONSIVE SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera

-- CRITICAL FIX: Added IS_TINY_PHONE for ultra-small phones like iPhone SE
local IS_MOBILE = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
local IS_TABLET = IS_MOBILE and (Camera.ViewportSize.X >= 768 or Camera.ViewportSize.Y >= 768)
local IS_SMALL_PHONE = IS_MOBILE and not IS_TABLET and (Camera.ViewportSize.X < 400 or Camera.ViewportSize.Y < 700)
local IS_TINY_PHONE = IS_MOBILE and not IS_TABLET and (Camera.ViewportSize.X <= 380 or Camera.ViewportSize.Y <= 680)
local ViewportSize = Camera.ViewportSize

-- CRITICAL UI FIX: More aggressive scaling for small phones
local function getScale()
	local minDim = math.min(ViewportSize.X, ViewportSize.Y)
	if minDim < 350 then return 0.55 end  -- SUPER TINY phones
	if minDim < 380 then return 0.65 end  -- TINY phones like iPhone SE
	if minDim < 400 then return 0.72 end  -- Small phones
	if minDim < 500 then return 0.85 end
	if minDim < 768 then return 0.95 end
	return 1.0
end

local function px(baseValue) return math.floor(baseValue * getScale()) end

-- CRITICAL FIX: Better text sizing for tiny phones - more readable
local function textSize(baseSize) 
	local minSize = IS_TINY_PHONE and 10 or (IS_SMALL_PHONE and 11 or 12)
	return math.max(minSize, math.floor(baseSize * getScale())) 
end

-- CRITICAL FIX: More padding/spacing on small screens to reduce bunching
local function padSize(base) 
	if IS_TINY_PHONE then return math.max(4, math.floor(base * 0.6)) end
	if IS_SMALL_PHONE then return math.max(5, math.floor(base * 0.75)) end
	return math.floor(base * getScale())
end

-- CRITICAL FIX: Card heights that scale properly
local function cardHeight(baseHeight)
	if IS_TINY_PHONE then return math.max(70, math.floor(baseHeight * 0.7)) end
	if IS_SMALL_PHONE then return math.max(80, math.floor(baseHeight * 0.85)) end
	return baseHeight
end

-- CRITICAL FIX: Proper minimum touch target for tiny phones
local function btnHeight(baseHeight)
	local scaled = math.floor(baseHeight * getScale())
	local minTarget = IS_TINY_PHONE and 36 or (IS_SMALL_PHONE and 40 or 44)
	return IS_MOBILE and math.max(minTarget, scaled) or scaled
end

local function cardWidth()
	if IS_TINY_PHONE then return ViewportSize.X - 8 end
	if IS_SMALL_PHONE then return ViewportSize.X - 12 end
	if IS_MOBILE then return math.min(ViewportSize.X - 24, 350) end
	return 350
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PREMIUM EMPTY STATE CARD HELPER
-- Creates a polished empty state card with icon, message, and optional action
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function createPremiumEmptyCard(parent, options)
	options = options or {}
	local emoji = options.emoji or "ğŸ“­"
	local title = options.title or "Nothing Here"
	local message = options.message or "No items to display."
	local accentColor = options.accentColor or C.Gray400
	local layoutOrder = options.layoutOrder or 1
	local actionText = options.actionText
	local actionCallback = options.actionCallback
	
	-- Container
	local container = Instance.new("Frame")
	container.Name = "EmptyStateCard"
	container.Size = UDim2.new(1, 0, 0, actionText and 170 or 140)
	container.BackgroundTransparency = 1
	container.LayoutOrder = layoutOrder
	container.ZIndex = 82
	container.Parent = parent
	
	-- Shadow
	local shadow = Instance.new("Frame")
	shadow.Size = UDim2.new(1, 4, 1, 4)
	shadow.Position = UDim2.new(0, 2, 0, 2)
	shadow.BackgroundColor3 = C.Black
	shadow.BackgroundTransparency = 0.94
	shadow.ZIndex = 82
	shadow.Parent = container
	UI.corner(shadow, 20)
	
	-- Shell (subtle accent)
	local shell = Instance.new("Frame")
	shell.Size = UDim2.fromScale(1, 1)
	shell.BackgroundColor3 = accentColor:Lerp(C.White, 0.6)
	shell.ZIndex = 83
	shell.Parent = container
	UI.corner(shell, 18)
	
	-- Inner card
	local card = Instance.new("Frame")
	card.Size = UDim2.new(1, -4, 1, -4)
	card.Position = UDim2.new(0, 2, 0, 2)
	card.BackgroundColor3 = C.White
	card.ZIndex = 84
	card.Parent = shell
	UI.corner(card, 16)
	
	-- Emoji icon with circle background
	local iconCircle = Instance.new("Frame")
	iconCircle.Size = UDim2.new(0, 56, 0, 56)
	iconCircle.AnchorPoint = Vector2.new(0.5, 0)
	iconCircle.Position = UDim2.new(0.5, 0, 0, 14)
	iconCircle.BackgroundColor3 = accentColor:Lerp(C.White, 0.85)
	iconCircle.ZIndex = 85
	iconCircle.Parent = card
	UI.corner(iconCircle, 28)
	
	local iconLabel = Instance.new("TextLabel")
	iconLabel.Size = UDim2.fromScale(1, 1)
	iconLabel.BackgroundTransparency = 1
	iconLabel.Font = F.Body
	iconLabel.TextSize = 26
	iconLabel.Text = emoji
	iconLabel.ZIndex = 86
	iconLabel.Parent = iconCircle
	
	-- Title
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Size = UDim2.new(1, -32, 0, 22)
	titleLabel.AnchorPoint = Vector2.new(0.5, 0)
	titleLabel.Position = UDim2.new(0.5, 0, 0, 74)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Font = F.Title
	titleLabel.TextSize = 15
	titleLabel.TextColor3 = C.Gray700
	titleLabel.Text = title
	titleLabel.ZIndex = 85
	titleLabel.Parent = card
	
	-- Message
	local messageLabel = Instance.new("TextLabel")
	messageLabel.Size = UDim2.new(1, -32, 0, 28)
	messageLabel.AnchorPoint = Vector2.new(0.5, 0)
	messageLabel.Position = UDim2.new(0.5, 0, 0, 96)
	messageLabel.BackgroundTransparency = 1
	messageLabel.Font = F.Body
	messageLabel.TextSize = 12
	messageLabel.TextColor3 = C.Gray500
	messageLabel.TextWrapped = true
	messageLabel.Text = message
	messageLabel.ZIndex = 85
	messageLabel.Parent = card
	
	-- Optional action button
	if actionText and actionCallback then
		local actionBtn = Instance.new("TextButton")
		actionBtn.Size = UDim2.new(0.6, 0, 0, 32)
		actionBtn.AnchorPoint = Vector2.new(0.5, 0)
		actionBtn.Position = UDim2.new(0.5, 0, 0, 128)
		actionBtn.BackgroundColor3 = accentColor
		actionBtn.Font = F.Button
		actionBtn.TextSize = 12
		actionBtn.TextColor3 = C.White
		actionBtn.Text = actionText
		actionBtn.AutoButtonColor = false
		actionBtn.ZIndex = 86
		actionBtn.Parent = card
		UI.corner(actionBtn, 8)
		
		actionBtn.MouseEnter:Connect(function()
			UI.tween(actionBtn, TweenInfo.new(0.12), {
				BackgroundColor3 = accentColor:Lerp(C.Black, 0.15)
			})
		end)
		actionBtn.MouseLeave:Connect(function()
			UI.tween(actionBtn, TweenInfo.new(0.12), { BackgroundColor3 = accentColor })
		end)
		actionBtn.MouseButton1Click:Connect(actionCallback)
	end
	
	return container
end
C.Amber      = C.Amber      or Color3.fromRGB(245, 158, 11)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local RelationshipsScreen = {}
RelationshipsScreen.__index = RelationshipsScreen

-- Debug logging
local DEBUG = false
local function log(...)
	if DEBUG then
		print("[RelationshipsScreen]", ...)
	end
end
local function logWarn(...)
	warn("[RelationshipsScreen]", ...)
end

-- Deep debug for relationships
local function debugRelationships(rels, label)
	if not DEBUG then return end
	label = label or "Relationships"
	print("[RelationshipsScreen] === " .. label .. " DEBUG ===")
	if not rels then
		print("  Relationships table is NIL")
		return
	end
	local count = 0
	for id, rel in pairs(rels) do
		count = count + 1
		if type(rel) == "table" then
			print("  [" .. tostring(id) .. "] name=" .. tostring(rel.name) .. " role=" .. tostring(rel.role) .. " type=" .. tostring(rel.type) .. " alive=" .. tostring(rel.alive))
		else
			print("  [" .. tostring(id) .. "] = " .. tostring(rel))
		end
	end
	print("  Total: " .. count .. " relationships")
	print("[RelationshipsScreen] === END DEBUG ===")
end

local function safeLower(value)
	if typeof(value) ~= "string" then
		return ""
	end
	return string.lower(value)
end

-- Stable key builder for deduping relationships
local function getRelKey(id, rel)
	if type(rel) ~= "table" then return nil end
	if rel.id ~= nil then
		return tostring(rel.id)
	end
	if id ~= nil then
		return tostring(id)
	end
	local name = rel.name or "?"
	local role = rel.role or rel.type or "?"
	return name .. "|" .. role
end

local function isAliveFromRel(rel)
	if type(rel) ~= "table" then
		return true
	end
	if rel.alive ~= nil then
		return rel.alive ~= false
	end
	if rel.isDead ~= nil then
		return not rel.isDead
	end
	return true
end

-- Robust categorizer so new backend shapes don't break UI
-- CRITICAL FIX: Friend was showing in Romance tab because flags-based detection was too aggressive
local function categorizeRelationship(rel, flags)
	if type(rel) ~= "table" then
		return nil
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #REL-1: Check explicit category FIRST - this is most reliable
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	if typeof(rel.category) == "string" then
		local cat = safeLower(rel.category)
		if cat == "family" or cat == "romance" or cat == "friend" or cat == "enemy" then
			return cat
		end
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #REL-2: Check explicit type - backend sets this on creation
	-- This MUST come before any role-based or flag-based detection!
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local t = safeLower(rel.type or "")

	if t == "family" then
		return "family"
	elseif t == "romance" or t == "romantic" or t == "partner" or t == "lover" or t == "spouse" or t == "fiance" then
		return "romance"
	elseif t == "friend" or t == "friends" then
		return "friend"
	elseif t == "enemy" or t == "rival" then
		return "enemy"
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #REL-3: Check isFamily/isFriend/isRomance explicit flags
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	if rel.isFamily or rel.is_family then
		return "family"
	end
	if rel.isFriend or rel.is_friend then
		return "friend"
	end
	-- CRITICAL FIX: More comprehensive romance detection including marriage
	if rel.isRomance or rel.is_romance or rel.isPartner or rel.is_partner 
		or rel.isSpouse or rel.is_spouse or rel.isMarried or rel.married then
		return "romance"
	end
	if rel.isEnemy or rel.is_enemy then
		return "enemy"
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #REL-4: Role-based detection for family members
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local roleLower = safeLower(rel.role or "")

	if roleLower ~= "" then
		-- Family roles - be comprehensive
		if roleLower:find("mother") or roleLower:find("mom") then
			return "family"
		end
		if roleLower:find("father") or roleLower:find("dad") then
			return "family"
		end
		if roleLower:find("grand") then
			return "family"
		end
		if roleLower:find("brother") or roleLower:find("sister") or roleLower:find("sibling") then
			return "family"
		end
		if roleLower:find("son") or roleLower:find("daughter") or roleLower:find("child") then
			return "family"
		end
		if roleLower:find("aunt") or roleLower:find("uncle") or roleLower:find("cousin") then
			return "family"
		end
		
		-- Romance roles - only explicit romantic titles
		if roleLower:find("wife") or roleLower:find("husband") or roleLower:find("spouse") then
			return "romance"
		end
		if roleLower:find("fianc") or roleLower:find("boyfriend") or roleLower:find("girlfriend") then
			return "romance"
		end
		if roleLower:find("partner") and not roleLower:find("business") then
			return "romance"
		end
		
		-- Friend role - CRITICAL FIX: Check this BEFORE falling through to flags
		if roleLower:find("friend") then
			return "friend"
		end
		
		-- Enemy role
		if roleLower:find("enemy") or roleLower:find("rival") or roleLower:find("nemesis") then
			return "enemy"
		end
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #REL-5: REMOVED broken flag-based detection!
	-- OLD BUG: If flags.has_partner was true, ALL uncategorized relationships 
	-- were being put in romance tab - even friends!
	-- The flags should NOT determine where a SPECIFIC relationship goes,
	-- they only indicate the player's overall status.
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- REMOVED: local f = flags or {}
	-- REMOVED: if f.married or f.has_partner or f.committed_relationship then
	-- REMOVED:     return "romance"
	-- REMOVED: end

	return nil
end

-- Remotes
local remotesFolder = ReplicatedStorage:FindFirstChild("LifeRemotes")
	or ReplicatedStorage:WaitForChild("LifeRemotes", 3)

local function getRemote(name)
	return remotesFolder and (remotesFolder:FindFirstChild(name)
		or remotesFolder:WaitForChild(name, 1))
end

local DoInteraction = getRemote("DoInteraction")

-- Relationship Actions ---------------------------------------------------------

local FamilyActions = {
	{ id = "hug",       name = "Hug",           emoji = "Hug",   effect = "+Relationship" },
	{ id = "talk",      name = "Talk",          emoji = "Talk",  effect = "+Relationship" },
	{ id = "gift",      name = "Give Gift",     emoji = "Gift",  effect = "+Relationship", cost = 100 },
	{ id = "argue",     name = "Argue",         emoji = "Argue", effect = "-Relationship" },
	{ id = "money",     name = "Ask for Money", emoji = "Money", effect = "+Money maybe" },
	{ id = "vacation",  name = "Vacation",      emoji = "Travel",effect = "+Relationship", cost = 2000 },
	{ id = "apologize", name = "Apologize",     emoji = "Sorry", effect = "+Relationship" },
}

local RomanceActions = {
	{ id = "date",       name = "Go on Date",   emoji = "Date",  effect = "+Relationship", cost = 100 },
	{ id = "gift",       name = "Give Gift",    emoji = "Gift",  effect = "+Relationship", cost = 200 },
	{ id = "kiss",       name = "Kiss",         emoji = "Kiss",  effect = "+Relationship" },
	{ id = "propose",    name = "Propose",      emoji = "Ring",  effect = "Engagement", cost = 5000 },
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Added "Get Married" option for engaged couples!
	-- After proposing and getting engaged, players need to actually get married!
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	{ id = "get_married", name = "Get Married", emoji = "Wedding", effect = "Marriage!", cost = 10000, requiresEngaged = true },
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Added "Have a Kid" option!
	-- User bug: "I DONT HAVE A HAVE A KID OPTION IN RELASHONSHIP"
	-- Partner can accept or decline, then you have a baby!
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	{ id = "try_baby",   name = "Have a Kid",   emoji = "Baby",  effect = "Maybe Baby!" },
	{ id = "breakup",    name = "Break Up",     emoji = "Break", effect = "End Relationship" },
	{ id = "flirt",      name = "Flirt",        emoji = "Flirt", effect = "+Relationship" },
	{ id = "compliment", name = "Compliment",   emoji = "Nice",  effect = "+Relationship" },
	-- Targetless romance action exists as "Find" card: meet_someone
}

local FriendActions = {
	{ id = "hangout", name = "Hang Out",       emoji = "Party", effect = "+Relationship" },
	{ id = "gift",    name = "Give Gift",      emoji = "Gift",  effect = "+Relationship", cost = 50 },
	{ id = "support", name = "Support",        emoji = "Help",  effect = "+Relationship" },
	{ id = "party",   name = "Party Together", emoji = "Dance", effect = "+Relationship" },
	{ id = "betray",  name = "Betray",         emoji = "Bad",   effect = "-Relationship" },
	{ id = "ghost",   name = "Ghost",          emoji = "Ghost", effect = "End Friendship" },
	-- Targetless friend action exists as "Meet" card: make_friend
}

local EnemyActions = {
	{ id = "insult",  name = "Insult",  emoji = "Angry", effect = "-Relationship" },
	{ id = "fight",   name = "Fight",   emoji = "Fight", effect = "Physical!" },
	{ id = "forgive", name = "Forgive", emoji = "Peace", effect = "Make Peace" },
	{ id = "prank",   name = "Prank",   emoji = "Prank", effect = "-Relationship" },
	{ id = "ignore",  name = "Ignore",  emoji = "Ignore",effect = "Nothing" },
}

local function getActionDisplayName(actionId, relType)
	local list
	if relType == "family" then
		list = FamilyActions
	elseif relType == "romance" then
		list = RomanceActions
	elseif relType == "friend" then
		list = FriendActions
	elseif relType == "enemy" then
		list = EnemyActions
	end

	if list then
		for _, action in ipairs(list) do
			if action.id == actionId then
				return action.name or "Interaction"
			end
		end
	end

	return "Interaction"
end

local function getAccentForType(relType)
	if relType == "family" then
		return C.Cyan
	elseif relType == "romance" then
		return C.Pink
	elseif relType == "friend" then
		return C.Purple
	elseif relType == "enemy" then
		return C.Red
	end
	return C.Pink
end

-- Constructor ------------------------------------------------------------------

function RelationshipsScreen.new(screenGui, blurOverlay, showBlurFunc, hideBlurFunc, playerState)
	log("=== CREATING RelationshipsScreen ===")
	local self = setmetatable({}, RelationshipsScreen)

	self.screenGui    = screenGui
	self.playerState  = playerState or {}
	self.showBlur     = showBlurFunc
	self.hideBlur     = hideBlurFunc
	self.isVisible    = false
	self.currentTab   = "family"

	log("Initial state - Age:", self:getAge(), "Money:", self:getMoney())
	self:createUI()
	log("âœ… RelationshipsScreen created successfully")

	return self
end

function RelationshipsScreen:updateState(newState)
	log("=== UPDATE STATE CALLED ===")
	if not newState then 
		log("WARNING: updateState called with nil newState!")
		return 
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #25: Detect new life and reset relationship view
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local wasAge = self.playerState and self.playerState.Age or 0
	local newAge = newState.Age or 0
	local isNewLife = (wasAge > 5 and newAge <= 1)

	self.playerState = newState
	log("State updated - Age:", self:getAge(), "Money:", self:getMoney())

	-- CRITICAL DEBUG: Trace the Relationships field
	if newState.Relationships then
		debugRelationships(newState.Relationships, "Incoming State Relationships")
	else
		log("WARNING: newState.Relationships is NIL or missing!")
	end

	-- Debug: log relationships from our getter
	local rels = self:getRelationships()
	local relCount = 0
	for id, rel in pairs(rels) do
		if type(rel) == "table" then
			relCount += 1
			log("  Relationship:", id, "Type:", rel.type, "Name:", rel.name, "Role:", rel.role, "Alive:", rel.alive)
		end
	end
	log("Total relationships from getRelationships():", relCount)

	-- Force refresh on new life to show new family members
	if isNewLife then
		log("ğŸ”„ NEW LIFE DETECTED! Forcing relationship UI refresh")
		self.currentTab = "family" -- Reset to family tab for new life
	end

	if self.isVisible then
		self:updateInfoBar()
		self:switchTab(self.currentTab)
	end
end

function RelationshipsScreen:getAge()
	local state = self.playerState
	if not state then return 18 end
	return state.Age or (state.Stats and state.Stats.Age) or 18
end

function RelationshipsScreen:getMoney()
	local state = self.playerState
	if not state then return 1000 end
	return state.Money or (state.Stats and state.Stats.Money) or 1000
end

function RelationshipsScreen:getRelationships()
	local state = self.playerState
	if not state then return {} end
	return state.Relationships or {}
end

function RelationshipsScreen:getPlayerName()
	local state = self.playerState
	if state and state.Name then
		return state.Name
	end
	return "Player"
end

-- Count unique people across all relationships + family (for People chip)
function RelationshipsScreen:countTotalPeople()
	local seen  = {}
	local total = 0

	local rels = self:getRelationships()
	for id, rel in pairs(rels) do
		local key = getRelKey(id, rel)
		if key and not seen[key] then
			seen[key] = true
			total += 1
		end
	end

	for _, person in ipairs(self:getFamily()) do
		local key = person.id or (person.name .. "|" .. (person.role or ""))
		if key and not seen[key] then
			seen[key] = true
			total += 1
		end
	end

	if total == 0 then
		total = 2 -- feels weird to have â€œ0 Peopleâ€, assume parents
	end

	return total
end

-- UI creation ------------------------------------------------------------------

function RelationshipsScreen:createUI()
	----------------------------------------------------------------
	-- MAIN OVERLAY
	----------------------------------------------------------------
	self.overlay = Instance.new("Frame")
	self.overlay.Name = "RelationshipsOverlay"
	self.overlay.Size = UDim2.fromScale(1, 1)
	self.overlay.BackgroundColor3 = C.Bg
	self.overlay.Visible = false
	self.overlay.ZIndex = 80
	self.overlay.Parent = self.screenGui

	----------------------------------------------------------------
	-- HEADER - MOBILE FIX: Responsive sizing (CRITICAL: IS_TINY_PHONE support)
	-- CRITICAL FIX #317: Increased header height for better visibility
	----------------------------------------------------------------
	local HEADER_HEIGHT = IS_TINY_PHONE and 56 or (IS_SMALL_PHONE and 64 or px(80))

	local header = Instance.new("Frame")
	header.Name = "Header"
	header.Size = UDim2.new(1, 0, 0, HEADER_HEIGHT)
	header.BackgroundColor3 = C.Gray100
	header.BorderSizePixel = 0
	header.ZIndex = 84
	header.Parent = self.overlay

	local headerBottom = Instance.new("Frame")
	headerBottom.Name = "BottomBorder"
	headerBottom.Size = UDim2.new(1, 0, 0, 1)
	headerBottom.Position = UDim2.new(0, 0, 1, -1)
	headerBottom.BackgroundColor3 = C.Gray200
	headerBottom.BorderSizePixel = 0
	headerBottom.ZIndex = 85
	headerBottom.Parent = header

	-- MOBILE FIX: Responsive title
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "Title"
	titleLabel.Size = UDim2.new(1, -px(80), 1, 0)
	titleLabel.Position = UDim2.new(0, padSize(16), 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Font = F.Title
	titleLabel.TextSize = textSize(20)
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.TextColor3 = C.Gray900
	titleLabel.Text = "Relationships"
	titleLabel.ZIndex = 86
	titleLabel.Parent = header

	-- MOBILE FIX: Touch-friendly close button
	-- CRITICAL FIX #317: Made close button bigger for consistency
	local closeBtnSize = IS_TINY_PHONE and 36 or btnHeight(44)
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, closeBtnSize, 0, closeBtnSize)
	closeButton.AnchorPoint = Vector2.new(1, 0.5)
	closeButton.Position = UDim2.new(1, -padSize(16), 0.5, 0)
	closeButton.BackgroundColor3 = C.White
	closeButton.BackgroundTransparency = 0.1
	closeButton.Font = Enum.Font.GothamBold
	closeButton.TextSize = textSize(16)
	closeButton.TextColor3 = C.Gray600
	closeButton.Text = "âœ•"
	closeButton.AutoButtonColor = false
	closeButton.ZIndex = 87
	closeButton.Parent = header
	UI.corner(closeButton, px(16))

	closeButton.MouseButton1Click:Connect(function()
		self:hide()
	end)
	closeButton.MouseEnter:Connect(function()
		UI.tween(closeButton, TweenInfo.new(0.12), { BackgroundTransparency = 0 })
	end)
	closeButton.MouseLeave:Connect(function()
		UI.tween(closeButton, TweenInfo.new(0.12), { BackgroundTransparency = 0.1 })
	end)

	----------------------------------------------------------------
	-- BODY ROOT (everything under header lives here)
	----------------------------------------------------------------
	self.contentRoot = Instance.new("Frame")
	self.contentRoot.Name = "ContentRoot"
	self.contentRoot.BackgroundTransparency = 1
	self.contentRoot.ZIndex = 80
	self.contentRoot.Size = UDim2.new(1, 0, 1, -HEADER_HEIGHT)
	self.contentRoot.Position = UDim2.new(0, 0, 0, HEADER_HEIGHT)
	self.contentRoot.Parent = self.overlay

	-- MOBILE FIX: Responsive padding
	local pad = Instance.new("UIPadding")
	pad.PaddingLeft   = UDim.new(0, padSize(8))
	pad.PaddingRight  = UDim.new(0, padSize(8))
	pad.PaddingTop    = UDim.new(0, padSize(8))
	pad.PaddingBottom = UDim.new(0, padSize(12))
	pad.Parent = self.contentRoot

	----------------------------------------------------------------
	-- LAYOUT CONSTANTS (inside contentRoot) - CRITICAL FIX: IS_TINY_PHONE support
	----------------------------------------------------------------
	local INFO_HEIGHT   = IS_TINY_PHONE and 38 or 52
	local TAB_HEIGHT    = IS_TINY_PHONE and 40 or 52
	local GAP           = IS_TINY_PHONE and 4 or 8

	local infoY   = 0                           -- first row
	local tabY    = infoY   + INFO_HEIGHT + GAP -- second row
	local scrollY = tabY    + TAB_HEIGHT + GAP  -- rest

	----------------------------------------------------------------
	-- INFO BAR  (Age / Money / People)
	----------------------------------------------------------------
	self.infoBar = Instance.new("Frame")
	self.infoBar.Name = "InfoBar"
	self.infoBar.Size = UDim2.new(1, 0, 0, INFO_HEIGHT)
	self.infoBar.Position = UDim2.new(0, 0, 0, infoY)
	self.infoBar.BackgroundColor3 = C.White
	self.infoBar.ZIndex = 84
	self.infoBar.Parent = self.contentRoot
	UI.corner(self.infoBar, 14)
	UI.stroke(self.infoBar, 1, 0.9, C.Gray200)

	local infoLayout = Instance.new("UIListLayout")
	infoLayout.FillDirection = Enum.FillDirection.Horizontal
	infoLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	infoLayout.VerticalAlignment   = Enum.VerticalAlignment.Center
	infoLayout.Padding             = UDim.new(0, 10)
	infoLayout.Parent = self.infoBar

	-- Age chip
	self.ageChip = UI.createInfoChip(self.infoBar, {
		name      = "AgeChip",
		icon      = "",
		text      = "Age 18",
		bgColor   = C.BluePale,
		textColor = C.BlueDark,
		order     = 1,
		width     = 75,
	})
	self.ageChip.icon.Text = ""
	self.ageChip.text.Text = "Age 18"
	self.ageChip.text.Position       = UDim2.new(0, 8, 0, 0)
	self.ageChip.text.Size           = UDim2.new(1, -16, 1, 0)
	self.ageChip.text.TextXAlignment = Enum.TextXAlignment.Center

	-- Money chip
	self.moneyChip = UI.createInfoChip(self.infoBar, {
		name      = "MoneyChip",
		icon      = "",
		text      = "$1,000",
		bgColor   = C.GreenPale,
		textColor = C.GreenDark,
		order     = 2,
		width     = 85,
	})
	self.moneyChip.icon.Text = ""
	self.moneyChip.text.Text = "$1,000"
	self.moneyChip.text.Position       = UDim2.new(0, 8, 0, 0)
	self.moneyChip.text.Size           = UDim2.new(1, -16, 1, 0)
	self.moneyChip.text.TextXAlignment = Enum.TextXAlignment.Center

	-- People chip
	self.relationChip = UI.createInfoChip(self.infoBar, {
		name      = "RelationChip",
		icon      = "",
		text      = "0 People",
		bgColor   = C.PinkPale,
		textColor = C.PinkDark,
		order     = 3,
		width     = 95,
	})
	self.relationChip.icon.Text = ""
	self.relationChip.text.Text = "0 People"
	self.relationChip.text.Position       = UDim2.new(0, 8, 0, 0)
	self.relationChip.text.Size           = UDim2.new(1, -16, 1, 0)
	self.relationChip.text.TextXAlignment = Enum.TextXAlignment.Center

	----------------------------------------------------------------
	-- TAB BAR
	----------------------------------------------------------------
	self.tabBar = Instance.new("Frame")
	self.tabBar.Name = "TabBar"
	self.tabBar.Size = UDim2.new(1, 0, 0, TAB_HEIGHT)
	self.tabBar.Position = UDim2.new(0, 0, 0, tabY)
	self.tabBar.BackgroundColor3 = C.Gray100
	self.tabBar.ZIndex = 84
	self.tabBar.Parent = self.contentRoot
	UI.corner(self.tabBar, 14)
	UI.pad(self.tabBar, 5, 5, 5, 5)

	local tabLayout = Instance.new("UIListLayout")
	tabLayout.FillDirection = Enum.FillDirection.Horizontal
	tabLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	tabLayout.VerticalAlignment   = Enum.VerticalAlignment.Center
	tabLayout.Padding             = UDim.new(0, 6)
	tabLayout.Parent = self.tabBar

	local tabs = {
		{ id = "family",   text = "Family",   color = C.Cyan },
		{ id = "romance",  text = "Romance",  color = C.Pink },
		{ id = "friends",  text = "Friends",  color = C.Purple },
		{ id = "enemies",  text = "Enemies",  color = C.Red },
	}

	self.tabBtns = {}
	for i, tab in ipairs(tabs) do
		local btn = Instance.new("TextButton")
		btn.Name = tab.id
		btn.Size = UDim2.new(0.24, 0, 1, 0)
		btn.BackgroundColor3 = (tab.id == "family") and tab.color or C.White
		btn.Font = F.Button
		btn.TextSize = 13
		btn.TextColor3 = (tab.id == "family") and C.White or C.Gray600
		btn.Text = tab.text
		btn.AutoButtonColor = false
		btn.LayoutOrder = i
		btn.ZIndex = 85
		btn.Parent = self.tabBar
		UI.corner(btn, 10)

		self.tabBtns[tab.id] = { btn = btn, color = tab.color }
		btn.MouseButton1Click:Connect(function()
			self:switchTab(tab.id)
		end)
	end

	----------------------------------------------------------------
	-- SCROLL AREA (cards list)
	----------------------------------------------------------------
	self.contentScroll = Instance.new("ScrollingFrame")
	self.contentScroll.Name = "ContentScroll"
	self.contentScroll.Position = UDim2.new(0, 0, 0, scrollY)
	self.contentScroll.Size = UDim2.new(1, 0, 1, -scrollY)
	self.contentScroll.BackgroundTransparency = 1
	self.contentScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
	self.contentScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
	self.contentScroll.ScrollBarThickness = 4
	self.contentScroll.ScrollBarImageColor3 = C.Gray300
	self.contentScroll.ZIndex = 81
	self.contentScroll.Parent = self.contentRoot

	local contentLayout = Instance.new("UIListLayout")
	contentLayout.Padding = UDim.new(0, 12)
	contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
	contentLayout.Parent = self.contentScroll

	----------------------------------------------------------------
	-- INTERACTION + RESULT MODALS
	----------------------------------------------------------------
	self:createInteractionModal()
	self:createResultModal()

	-- Initial populate
	self:populateFamily()
end

function RelationshipsScreen:updateInfoBar()
	if not (self.ageChip and self.moneyChip and self.relationChip) then
		return
	end

	self.ageChip.text.Text   = "Age " .. self:getAge()
	self.moneyChip.text.Text = UI.formatMoney(self:getMoney())

	local totalPeople = self:countTotalPeople()
	self.relationChip.text.Text = tostring(totalPeople) .. " People"
end

function RelationshipsScreen:switchTab(tabId)
	self.currentTab = tabId

	-- Tab highlight
	for id, data in pairs(self.tabBtns) do
		local isActive = (id == tabId)
		UI.tween(data.btn, TweenInfo.new(0.15), {
			BackgroundColor3 = isActive and data.color or C.White,
			TextColor3       = isActive and C.White or C.Gray600,
		})
	end

	-- Clear content and reset scroll
	for _, child in ipairs(self.contentScroll:GetChildren()) do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end
	self.contentScroll.CanvasPosition = Vector2.new(0, 0)

	if tabId == "family" then
		self:populateFamily()
	elseif tabId == "romance" then
		self:populateRomance()
	elseif tabId == "friends" then
		self:populateFriends()
	elseif tabId == "enemies" then
		self:populateEnemies()
	end
end

-- FAMILY -----------------------------------------------------------------------

local FamilyEmojis = {
	mother      = "ğŸ‘©",
	father      = "ğŸ‘¨",
	grandmother = "ğŸ‘µ",
	grandfather = "ğŸ‘´",
	brother     = "ğŸ‘¦",
	sister      = "ğŸ‘§",
	son         = "ğŸ‘¦",
	daughter    = "ğŸ‘§",
	baby        = "ğŸ‘¶",
	spouse      = "ğŸ’‘",
	wife        = "ğŸ‘©",
	husband     = "ğŸ‘¨",
}

function RelationshipsScreen:getFamilyEmoji(role, gender, age)
	local lowerRole = safeLower(role or "")
	local lowerGender = safeLower(gender or "")
	local personAge = age or 25
	
	-- Mother/Father
	if lowerRole:find("mother")   or lowerRole:find("mom")   then return "ğŸ‘©" end
	if lowerRole:find("father")   or lowerRole:find("dad")   then return "ğŸ‘¨" end
	-- Grandparents
	if lowerRole:find("grandmother") or lowerRole:find("grandma") then return "ğŸ‘µ" end
	if lowerRole:find("grandfather") or lowerRole:find("grandpa") then return "ğŸ‘´" end
	-- Siblings
	if lowerRole:find("brother")  then return "ğŸ‘¦" end
	if lowerRole:find("sister")   then return "ğŸ‘§" end
	-- Children
	if lowerRole:find("son")      then return personAge < 3 and "ğŸ‘¶" or "ğŸ‘¦" end
	if lowerRole:find("daughter") then return personAge < 3 and "ğŸ‘¶" or "ğŸ‘§" end
	if lowerRole:find("child")    then return personAge < 3 and "ğŸ‘¶" or "ğŸ‘§" end
	if lowerRole:find("baby")     then return "ğŸ‘¶" end
	-- Spouse
	if lowerRole:find("wife")     then return "ğŸ‘©" end
	if lowerRole:find("husband")  then return "ğŸ‘¨" end
	if lowerRole:find("spouse")   then return "ğŸ’‘" end
	-- Extended family
	if lowerRole:find("aunt")     then return "ğŸ‘©" end
	if lowerRole:find("uncle")    then return "ğŸ‘¨" end
	if lowerRole:find("cousin")   then return lowerGender == "female" and "ğŸ‘§" or "ğŸ‘¦" end
	if lowerRole:find("niece")    then return "ğŸ‘§" end
	if lowerRole:find("nephew")   then return "ğŸ‘¦" end
	-- Step-relations
	if lowerRole:find("step") and lowerRole:find("mother") then return "ğŸ‘©" end
	if lowerRole:find("step") and lowerRole:find("father") then return "ğŸ‘¨" end
	if lowerRole:find("step") and lowerRole:find("brother") then return "ğŸ‘¦" end
	if lowerRole:find("step") and lowerRole:find("sister") then return "ğŸ‘§" end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Use gender field when role doesn't match
	-- User bug: "FAMILY NOT LIKE DAD OR MOM... JUST SAYS FAMILY"
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	if lowerGender == "female" or lowerGender == "f" then return "ğŸ‘©" end
	if lowerGender == "male" or lowerGender == "m" then return "ğŸ‘¨" end
	
	return "ğŸ‘¤"
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: Helper to get proper emoji for romance partners
-- User bug: "PARTNER... NO EMOJI IT JUST BLANK PERSON EMOJI INSTEAD OF GUY OR GIRL"
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function RelationshipsScreen:getPartnerEmoji(person)
	local gender = safeLower(person.gender or person.Gender or "")
	local role = safeLower(person.role or "")
	
	-- Check explicit gender field
	if gender == "female" or gender == "f" then return "ğŸ‘©" end
	if gender == "male" or gender == "m" then return "ğŸ‘¨" end
	
	-- Check role for gender hints
	if role:find("girlfriend") or role:find("wife") then return "ğŸ‘©" end
	if role:find("boyfriend") or role:find("husband") then return "ğŸ‘¨" end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Determine partner gender based on PLAYER's gender (opposite sex)
	-- User bug: "ENSURE IF A GUY U GET A GIRL AND IF GIRL U GET GUYS"
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local playerGender = safeLower(self.playerState and self.playerState.Gender or "")
	if playerGender == "male" or playerGender == "m" then
		return "ğŸ‘©"  -- Male player gets female partner
	elseif playerGender == "female" or playerGender == "f" then
		return "ğŸ‘¨"  -- Female player gets male partner
	end
	
	return "ğŸ‘¤"
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: Helper to determine proper family role label
-- User bug: "OTHER FAMILY SAYS JUST FAMILY FAMILY FAMILY"
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function RelationshipsScreen:determineFamilyRole(rel, playerAge)
	local role = rel.role or ""
	local type_ = rel.type or ""
	local id = safeLower(rel.id or "")
	local name = safeLower(rel.name or "")
	local gender = safeLower(rel.gender or rel.Gender or "")
	local relAge = rel.age or 25
	
	-- If role is already set and meaningful, use it
	if role ~= "" and role ~= "Family" and role ~= "family" then
		return role
	end
	
	-- Try to determine from type
	if type_ ~= "" and type_ ~= "family" then
		if type_:lower():find("mother") then return "Mother" end
		if type_:lower():find("father") then return "Father" end
		if type_:lower():find("son") then return "Son" end
		if type_:lower():find("daughter") then return "Daughter" end
		if type_:lower():find("brother") then return "Brother" end
		if type_:lower():find("sister") then return "Sister" end
	end
	
	-- Try to determine from id
	if id:find("mother") or id:find("mom") then return "Mother" end
	if id:find("father") or id:find("dad") then return "Father" end
	if id:find("son") then return "Son" end
	if id:find("daughter") then return "Daughter" end
	if id:find("brother") then return "Brother" end
	if id:find("sister") then return "Sister" end
	if id:find("grandma") or id:find("grandmother") then return "Grandmother" end
	if id:find("grandpa") or id:find("grandfather") then return "Grandfather" end
	if id:find("child") or id:find("kid") then 
		return gender == "female" and "Daughter" or "Son"
	end
	
	-- Try to determine from name
	if name:find("mom") or name:find("mother") then return "Mother" end
	if name:find("dad") or name:find("father") then return "Father" end
	
	-- Try to determine from age difference
	if playerAge then
		local ageDiff = relAge - playerAge
		if ageDiff >= 18 then
			-- Could be a parent
			return gender == "female" and "Mother" or "Father"
		elseif ageDiff <= -18 then
			-- Could be a child
			return gender == "female" and "Daughter" or "Son"
		elseif math.abs(ageDiff) <= 10 then
			-- Could be a sibling
			if ageDiff > 0 then
				return gender == "female" and "Older Sister" or "Older Brother"
			else
				return gender == "female" and "Younger Sister" or "Younger Brother"
			end
		end
	end
	
	-- Last resort - use gender for generic label
	if gender == "female" then return "Female Relative" end
	if gender == "male" then return "Male Relative" end
	
	return "Family"
end

function RelationshipsScreen:getFamily()
	log("=== GET FAMILY CALLED ===")
	local rels   = self:getRelationships()
	local age    = self:getAge()
	local flags  = (self.playerState and self.playerState.Flags) or {}
	local family = {}

	log("Checking relationships for family members...")
	-- Use stored family if present in Relationships table or flagged isFamily
	for id, rel in pairs(rels) do
		if type(rel) == "table" then
			local cat = categorizeRelationship(rel, flags)
			log("  Checking:", id, "-> category:", cat, "name:", rel.name, "type:", rel.type, "isFamily:", rel.isFamily)
			if cat == "family" then
				log("    -> ADDING to family list")
				-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				-- CRITICAL FIX: Use improved role detection instead of defaulting to "Family"
				-- User bug: "OTHER FAMILY SAYS JUST FAMILY FAMILY FAMILY"
				-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				local determinedRole = self:determineFamilyRole(rel, age)
				local relAge = rel.age or age
				local relGender = rel.gender or rel.Gender or ""
				table.insert(family, {
					id           = rel.id or id,
					name         = rel.name,
					role         = determinedRole,
					emoji        = self:getFamilyEmoji(determinedRole, relGender, relAge),
					relationship = rel.relationship or 75,
					age          = relAge,
					alive        = isAliveFromRel(rel),
				})
			end
		end
	end

	log("Found", #family, "family members from server relationships")

	-- Generated defaults if no explicit family stored
	if #family == 0 then
		log("No server family found, generating defaults...")
		local motherAge = math.max(age + 22, 22)
		local fatherAge = math.max(age + 25, 25)

		family = {
			{
				id           = "mother",
				name         = "Mom",
				role         = "Mother",
				emoji        = "ğŸ‘©",
				relationship = 80,
				age          = motherAge,
				alive        = motherAge < 90,
			},
			{
				id           = "father",
				name         = "Dad",
				role         = "Father",
				emoji        = "ğŸ‘¨",
				relationship = 75,
				age          = fatherAge,
				alive        = fatherAge < 85,
			},
		}

		-- Siblings
		if age > 5 then
			local hasBrother = (age % 4 == 0) or (age % 7 == 1)
			local hasSister  = (age % 5 == 0) or (age % 6 == 2)

			if hasBrother then
				local sibAge  = math.max(age + (age % 2 == 0 and -3 or 2), 1)
				local sibRole = sibAge > age and "Older Brother" or "Younger Brother"
				table.insert(family, {
					id           = "brother",
					name         = sibAge > age and "Big Bro" or "Lil Bro",
					role         = sibRole,
					emoji        = "ğŸ‘¦",
					relationship = 65,
					age          = sibAge,
					alive        = true,
				})
			end

			if hasSister then
				local sibAge  = math.max(age + (age % 3 == 0 and 2 or -2), 1)
				local sibRole = sibAge > age and "Older Sister" or "Younger Sister"
				table.insert(family, {
					id           = "sister",
					name         = sibAge > age and "Big Sis" or "Lil Sis",
					role         = sibRole,
					emoji        = "ğŸ‘§",
					relationship = 68,
					age          = sibAge,
					alive        = true,
				})
			end
		end

		-- Grandparents if you're young
		if age < 30 then
			local grandmaAge = motherAge + 25
			local grandpaAge = fatherAge + 28

			table.insert(family, {
				id           = "grandma",
				name         = "Grandma",
				role         = "Grandmother",
				emoji        = "ğŸ‘µ",
				relationship = 70,
				age          = grandmaAge,
				alive        = grandmaAge < 88,
			})
			table.insert(family, {
				id           = "grandpa",
				name         = "Grandpa",
				role         = "Grandfather",
				emoji        = "ğŸ‘´",
				relationship = 65,
				age          = grandpaAge,
				alive        = grandpaAge < 85,
			})
		end

		-- Children if you're older
		if age >= 25 then
			local hasKid = (age % 3 == 0) or (age >= 30)
			if hasKid then
				local kidAge = math.max(age - 25, 1)
				local isBoy  = age % 2 == 0
				table.insert(family, {
					id           = "child1",
					name         = isBoy and "Son" or "Daughter",
					role         = isBoy and "Son" or "Daughter",
					emoji        = kidAge < 3 and "ğŸ‘¶" or (isBoy and "ğŸ‘¦" or "ğŸ‘§"),
					relationship = 85,
					age          = kidAge,
					alive        = true,
				})
			end
		end
	end

	return family
end

function RelationshipsScreen:populateFamily()
	self:updateInfoBar()

	local family = self:getFamily()

	local section = Instance.new("Frame")
	section.Name = "FamilySection"
	section.Size = UDim2.new(1, 0, 0, 0)
	section.AutomaticSize = Enum.AutomaticSize.Y
	section.BackgroundColor3 = C.White
	section.LayoutOrder = 1
	section.ZIndex = 82
	section.Parent = self.contentScroll
	UI.corner(section, 18)
	UI.stroke(section, 1, 0.88, C.Gray200)
	UI.pad(section, 14, 14, 14, 16)

	local sectionLayout = Instance.new("UIListLayout")
	sectionLayout.Padding = UDim.new(0, 10)
	sectionLayout.SortOrder = Enum.SortOrder.LayoutOrder
	sectionLayout.Parent = section

	-- Header
	local header = Instance.new("Frame")
	header.Size = UDim2.new(1, 0, 0, 36)
	header.BackgroundTransparency = 1
	header.LayoutOrder = 0
	header.ZIndex = 83
	header.Parent = section

	local badge = Instance.new("Frame")
	badge.Size = UDim2.new(0, 130, 0, 32)
	badge.BackgroundColor3 = C.Cyan
	badge.ZIndex = 84
	badge.Parent = header
	UI.pill(badge)

	local badgeLabel = Instance.new("TextLabel")
	badgeLabel.Size = UDim2.fromScale(1, 1)
	badgeLabel.BackgroundTransparency = 1
	badgeLabel.Font = F.Button
	badgeLabel.TextSize = 14
	badgeLabel.TextColor3 = C.White
	badgeLabel.Text = "Family Members"
	badgeLabel.ZIndex = 85
	badgeLabel.Parent = badge

	local countLabel = Instance.new("TextLabel")
	countLabel.Size = UDim2.new(0, 80, 1, 0)
	countLabel.Position = UDim2.new(0, 140, 0, 0)
	countLabel.BackgroundTransparency = 1
	countLabel.Font = F.Medium
	countLabel.TextSize = 13
	countLabel.TextColor3 = C.Gray400
	countLabel.TextXAlignment = Enum.TextXAlignment.Left
	countLabel.Text = #family .. " people"
	countLabel.ZIndex = 84
	countLabel.Parent = header

	-- CRITICAL FIX: Premium empty state for no family
	if #family == 0 then
		createPremiumEmptyCard(section, {
			emoji = "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§",
			title = "No Family Members",
			message = "Your family will appear here as you progress through life.",
			accentColor = C.Cyan,
			layoutOrder = 1
		})
	else
		for i, person in ipairs(family) do
			self:createPersonCard(section, person, i, C.Cyan, C.CyanPale, "family")
		end
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Show pets at the bottom of the Family tab!
	-- User bug: "FOR RELASHONSHIPS HAVE PETS BE IN FAMILY AT THE BOTTOM"
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local pets = self:getPets()
	if #pets > 0 then
		-- Pet section header
		local petSection = Instance.new("Frame")
		petSection.Name = "PetSection"
		petSection.Size = UDim2.new(1, 0, 0, 0)
		petSection.AutomaticSize = Enum.AutomaticSize.Y
		petSection.BackgroundColor3 = C.White
		petSection.LayoutOrder = 100 -- Put at bottom
		petSection.ZIndex = 82
		petSection.Parent = self.contentScroll
		UI.corner(petSection, 18)
		UI.stroke(petSection, 1, 0.88, C.Gray200)
		UI.pad(petSection, 14, 14, 14, 16)

		local petLayout = Instance.new("UIListLayout")
		petLayout.Padding = UDim.new(0, 10)
		petLayout.SortOrder = Enum.SortOrder.LayoutOrder
		petLayout.Parent = petSection

		-- Pet header
		local petHeader = Instance.new("Frame")
		petHeader.Size = UDim2.new(1, 0, 0, 36)
		petHeader.BackgroundTransparency = 1
		petHeader.LayoutOrder = 0
		petHeader.ZIndex = 83
		petHeader.Parent = petSection

		local petBadge = Instance.new("Frame")
		petBadge.Size = UDim2.new(0, 100, 0, 32)
		petBadge.BackgroundColor3 = Color3.fromRGB(255, 152, 0) -- Orange for pets
		petBadge.ZIndex = 84
		petBadge.Parent = petHeader
		UI.pill(petBadge)

		local petBadgeLabel = Instance.new("TextLabel")
		petBadgeLabel.Size = UDim2.fromScale(1, 1)
		petBadgeLabel.BackgroundTransparency = 1
		petBadgeLabel.Font = F.Button
		petBadgeLabel.TextSize = 14
		petBadgeLabel.TextColor3 = C.White
		petBadgeLabel.Text = "ğŸ¾ Pets"
		petBadgeLabel.ZIndex = 85
		petBadgeLabel.Parent = petBadge

		local petCountLabel = Instance.new("TextLabel")
		petCountLabel.Size = UDim2.new(0, 80, 1, 0)
		petCountLabel.Position = UDim2.new(0, 110, 0, 0)
		petCountLabel.BackgroundTransparency = 1
		petCountLabel.Font = F.Medium
		petCountLabel.TextSize = 13
		petCountLabel.TextColor3 = C.Gray400
		petCountLabel.TextXAlignment = Enum.TextXAlignment.Left
		petCountLabel.Text = #pets .. " pet" .. (#pets > 1 and "s" or "")
		petCountLabel.ZIndex = 84
		petCountLabel.Parent = petHeader

		-- Create pet cards
		for i, pet in ipairs(pets) do
			self:createPetCard(petSection, pet, i)
		end
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: Get pets from player state
-- User bug: "FOR RELASHONSHIPS HAVE PETS BE IN FAMILY AT THE BOTTOM"
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function RelationshipsScreen:getPets()
	local pets = {}
	local flags = (self.playerState and self.playerState.Flags) or {}
	local petData = (self.playerState and self.playerState.PetData) or {}
	
	-- Check for dog
	if flags.has_dog then
		table.insert(pets, {
			id = "dog",
			name = petData.dogName or "Buddy",
			type = "Dog",
			emoji = "ğŸ•",
			age = petData.dogAge or 1,
			alive = true,
		})
	end
	
	-- Check for cat
	if flags.has_cat then
		table.insert(pets, {
			id = "cat",
			name = petData.catName or "Whiskers",
			type = "Cat",
			emoji = "ğŸ±",
			age = petData.catAge or 1,
			alive = true,
		})
	end
	
	-- Check for small pet
	if flags.has_small_pet then
		table.insert(pets, {
			id = "small_pet",
			name = petData.smallPetName or "Little One",
			type = "Small Pet",
			emoji = "ğŸ¹",
			age = petData.smallPetAge or 1,
			alive = true,
		})
	end
	
	-- Check for fish
	if flags.has_fish then
		table.insert(pets, {
			id = "fish",
			name = petData.fishName or "Goldie",
			type = "Fish",
			emoji = "ğŸ ",
			age = petData.fishAge or 1,
			alive = true,
		})
	end
	
	-- Check for bird
	if flags.has_bird then
		table.insert(pets, {
			id = "bird",
			name = petData.birdName or "Tweety",
			type = "Bird",
			emoji = "ğŸ¦",
			age = petData.birdAge or 1,
			alive = true,
		})
	end
	
	return pets
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: Create pet card for Family tab
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function RelationshipsScreen:createPetCard(parent, pet, index)
	local card = Instance.new("Frame")
	card.Name = "PetCard_" .. pet.id
	card.Size = UDim2.new(1, 0, 0, 70)
	card.BackgroundColor3 = Color3.fromRGB(255, 248, 225) -- Warm orange-ish
	card.LayoutOrder = index
	card.ZIndex = 83
	card.Parent = parent
	UI.corner(card, 14)
	UI.stroke(card, 1, 0.85, Color3.fromRGB(255, 200, 100))

	-- Pet emoji
	local emojiLabel = Instance.new("TextLabel")
	emojiLabel.Size = UDim2.new(0, 50, 0, 50)
	emojiLabel.Position = UDim2.new(0, 12, 0.5, -25)
	emojiLabel.BackgroundTransparency = 1
	emojiLabel.Font = F.Body
	emojiLabel.TextSize = 32
	emojiLabel.Text = pet.emoji or "ğŸ¾"
	emojiLabel.ZIndex = 84
	emojiLabel.Parent = card

	-- Pet name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(0.5, -70, 0, 24)
	nameLabel.Position = UDim2.new(0, 70, 0, 12)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Font = F.Bold
	nameLabel.TextSize = 16
	nameLabel.TextColor3 = C.Black
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.Text = pet.name or "Pet"
	nameLabel.ZIndex = 84
	nameLabel.Parent = card

	-- Pet type and age
	local infoLabel = Instance.new("TextLabel")
	infoLabel.Size = UDim2.new(0.5, -70, 0, 18)
	infoLabel.Position = UDim2.new(0, 70, 0, 38)
	infoLabel.BackgroundTransparency = 1
	infoLabel.Font = F.Medium
	infoLabel.TextSize = 13
	infoLabel.TextColor3 = C.Gray500
	infoLabel.TextXAlignment = Enum.TextXAlignment.Left
	infoLabel.Text = string.format("%s â€¢ %d year%s old", pet.type or "Pet", pet.age or 1, pet.age == 1 and "" or "s")
	infoLabel.ZIndex = 84
	infoLabel.Parent = card

	-- Heart/love indicator
	local loveLabel = Instance.new("TextLabel")
	loveLabel.Size = UDim2.new(0, 30, 0, 30)
	loveLabel.Position = UDim2.new(1, -50, 0.5, -15)
	loveLabel.BackgroundTransparency = 1
	loveLabel.Font = F.Body
	loveLabel.TextSize = 24
	loveLabel.Text = "â¤ï¸"
	loveLabel.ZIndex = 84
	loveLabel.Parent = card

	return card
end

-- ROMANCE ----------------------------------------------------------------------

function RelationshipsScreen:populateRomance()
	self:updateInfoBar()

	local age = self:getAge()

	if age < 16 then
		-- CRITICAL FIX: Premium "Too Young" card
		createPremiumEmptyCard(self.contentScroll, {
			emoji = "ğŸ‘¶",
			title = "Too Young for Romance!",
			message = "Romance features unlock when you turn 16. Focus on school and family for now!",
			accentColor = C.Pink,
			layoutOrder = 1
		})
		return
	end

	local romances = {}
	local rels = self:getRelationships()
	local flags = (self.playerState and self.playerState.Flags) or {}
	local seen = {}

	for id, rel in pairs(rels) do
		if type(rel) == "table" then
			local cat = categorizeRelationship(rel, flags)
			if cat == "romance" then
				local key = getRelKey(id, rel)
				if key and not seen[key] then
					seen[key] = true
					-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
					-- CRITICAL FIX: Determine partner role and emoji properly
					-- User bug: "PARTNER... NO EMOJI IT JUST BLANK PERSON EMOJI INSTEAD OF GUY OR GIRL"
					-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
					local partnerRole = rel.role or "Partner"
					local partnerGender = rel.gender or rel.Gender or ""
					
					-- If role is generic "Partner", try to make it more specific based on relationship state
					if partnerRole == "Partner" or partnerRole == "" then
						if rel.isSpouse or rel.married or flags.married then
							partnerRole = safeLower(partnerGender) == "female" and "Wife" or "Husband"
						elseif rel.isEngaged or rel.engaged or flags.engaged then
							partnerRole = "FiancÃ©"
						elseif safeLower(partnerGender) == "female" then
							partnerRole = "Girlfriend"
						elseif safeLower(partnerGender) == "male" then
							partnerRole = "Boyfriend"
						end
					end
					
					table.insert(romances, {
						id           = rel.id or id,
						name         = rel.name,
						role         = partnerRole,
						emoji        = self:getPartnerEmoji(rel), -- CRITICAL FIX: Add emoji!
						gender       = partnerGender, -- Store gender for later use
						relationship = rel.relationship or 50,
						age          = rel.age or age,
						alive        = isAliveFromRel(rel),
					})
				end
			end
		end
	end

	-- Meet someone card
	local meetCard = Instance.new("Frame")
	meetCard.Size = UDim2.new(1, 0, 0, 75)
	meetCard.BackgroundColor3 = C.PinkPale
	meetCard.LayoutOrder = 0
	meetCard.ZIndex = 82
	meetCard.Parent = self.contentScroll
	UI.corner(meetCard, 16)
	UI.stroke(meetCard, 1, 0.7, C.Pink)

	local meetIcon = Instance.new("TextLabel")
	meetIcon.Size = UDim2.new(0, 50, 0, 50)
	meetIcon.Position = UDim2.new(0, 14, 0.5, -25)
	meetIcon.BackgroundTransparency = 1
	meetIcon.Font = F.Body
	meetIcon.TextSize = 32
	meetIcon.TextColor3 = C.Pink
	meetIcon.Text = "ğŸ’•"
	meetIcon.ZIndex = 83
	meetIcon.Parent = meetCard

	local meetTitle = Instance.new("TextLabel")
	meetTitle.Size = UDim2.new(0.5, 0, 0, 26)
	meetTitle.Position = UDim2.new(0, 74, 0.5, -13)
	meetTitle.BackgroundTransparency = 1
	meetTitle.Font = F.Title
	meetTitle.TextSize = 16
	meetTitle.TextColor3 = C.PinkDark
	meetTitle.TextXAlignment = Enum.TextXAlignment.Left
	meetTitle.Text = "Meet Someone New"
	meetTitle.ZIndex = 83
	meetTitle.Parent = meetCard

	local meetBtn = Instance.new("TextButton")
	meetBtn.Size = UDim2.new(0, 80, 0, 40)
	meetBtn.AnchorPoint = Vector2.new(1, 0.5)
	meetBtn.Position = UDim2.new(1, -14, 0.5, 0)
	meetBtn.BackgroundColor3 = C.Pink
	meetBtn.Font = F.Button
	meetBtn.TextSize = 14
	meetBtn.TextColor3 = C.White
	meetBtn.Text = "Find"
	meetBtn.AutoButtonColor = false
	meetBtn.ZIndex = 83
	meetBtn.Parent = meetCard
	UI.corner(meetBtn, 12)

	meetBtn.MouseEnter:Connect(function()
		UI.tween(meetBtn, TweenInfo.new(0.12), { BackgroundColor3 = C.PinkDark })
	end)
	meetBtn.MouseLeave:Connect(function()
		UI.tween(meetBtn, TweenInfo.new(0.12), { BackgroundColor3 = C.Pink })
	end)
	meetBtn.MouseButton1Click:Connect(function()
		-- CRITICAL FIX: Pass explicit empty table {} to indicate "create new person"
		-- Previously nil fell back to self.currentInteractPerson (the friend they clicked on!)
		-- This caused "meet someone" to keep targeting the same friend instead of creating a new romantic interest
		self:doInteraction("meet_someone", "romance", {})
	end)

	if #romances > 0 then
		local section = Instance.new("Frame")
		section.Name = "RomanceSection"
		section.Size = UDim2.new(1, 0, 0, 0)
		section.AutomaticSize = Enum.AutomaticSize.Y
		section.BackgroundColor3 = C.White
		section.LayoutOrder = 1
		section.ZIndex = 82
		section.Parent = self.contentScroll
		UI.corner(section, 18)
		UI.stroke(section, 1, 0.88, C.Gray200)
		UI.pad(section, 14, 14, 14, 16)

		local sectionLayout = Instance.new("UIListLayout")
		sectionLayout.Padding = UDim.new(0, 10)
		sectionLayout.SortOrder = Enum.SortOrder.LayoutOrder
		sectionLayout.Parent = section

		-- Header
		local header = Instance.new("Frame")
		header.Size = UDim2.new(1, 0, 0, 36)
		header.BackgroundTransparency = 1
		header.LayoutOrder = 0
		header.ZIndex = 83
		header.Parent = section

		local badge = Instance.new("Frame")
		badge.Size = UDim2.new(0, 145, 0, 32)
		badge.BackgroundColor3 = C.Pink
		badge.ZIndex = 84
		badge.Parent = header
		UI.pill(badge)

		local badgeLabel = Instance.new("TextLabel")
		badgeLabel.Size = UDim2.fromScale(1, 1)
		badgeLabel.BackgroundTransparency = 1
		badgeLabel.Font = F.Button
		badgeLabel.TextSize = 14
		badgeLabel.TextColor3 = C.White
		badgeLabel.Text = "Romantic Partners"
		badgeLabel.ZIndex = 85
		badgeLabel.Parent = badge

		for i, person in ipairs(romances) do
			self:createPersonCard(section, person, i, C.Pink, C.PinkPale, "romance")
		end
	else
		-- CRITICAL FIX: Premium empty state for no romance
		createPremiumEmptyCard(self.contentScroll, {
			emoji = "ğŸ’”",
			title = "No Partners Yet",
			message = "You haven't found love yet. Tap 'Find' above to meet someone special!",
			accentColor = C.Pink,
			layoutOrder = 1
		})
	end
end

-- FRIENDS ----------------------------------------------------------------------

function RelationshipsScreen:populateFriends()
	self:updateInfoBar()

	local friends = {}
	local rels = self:getRelationships()
	local flags = (self.playerState and self.playerState.Flags) or {}
	local seen = {}

	log("populateFriends() - Scanning relationships...")
	local totalRels = 0

	for id, rel in pairs(rels) do
		totalRels += 1
		local relType = (type(rel) == "table") and rel.type or "NOT_A_TABLE"
		log("  Found:", id, "Type:", relType, "Name:", type(rel) == "table" and rel.name or "N/A")

		if type(rel) == "table" then
			local cat = categorizeRelationship(rel, flags)
			if cat == "friend" then
				local key = getRelKey(id, rel)
				if key and not seen[key] then
					seen[key] = true
					-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
					-- CRITICAL FIX: Add emoji for friends based on gender
					-- User bug: "NO EMOJI IT JUST BLANK PERSON EMOJI"
					-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
					local friendGender = safeLower(rel.gender or rel.Gender or "")
					local friendEmoji = "ğŸ‘¤"
					if friendGender == "female" or friendGender == "f" then
						friendEmoji = "ğŸ‘©"
					elseif friendGender == "male" or friendGender == "m" then
						friendEmoji = "ğŸ‘¨"
					end
					
					table.insert(friends, {
						id           = rel.id or id,
						name         = rel.name,
						role         = rel.role or "Friend",
						emoji        = friendEmoji,  -- CRITICAL FIX: Add emoji!
						gender       = friendGender,
						relationship = rel.relationship or 60,
						age          = rel.age or self:getAge(),
						alive        = isAliveFromRel(rel),
					})
					log("  âœ… Added friend:", rel.name)
				else
					log("  âš ï¸ Skipped duplicate friend:", rel.name)
				end
			end
		end
	end

	log("populateFriends() - Total relationships:", totalRels, "Friends found (unique):", #friends)

	-- Make friend card
	local makeCard = Instance.new("Frame")
	makeCard.Size = UDim2.new(1, 0, 0, 75)
	makeCard.BackgroundColor3 = C.PurplePale
	makeCard.LayoutOrder = 0
	makeCard.ZIndex = 82
	makeCard.Parent = self.contentScroll
	UI.corner(makeCard, 16)
	UI.stroke(makeCard, 1, 0.7, C.Purple)

	local makeIcon = Instance.new("TextLabel")
	makeIcon.Size = UDim2.new(0, 50, 0, 50)
	makeIcon.Position = UDim2.new(0, 14, 0.5, -25)
	makeIcon.BackgroundTransparency = 1
	makeIcon.Font = F.Body
	makeIcon.TextSize = 32
	makeIcon.TextColor3 = C.Purple
	makeIcon.Text = "ğŸ¤"
	makeIcon.ZIndex = 83
	makeIcon.Parent = makeCard

	local makeTitle = Instance.new("TextLabel")
	makeTitle.Size = UDim2.new(0.5, 0, 0, 26)
	makeTitle.Position = UDim2.new(0, 74, 0.5, -13)
	makeTitle.BackgroundTransparency = 1
	makeTitle.Font = F.Title
	makeTitle.TextSize = 16
	makeTitle.TextColor3 = C.PurpleDark
	makeTitle.TextXAlignment = Enum.TextXAlignment.Left
	makeTitle.Text = "Make a New Friend"
	makeTitle.ZIndex = 83
	makeTitle.Parent = makeCard

	local makeBtn = Instance.new("TextButton")
	makeBtn.Size = UDim2.new(0, 80, 0, 40)
	makeBtn.AnchorPoint = Vector2.new(1, 0.5)
	makeBtn.Position = UDim2.new(1, -14, 0.5, 0)
	makeBtn.BackgroundColor3 = C.Purple
	makeBtn.Font = F.Button
	makeBtn.TextSize = 14
	makeBtn.TextColor3 = C.White
	makeBtn.Text = "Meet"
	makeBtn.AutoButtonColor = false
	makeBtn.ZIndex = 83
	makeBtn.Parent = makeCard
	UI.corner(makeBtn, 12)

	makeBtn.MouseEnter:Connect(function()
		UI.tween(makeBtn, TweenInfo.new(0.12), { BackgroundColor3 = C.PurpleDark })
	end)
	makeBtn.MouseLeave:Connect(function()
		UI.tween(makeBtn, TweenInfo.new(0.12), { BackgroundColor3 = C.Purple })
	end)
	makeBtn.MouseButton1Click:Connect(function()
		-- CRITICAL FIX: Pass explicit empty table {} to indicate "create new person"
		-- Previously nil fell back to self.currentInteractPerson
		self:doInteraction("make_friend", "friend", {})
	end)

	if #friends > 0 then
		local section = Instance.new("Frame")
		section.Name = "FriendsSection"
		section.Size = UDim2.new(1, 0, 0, 0)
		section.AutomaticSize = Enum.AutomaticSize.Y
		section.BackgroundColor3 = C.White
		section.LayoutOrder = 1
		section.ZIndex = 82
		section.Parent = self.contentScroll
		UI.corner(section, 18)
		UI.stroke(section, 1, 0.88, C.Gray200)
		UI.pad(section, 14, 14, 14, 16)

		local sectionLayout = Instance.new("UIListLayout")
		sectionLayout.Padding = UDim.new(0, 10)
		sectionLayout.SortOrder = Enum.SortOrder.LayoutOrder
		sectionLayout.Parent = section

		local header = Instance.new("Frame")
		header.Size = UDim2.new(1, 0, 0, 36)
		header.BackgroundTransparency = 1
		header.LayoutOrder = 0
		header.ZIndex = 83
		header.Parent = section

		local badge = Instance.new("Frame")
		badge.Size = UDim2.new(0, 90, 0, 32)
		badge.BackgroundColor3 = C.Purple
		badge.ZIndex = 84
		badge.Parent = header
		UI.pill(badge)

		local badgeLabel = Instance.new("TextLabel")
		badgeLabel.Size = UDim2.fromScale(1, 1)
		badgeLabel.BackgroundTransparency = 1
		badgeLabel.Font = F.Button
		badgeLabel.TextSize = 14
		badgeLabel.TextColor3 = C.White
		badgeLabel.Text = "Friends"
		badgeLabel.ZIndex = 85
		badgeLabel.Parent = badge

		for i, person in ipairs(friends) do
			self:createPersonCard(section, person, i, C.Purple, C.PurplePale, "friend")
		end
	else
		-- CRITICAL FIX: Premium empty state for no friends
		createPremiumEmptyCard(self.contentScroll, {
			emoji = "ğŸ«‚",
			title = "No Friends Yet",
			message = "You haven't made any friends yet. Tap 'Meet' above to find your first friend!",
			accentColor = C.Purple,
			layoutOrder = 1
		})
	end
end

-- ENEMIES ----------------------------------------------------------------------

function RelationshipsScreen:populateEnemies()
	self:updateInfoBar()

	local enemies = {}
	local rels = self:getRelationships()
	local flags = (self.playerState and self.playerState.Flags) or {}
	local seen = {}

	for id, rel in pairs(rels) do
		if type(rel) == "table" then
			local cat = categorizeRelationship(rel, flags)
			if cat == "enemy" then
				local key = getRelKey(id, rel)
				if key and not seen[key] then
					seen[key] = true
					-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
					-- CRITICAL FIX: Add emoji for enemies based on gender
					-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
					local enemyGender = safeLower(rel.gender or rel.Gender or "")
					local enemyEmoji = "ğŸ‘¤"
					if enemyGender == "female" or enemyGender == "f" then
						enemyEmoji = "ğŸ‘©"
					elseif enemyGender == "male" or enemyGender == "m" then
						enemyEmoji = "ğŸ‘¨"
					end
					
					table.insert(enemies, {
						id           = rel.id or id,
						name         = rel.name,
						role         = "Enemy",
						emoji        = enemyEmoji,  -- CRITICAL FIX: Add emoji!
						gender       = enemyGender,
						relationship = rel.relationship or 20,
						age          = rel.age or self:getAge(),
						alive        = isAliveFromRel(rel),
					})
				end
			end
		end
	end

	if #enemies > 0 then
		local section = Instance.new("Frame")
		section.Name = "EnemiesSection"
		section.Size = UDim2.new(1, 0, 0, 0)
		section.AutomaticSize = Enum.AutomaticSize.Y
		section.BackgroundColor3 = C.White
		section.LayoutOrder = 1
		section.ZIndex = 82
		section.Parent = self.contentScroll
		UI.corner(section, 18)
		UI.stroke(section, 1, 0.88, C.Gray200)
		UI.pad(section, 14, 14, 14, 16)

		local sectionLayout = Instance.new("UIListLayout")
		sectionLayout.Padding = UDim.new(0, 10)
		sectionLayout.SortOrder = Enum.SortOrder.LayoutOrder
		sectionLayout.Parent = section

		local header = Instance.new("Frame")
		header.Size = UDim2.new(1, 0, 0, 36)
		header.BackgroundTransparency = 1
		header.LayoutOrder = 0
		header.ZIndex = 83
		header.Parent = section

		local badge = Instance.new("Frame")
		badge.Size = UDim2.new(0, 90, 0, 32)
		badge.BackgroundColor3 = C.Red
		badge.ZIndex = 84
		badge.Parent = header
		UI.pill(badge)

		local badgeLabel = Instance.new("TextLabel")
		badgeLabel.Size = UDim2.fromScale(1, 1)
		badgeLabel.BackgroundTransparency = 1
		badgeLabel.Font = F.Button
		badgeLabel.TextSize = 14
		badgeLabel.TextColor3 = C.White
		badgeLabel.Text = "Enemies"
		badgeLabel.ZIndex = 85
		badgeLabel.Parent = badge

		for i, person in ipairs(enemies) do
			self:createPersonCard(section, person, i, C.Red, C.RedPale, "enemy")
		end
	else
		-- CRITICAL FIX: Premium empty state for no enemies (positive message)
		createPremiumEmptyCard(self.contentScroll, {
			emoji = "ğŸ˜‡",
			title = "No Enemies!",
			message = "Everyone likes you... for now! Keep being nice to stay on good terms.",
			accentColor = C.Green,
			layoutOrder = 1
		})
	end
end

-- PERSON CARD ------------------------------------------------------------------

function RelationshipsScreen:createPersonCard(parent, person, order, accentColor, paleColor, relType)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Validate person parameter to prevent nil errors
	-- User reported: "Unable to assign property Text. string expected, got nil"
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	if not person or type(person) ~= "table" then
		logWarn("createPersonCard called with invalid person:", type(person))
		return nil
	end
	
	-- Ensure required fields have defaults
	person.id = person.id or ("person_" .. tostring(order))
	person.name = person.name or person.Name or "Unknown"
	person.role = person.role or person.type or "Person"
	person.relationship = person.relationship or 50
	person.age = person.age or 0
	
	local isAlive = person.alive ~= false
	local accentDark = accentColor:Lerp(C.Black, 0.2)
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL REVAMP: Premium Card with Shell Structure (like LifeClient popup)
	-- Container -> Shadow -> Shell -> Inner Card
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	-- CRITICAL UI FIX: Scale card heights for small phones
	local PERSON_CARD_HEIGHT = IS_TINY_PHONE and 80 or (IS_SMALL_PHONE and 92 or 110)
	local AVATAR_SIZE = IS_TINY_PHONE and 48 or (IS_SMALL_PHONE and 56 or 68)
	local AVATAR_MARGIN = IS_TINY_PHONE and 6 or (IS_SMALL_PHONE and 8 or 10)
	local TEXT_START = AVATAR_MARGIN + AVATAR_SIZE + (IS_TINY_PHONE and 6 or 12)
	local cornerRad = IS_TINY_PHONE and 12 or 20
	
	-- Container (holds everything, manages layout)
	local container = Instance.new("Frame")
	container.Name = tostring(person.id) .. "_Container"
	container.Size = UDim2.new(1, 0, 0, PERSON_CARD_HEIGHT)
	container.BackgroundTransparency = 1
	container.LayoutOrder = order
	container.ZIndex = 82
	container.Parent = parent
	
	-- Shadow layer (premium depth effect) - SCALED
	local shadowOffset = IS_TINY_PHONE and 1 or 2
	local shadow = Instance.new("Frame")
	shadow.Name = "Shadow"
	shadow.Size = UDim2.new(1, shadowOffset * 2, 1, shadowOffset * 2)
	shadow.Position = UDim2.new(0, shadowOffset, 0, shadowOffset)
	shadow.BackgroundColor3 = C.Black
	shadow.BackgroundTransparency = isAlive and 0.92 or 0.96
	shadow.ZIndex = 82
	shadow.Parent = container
	UI.corner(shadow, cornerRad)
	
	-- Colored shell (accent border)
	local shell = Instance.new("Frame")
	shell.Name = "Shell"
	shell.Size = UDim2.new(1, 0, 1, 0)
	shell.BackgroundColor3 = isAlive and accentColor or C.Gray400
	shell.ZIndex = 83
	shell.Parent = container
	UI.corner(shell, IS_TINY_PHONE and 10 or 18)
	
	-- Inner white card - SCALED padding
	local cardPad = IS_TINY_PHONE and 2 or 3
	local card = Instance.new("Frame")
	card.Name = "Card"
	card.Size = UDim2.new(1, -cardPad * 2, 1, -cardPad * 2)
	card.Position = UDim2.new(0, cardPad, 0, cardPad)
	card.BackgroundColor3 = C.White
	card.ZIndex = 84
	card.Parent = shell
	UI.corner(card, IS_TINY_PHONE and 8 or 16)
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- PREMIUM HOVER & PRESS EFFECTS
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	-- CRITICAL UI FIX: Use scaled heights for hover/press effects
	local hoverHeight = PERSON_CARD_HEIGHT + 4
	local pressHeight = PERSON_CARD_HEIGHT - 4

	if isAlive then
		-- CRITICAL FIX: Reduced width to not cover the Chat button on the right (SCALED)
		local pressArea = Instance.new("TextButton")
		pressArea.Name = "PressArea"
		pressArea.Size = UDim2.new(1, IS_TINY_PHONE and -50 or -100, 1, 0)  -- Leave space for button
		pressArea.BackgroundTransparency = 1
		pressArea.Text = ""
		pressArea.ZIndex = 92
		pressArea.Parent = container
		
		local isHovering = false
		local isPressed = false
		
		pressArea.MouseEnter:Connect(function()
			if isPressed then return end
			isHovering = true
			-- Premium hover: lift and brighten
			UI.tween(container, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
				Size = UDim2.new(1, 0, 0, hoverHeight)
			})
			UI.tween(shell, TweenInfo.new(0.12), { BackgroundColor3 = accentDark })
			UI.tween(shadow, TweenInfo.new(0.12), {
				BackgroundTransparency = 0.85,
				Position = UDim2.new(0, shadowOffset + 1, 0, shadowOffset + 2)
			})
			UI.tween(card, TweenInfo.new(0.12), { BackgroundColor3 = paleColor:Lerp(C.White, 0.85) })
		end)
		
		pressArea.MouseLeave:Connect(function()
			isHovering = false
			isPressed = false
			-- Return to normal
			UI.tween(container, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
				Size = UDim2.new(1, 0, 0, PERSON_CARD_HEIGHT)
			})
			UI.tween(shell, TweenInfo.new(0.12), { BackgroundColor3 = accentColor })
			UI.tween(shadow, TweenInfo.new(0.12), {
				BackgroundTransparency = 0.92,
				Position = UDim2.new(0, shadowOffset, 0, shadowOffset)
			})
			UI.tween(card, TweenInfo.new(0.12), { BackgroundColor3 = C.White })
		end)
		
		pressArea.MouseButton1Down:Connect(function()
			isPressed = true
			-- Press down effect
			UI.tween(container, TweenInfo.new(0.08), {
				Size = UDim2.new(1, 0, 0, pressHeight)
			})
			UI.tween(shell, TweenInfo.new(0.08), { BackgroundColor3 = accentDark:Lerp(C.Black, 0.1) })
		end)
		
		pressArea.MouseButton1Up:Connect(function()
			isPressed = false
			if isHovering then
				UI.tween(container, TweenInfo.new(0.1), {
					Size = UDim2.new(1, 0, 0, hoverHeight)
				})
				UI.tween(shell, TweenInfo.new(0.1), { BackgroundColor3 = accentDark })
			end
		end)
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- AVATAR (with ring effect for alive, grayed for deceased) - SCALED
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	-- Avatar ring (colored border around avatar) - SCALED
	local avatarRing = Instance.new("Frame")
	avatarRing.Size = UDim2.new(0, AVATAR_SIZE, 0, AVATAR_SIZE)
	avatarRing.Position = UDim2.new(0, AVATAR_MARGIN, 0.5, -AVATAR_SIZE / 2)
	avatarRing.BackgroundColor3 = isAlive and accentColor or C.Gray400
	avatarRing.ZIndex = 85
	avatarRing.Parent = card
	UI.corner(avatarRing, IS_TINY_PHONE and 10 or 18)
	
	local avatarPad = IS_TINY_PHONE and 2 or 3
	local avatarFrame = Instance.new("Frame")
	avatarFrame.Size = UDim2.new(1, -avatarPad * 2, 1, -avatarPad * 2)
	avatarFrame.Position = UDim2.new(0, avatarPad, 0, avatarPad)
	avatarFrame.BackgroundColor3 = isAlive and paleColor or C.Gray200
	avatarFrame.ZIndex = 86
	avatarFrame.Parent = avatarRing
	UI.corner(avatarFrame, IS_TINY_PHONE and 8 or 16)
	
	-- Gradient on avatar for depth
	if isAlive then
		local avatarGrad = Instance.new("UIGradient")
		avatarGrad.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
			ColorSequenceKeypoint.new(1, paleColor:Lerp(C.White, 0.3)),
		})
		avatarGrad.Rotation = 135
		avatarGrad.Parent = avatarFrame
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Use proper emoji helper based on relationship type
	-- User bug: "PARTNER... NO EMOJI IT JUST BLANK PERSON EMOJI INSTEAD OF GUY OR GIRL"
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local emoji = person.emoji
	if not emoji or emoji == "" or emoji == "ğŸ‘¤" then
		if relType == "romance" then
			emoji = self:getPartnerEmoji(person)
		else
			emoji = self:getFamilyEmoji(person.role or "", person.gender, person.age)
		end
	end

	local avatarLabel = Instance.new("TextLabel")
	avatarLabel.Size = UDim2.fromScale(1, 1)
	avatarLabel.BackgroundTransparency = 1
	avatarLabel.Font = F.Body
	avatarLabel.TextSize = IS_TINY_PHONE and 22 or (IS_SMALL_PHONE and 28 or 34)
	avatarLabel.TextColor3 = isAlive and accentColor or C.Gray500
	avatarLabel.TextTransparency = isAlive and 0 or 0.3
	avatarLabel.Text = emoji
	avatarLabel.ZIndex = 87
	avatarLabel.Parent = avatarFrame

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- NAME & DETAILS (repositioned for new layout) - SCALED
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	-- CRITICAL UI FIX: Scaled text and position for small phones
	local NAME_SIZE = IS_TINY_PHONE and 13 or (IS_SMALL_PHONE and 15 or 17)
	local BADGE_HEIGHT = IS_TINY_PHONE and 18 or (IS_SMALL_PHONE and 22 or 26)
	local BADGE_WIDTH = IS_TINY_PHONE and 65 or (IS_SMALL_PHONE and 80 or 95)
	local nameY = IS_TINY_PHONE and 6 or (IS_SMALL_PHONE and 8 or 10)
	local roleY = IS_TINY_PHONE and 26 or (IS_SMALL_PHONE and 32 or 36)

	-- Name (bolder) - SCALED
	-- CRITICAL FIX: Nil safety for person.name - prevents "string expected, got nil" error
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(1, -TEXT_START - (IS_TINY_PHONE and 50 or 100), 0, IS_TINY_PHONE and 18 or 24)
	nameLabel.Position = UDim2.new(0, TEXT_START, 0, nameY)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Font = F.Title
	nameLabel.TextSize = NAME_SIZE
	nameLabel.TextColor3 = isAlive and C.Gray900 or C.Gray500
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.Text = person.name or person.Name or person.role or "Unknown"
	nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
	nameLabel.ZIndex = 85
	nameLabel.Parent = card

	-- Role badge (more prominent) - SCALED
	local roleBadge = Instance.new("Frame")
	roleBadge.Size = UDim2.new(0, BADGE_WIDTH, 0, BADGE_HEIGHT)
	roleBadge.Position = UDim2.new(0, TEXT_START, 0, roleY)
	roleBadge.BackgroundColor3 = isAlive and paleColor or C.Gray200
	roleBadge.ZIndex = 85
	roleBadge.Parent = card
	UI.pill(roleBadge)

	local roleLabel = Instance.new("TextLabel")
	roleLabel.Size = UDim2.fromScale(1, 1)
	roleLabel.BackgroundTransparency = 1
	roleLabel.Font = F.Button
	roleLabel.TextSize = IS_TINY_PHONE and 9 or (IS_SMALL_PHONE and 10 or 11)
	roleLabel.TextColor3 = isAlive and accentColor or C.Gray500
	-- Show divorced/separated/deceased status
	local roleText = person.role or ""
	if person.divorced or person.maritalStatus == "Divorced" or person.status == "divorced" then
		roleText = roleText .. " ğŸ’”"
	elseif not isAlive then
		roleText = roleText .. " âœï¸"
	end
	roleLabel.Text = roleText
	roleLabel.ZIndex = 86
	roleLabel.Parent = roleBadge
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: AGE DISPLAY - User wanted to see ages for all people!
	-- Shows age badge next to role badge
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local personAge = person.age or 0
	if personAge > 0 then
		local AGE_BADGE_WIDTH = IS_TINY_PHONE and 40 or (IS_SMALL_PHONE and 48 or 55)
		local ageBadge = Instance.new("Frame")
		ageBadge.Name = "AgeBadge"
		ageBadge.Size = UDim2.new(0, AGE_BADGE_WIDTH, 0, BADGE_HEIGHT)
		ageBadge.Position = UDim2.new(0, TEXT_START + BADGE_WIDTH + 6, 0, roleY)
		ageBadge.BackgroundColor3 = isAlive and C.Gray200 or C.Gray100
		ageBadge.ZIndex = 85
		ageBadge.Parent = card
		UI.pill(ageBadge)
		
		local ageLabel = Instance.new("TextLabel")
		ageLabel.Size = UDim2.fromScale(1, 1)
		ageLabel.BackgroundTransparency = 1
		ageLabel.Font = F.Button
		ageLabel.TextSize = IS_TINY_PHONE and 9 or (IS_SMALL_PHONE and 10 or 11)
		ageLabel.TextColor3 = isAlive and C.Gray600 or C.Gray400
		ageLabel.Text = "Age " .. tostring(personAge)
		ageLabel.ZIndex = 86
		ageLabel.Parent = ageBadge
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- RELATIONSHIP BAR (bigger, more prominent)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	local relPct   = math.clamp((person.relationship or 50) / 100, 0, 1)
	local relColor = (relPct >= 0.7 and C.Green) or (relPct >= 0.4 and C.Amber) or C.Red

	-- CRITICAL UI FIX: Scaled relationship bar positions
	local relLabelY = IS_TINY_PHONE and 48 or (IS_SMALL_PHONE and 56 or 68)
	local relBarY = IS_TINY_PHONE and 60 or (IS_SMALL_PHONE and 68 or 84)
	local relBarHeight = IS_TINY_PHONE and 8 or (IS_SMALL_PHONE and 10 or 12)
	local relBadgeWidth = IS_TINY_PHONE and 32 or (IS_SMALL_PHONE and 36 or 40)
	local relBadgeHeight = IS_TINY_PHONE and 16 or (IS_SMALL_PHONE and 18 or 20)
	local relTextSize = IS_TINY_PHONE and 8 or (IS_SMALL_PHONE and 9 or 10)

	-- Relationship label - SCALED
	local relTitleLabel = Instance.new("TextLabel")
	relTitleLabel.Size = UDim2.new(0.2, 0, 0, IS_TINY_PHONE and 12 or 14)
	relTitleLabel.Position = UDim2.new(0, TEXT_START, 0, relLabelY)
	relTitleLabel.BackgroundTransparency = 1
	relTitleLabel.Font = F.Body
	relTitleLabel.TextSize = relTextSize
	relTitleLabel.TextColor3 = C.Gray400
	relTitleLabel.TextXAlignment = Enum.TextXAlignment.Left
	relTitleLabel.Text = IS_TINY_PHONE and "Rel." or "Relationship"
	relTitleLabel.ZIndex = 85
	relTitleLabel.Parent = card

	-- Relationship bar - SCALED
	local relBarBg = Instance.new("Frame")
	relBarBg.Size = UDim2.new(IS_TINY_PHONE and 0.25 or 0.30, 0, 0, relBarHeight)
	relBarBg.Position = UDim2.new(0, TEXT_START, 0, relBarY)
	relBarBg.BackgroundColor3 = C.Gray200
	relBarBg.ZIndex = 85
	relBarBg.Parent = card
	UI.pill(relBarBg)

	local relBarFill = Instance.new("Frame")
	relBarFill.Size = UDim2.new(relPct, 0, 1, 0)
	relBarFill.BackgroundColor3 = relColor
	relBarFill.ZIndex = 86
	relBarFill.Parent = relBarBg
	UI.pill(relBarFill)

	-- Percentage badge (next to bar) - SCALED
	local relBadgeX = TEXT_START + (IS_TINY_PHONE and 75 or (IS_SMALL_PHONE and 95 or 115))
	local relBadge = Instance.new("Frame")
	relBadge.Size = UDim2.new(0, relBadgeWidth, 0, relBadgeHeight)
	relBadge.Position = UDim2.new(0, relBadgeX, 0, relBarY - (IS_TINY_PHONE and 1 or 2))
	relBadge.BackgroundColor3 = relColor:Lerp(C.White, 0.7)
	relBadge.ZIndex = 85
	relBadge.Parent = card
	UI.pill(relBadge)

	local relLabel = Instance.new("TextLabel")
	relLabel.Size = UDim2.fromScale(1, 1)
	relLabel.BackgroundTransparency = 1
	relLabel.Font = F.Button
	relLabel.TextSize = IS_TINY_PHONE and 9 or 11
	relLabel.TextColor3 = relColor:Lerp(C.Black, 0.3)
	relLabel.Text = string.format("%d%%", math.floor(person.relationship or 50))
	relLabel.ZIndex = 86
	relLabel.Parent = relBadge

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- INTERACT BUTTON (premium styling with shadow) - SCALED
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	-- CRITICAL UI FIX: Scaled button sizes
	local INTERACT_BTN_WIDTH = IS_TINY_PHONE and 55 or (IS_SMALL_PHONE and 65 or 85)
	local INTERACT_BTN_HEIGHT = IS_TINY_PHONE and 36 or (IS_SMALL_PHONE and 44 or 52)
	local INTERACT_BTN_MARGIN = IS_TINY_PHONE and 6 or (IS_SMALL_PHONE and 8 or 10)
	local INTERACT_BTN_FONT = IS_TINY_PHONE and 10 or (IS_SMALL_PHONE and 12 or 14)

	-- Button shadow (CRITICAL FIX: Must be SIBLING of button so emoji/text shows properly)
	local btnShadow
	if isAlive then
		btnShadow = Instance.new("Frame")
		btnShadow.Name = "InteractBtnShadow"
		btnShadow.Size = UDim2.new(0, INTERACT_BTN_WIDTH + 4, 0, INTERACT_BTN_HEIGHT + 4)
		btnShadow.AnchorPoint = Vector2.new(1, 0.5)
		btnShadow.Position = UDim2.new(1, -INTERACT_BTN_MARGIN + 2, 0.5, 2)
		btnShadow.BackgroundColor3 = accentDark
		btnShadow.BackgroundTransparency = 0.6
		btnShadow.ZIndex = 94
		btnShadow.Parent = card
		UI.corner(btnShadow, IS_TINY_PHONE and 8 or 14)
	end

	local interactBtn = Instance.new("TextButton")
	interactBtn.Name = "InteractBtn"
	interactBtn.Size = UDim2.new(0, INTERACT_BTN_WIDTH, 0, INTERACT_BTN_HEIGHT)
	interactBtn.AnchorPoint = Vector2.new(1, 0.5)
	interactBtn.Position = UDim2.new(1, -INTERACT_BTN_MARGIN, 0.5, 0)
	interactBtn.BackgroundColor3 = isAlive and accentColor or C.Gray300
	interactBtn.Font = F.Button
	interactBtn.TextSize = INTERACT_BTN_FONT
	interactBtn.TextColor3 = isAlive and C.White or C.Gray500
	interactBtn.Text = isAlive and (IS_TINY_PHONE and "ğŸ’¬" or "ğŸ’¬ Chat") or "âœï¸"
	interactBtn.AutoButtonColor = false
	interactBtn.ZIndex = 95  -- Higher than shadow and pressArea
	interactBtn.Parent = card
	UI.corner(interactBtn, 14)

	if isAlive then
		local isLoading = false
		
		interactBtn.MouseEnter:Connect(function()
			if isLoading then return end
			UI.tween(interactBtn, TweenInfo.new(0.12, Enum.EasingStyle.Quad), {
				BackgroundColor3 = accentDark,
				Size = UDim2.new(0, 90, 0, 56)
			})
			if btnShadow then
				UI.tween(btnShadow, TweenInfo.new(0.12), { Size = UDim2.new(0, 94, 0, 60) })
			end
		end)
		interactBtn.MouseLeave:Connect(function()
			if isLoading then return end
			UI.tween(interactBtn, TweenInfo.new(0.12), {
				BackgroundColor3 = accentColor,
				Size = UDim2.new(0, 85, 0, 52)
			})
			if btnShadow then
				UI.tween(btnShadow, TweenInfo.new(0.12), { Size = UDim2.new(0, 89, 0, 56) })
			end
		end)
		interactBtn.MouseButton1Click:Connect(function()
			if isLoading then return end
			isLoading = true
			
			-- Brief loading state
			interactBtn.Text = "â³..."
			UI.tween(interactBtn, TweenInfo.new(0.1), { BackgroundColor3 = C.Gray400 })
			
			task.spawn(function()
				task.wait(0.1)
				self:showInteractionModal(person, relType, accentColor, paleColor)
				
				-- Reset button
				task.wait(0.3)
				if interactBtn and interactBtn.Parent then
					isLoading = false
					interactBtn.Text = "ğŸ’¬ Chat"
					interactBtn.BackgroundColor3 = accentColor
				end
			end)
		end)
	end
end

-- INTERACTION MODAL -------------------------------------------------------------

function RelationshipsScreen:createInteractionModal()
	self.interactOverlay = Instance.new("Frame")
	self.interactOverlay.Name = "InteractOverlay"
	self.interactOverlay.Size = UDim2.fromScale(1, 1)
	self.interactOverlay.BackgroundColor3 = C.Black
	self.interactOverlay.BackgroundTransparency = 0.4
	self.interactOverlay.Visible = false
	self.interactOverlay.ZIndex = 94
	self.interactOverlay.Parent = self.screenGui

	-- Click-through close
	local closeArea = Instance.new("TextButton")
	closeArea.Size = UDim2.fromScale(1, 1)
	closeArea.BackgroundTransparency = 1
	closeArea.Text = ""
	closeArea.ZIndex = 94
	closeArea.Parent = self.interactOverlay
	closeArea.MouseButton1Click:Connect(function()
		self:hideInteractionModal()
	end)

	-- Shadow (CRITICAL FIX: IS_TINY_PHONE responsive sizing)
	local modalWidth = IS_TINY_PHONE and 0.96 or 0.92  -- Wider on tiny phones
	local modalHeight = IS_TINY_PHONE and 360 or 450
	
	local shadowFrame = Instance.new("Frame")
	shadowFrame.Name = "ShadowFrame"
	shadowFrame.Size = UDim2.new(modalWidth, 6, 0, modalHeight + 6)
	shadowFrame.AnchorPoint = Vector2.new(0.5, 0.5)
	shadowFrame.Position = UDim2.new(0.5, 3, 0.5, 3)
	shadowFrame.BackgroundColor3 = C.Black
	shadowFrame.BackgroundTransparency = 0.75
	shadowFrame.ZIndex = 94
	shadowFrame.Parent = self.interactOverlay
	UI.corner(shadowFrame, IS_TINY_PHONE and 18 or 26)
	self.interactShadow = shadowFrame

	-- Colored shell (CRITICAL FIX: IS_TINY_PHONE responsive sizing)
	local shell = Instance.new("Frame")
	shell.Name = "Shell"
	shell.Size = UDim2.new(modalWidth, 0, 0, modalHeight)
	shell.AnchorPoint = Vector2.new(0.5, 0.5)
	shell.Position = UDim2.fromScale(0.5, 0.5)
	shell.BackgroundColor3 = C.Pink
	shell.ZIndex = 95
	shell.Parent = self.interactOverlay
	UI.corner(shell, IS_TINY_PHONE and 16 or 24)
	self.interactShell = shell

	local shellStroke = UI.stroke(shell, 2, 0.3, C.PinkDark)
	self.interactShellStroke = shellStroke

	-- Inner card
	local card = Instance.new("Frame")
	card.Name = "Card"
	card.Size = UDim2.new(1, -8, 1, -8)
	card.AnchorPoint = Vector2.new(0.5, 0.5)
	card.Position = UDim2.fromScale(0.5, 0.5)
	card.BackgroundColor3 = C.White
	card.ZIndex = 96
	card.Parent = shell
	UI.corner(card, 20)
	self.interactCard = card

	-- Header
	self.interactHeader = Instance.new("Frame")
	self.interactHeader.Name = "Header"
	self.interactHeader.Size = UDim2.new(1, 0, 0, 85)
	self.interactHeader.BackgroundColor3 = C.Pink
	self.interactHeader.ZIndex = 97
	self.interactHeader.Parent = card
	UI.corner(self.interactHeader, 20)

	local headerCover = Instance.new("Frame")
	headerCover.Name = "HeaderCover"
	headerCover.Size = UDim2.new(1, 0, 0, 30)
	headerCover.Position = UDim2.new(0, 0, 1, -30)
	headerCover.BackgroundColor3 = C.Pink
	headerCover.BorderSizePixel = 0
	headerCover.ZIndex = 97
	headerCover.Parent = self.interactHeader
	self.interactHeaderCover = headerCover

	-- Emoji/avatar
	local emojiFrame = Instance.new("Frame")
	emojiFrame.Name = "EmojiFrame"
	emojiFrame.Size = UDim2.new(0, 48, 0, 48)
	emojiFrame.Position = UDim2.new(0, 16, 0, 18)
	emojiFrame.BackgroundColor3 = C.PinkPale
	emojiFrame.ZIndex = 98
	emojiFrame.Parent = self.interactHeader
	UI.corner(emojiFrame, 24)
	self.interactEmojiFrame = emojiFrame

	local emojiLabel = Instance.new("TextLabel")
	emojiLabel.Name = "Emoji"
	emojiLabel.Size = UDim2.fromScale(1, 1)
	emojiLabel.BackgroundTransparency = 1
	emojiLabel.Font = Enum.Font.GothamBold
	emojiLabel.TextSize = 26
	emojiLabel.Text = "ğŸ‘¤"
	emojiLabel.ZIndex = 99
	emojiLabel.Parent = emojiFrame
	self.interactEmoji = emojiLabel

	-- Name / status
	self.interactName = Instance.new("TextLabel")
	self.interactName.Name = "NameLabel"
	self.interactName.Size = UDim2.new(1, -130, 0, 28)
	self.interactName.Position = UDim2.new(0, 76, 0, 18)
	self.interactName.BackgroundTransparency = 1
	self.interactName.Font = F.Title
	self.interactName.TextSize = 20
	self.interactName.TextColor3 = C.White
	self.interactName.TextXAlignment = Enum.TextXAlignment.Left
	self.interactName.TextTruncate = Enum.TextTruncate.AtEnd
	self.interactName.Text = "Name"
	self.interactName.ZIndex = 99
	self.interactName.Parent = self.interactHeader

	self.interactStatus = Instance.new("TextLabel")
	self.interactStatus.Name = "StatusLabel"
	self.interactStatus.Size = UDim2.new(1, -130, 0, 22)
	self.interactStatus.Position = UDim2.new(0, 76, 0, 48)
	self.interactStatus.BackgroundTransparency = 1
	self.interactStatus.Font = F.Body
	self.interactStatus.TextSize = 13
	self.interactStatus.TextColor3 = Color3.new(1, 1, 1)
	self.interactStatus.TextTransparency = 0.15
	self.interactStatus.TextXAlignment = Enum.TextXAlignment.Left
	self.interactStatus.Text = "Status"
	self.interactStatus.ZIndex = 99
	self.interactStatus.Parent = self.interactHeader

	-- Close button
	local closeBtn = Instance.new("TextButton")
	closeBtn.Name = "CloseButton"
	closeBtn.Size = UDim2.new(0, 32, 0, 32)
	closeBtn.AnchorPoint = Vector2.new(1, 0)
	closeBtn.Position = UDim2.new(1, -12, 0, 12)
	closeBtn.BackgroundColor3 = C.White
	closeBtn.BackgroundTransparency = 0.1
	closeBtn.Font = Enum.Font.GothamBold
	closeBtn.TextSize = 16
	closeBtn.TextColor3 = C.Pink
	closeBtn.Text = "âœ•"
	closeBtn.AutoButtonColor = false
	closeBtn.ZIndex = 100
	closeBtn.Parent = self.interactHeader
	UI.corner(closeBtn, 16)
	self.interactCloseBtn = closeBtn

	closeBtn.MouseEnter:Connect(function()
		UI.tween(closeBtn, TweenInfo.new(0.12), { BackgroundTransparency = 0 })
	end)
	closeBtn.MouseLeave:Connect(function()
		UI.tween(closeBtn, TweenInfo.new(0.12), { BackgroundTransparency = 0.1 })
	end)
	closeBtn.MouseButton1Click:Connect(function()
		self:hideInteractionModal()
	end)

	-- Actions scroll
	self.actionsScroll = Instance.new("ScrollingFrame")
	self.actionsScroll.Name = "ActionsScroll"
	self.actionsScroll.Size = UDim2.new(1, -24, 1, -105)
	self.actionsScroll.Position = UDim2.new(0, 12, 0, 95)
	self.actionsScroll.BackgroundTransparency = 1
	self.actionsScroll.ScrollBarThickness = 4
	self.actionsScroll.ScrollBarImageColor3 = C.Gray400
	self.actionsScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
	self.actionsScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
	self.actionsScroll.ZIndex = 98
	self.actionsScroll.Parent = card

	local actionsLayout = Instance.new("UIListLayout")
	actionsLayout.Padding = UDim.new(0, 8)
	actionsLayout.SortOrder = Enum.SortOrder.LayoutOrder
	actionsLayout.Parent = self.actionsScroll

	local actionsPad = Instance.new("UIPadding")
	actionsPad.PaddingBottom = UDim.new(0, 16)
	actionsPad.PaddingTop    = UDim.new(0, 4)
	actionsPad.Parent = self.actionsScroll

	self.currentInteractPerson = nil
	self.currentInteractType   = nil
end

function RelationshipsScreen:showInteractionModal(person, relType, accentColor, paleColor)
	self.currentInteractPerson = person
	self.currentInteractType   = relType

	local darkColor = accentColor:Lerp(C.Black, 0.25)

	self.interactShell.BackgroundColor3 = accentColor
	self.interactShellStroke.Color      = darkColor

	self.interactHeader.BackgroundColor3 = accentColor
	if self.interactHeaderCover then
		self.interactHeaderCover.BackgroundColor3 = accentColor
	end
	self.interactEmojiFrame.BackgroundColor3 = paleColor
	self.interactCloseBtn.TextColor3        = accentColor

	self.interactName.Text   = person.name or "Unknown"
	
	-- CRITICAL FIX: Show divorced/separated status for parents
	local statusStr = person.role or "Person"
	if person.divorced or person.maritalStatus == "Divorced" then
		statusStr = statusStr .. " (Divorced)"
	elseif person.status == "separated" or person.status == "divorced" then
		statusStr = statusStr .. " (Separated)"
	elseif person.deceased or person.alive == false then
		statusStr = statusStr .. " (Deceased)"
	end
	
	self.interactStatus.Text = statusStr
		.. " | "
		.. string.format("%d%% Relationship", math.floor(person.relationship or 50))

	local emoji = "ğŸ‘¤"
	if relType == "family" then
		local role = safeLower(person.role or "")
		if role:find("mother") or role:find("mom") then
			emoji = "ğŸ‘©"
		elseif role:find("father") or role:find("dad") then
			emoji = "ğŸ‘¨"
		elseif role:find("sibling") or role:find("brother") then
			emoji = "ğŸ‘¦"
		elseif role:find("sister") then
			emoji = "ğŸ‘§"
		elseif role:find("grand") then
			emoji = "ğŸ‘µ"
		elseif role:find("child") or role:find("son") or role:find("daughter") then
			emoji = "ğŸ‘¶"
		else
			emoji = "ğŸ‘ª"
		end
	elseif relType == "romance" then
		emoji = "ğŸ’•"
	elseif relType == "friend" then
		emoji = "ğŸ¤"
	elseif relType == "enemy" then
		emoji = "ğŸ˜ "
	end
	self.interactEmoji.Text = emoji

	-- Clear old actions
	for _, child in ipairs(self.actionsScroll:GetChildren()) do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end

	local actions
	if relType == "family" then
		actions = FamilyActions
	elseif relType == "romance" then
		actions = RomanceActions
	elseif relType == "friend" then
		actions = FriendActions
	elseif relType == "enemy" then
		actions = EnemyActions
	else
		actions = {}
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Filter actions based on requirements!
	-- Some actions (like "Get Married") require specific conditions
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local flags = (self.playerState and self.playerState.Flags) or {}
	local actionIndex = 0
	
	for i, action in ipairs(actions) do
		local shouldShow = true
		
		-- Check requiresEngaged
		if action.requiresEngaged and not flags.engaged then
			shouldShow = false
		end
		
		-- Check requiresMarried
		if action.requiresMarried and not flags.married then
			shouldShow = false
		end
		
		-- Check requiresSingle
		if action.requiresSingle and (flags.married or flags.engaged or flags.has_partner) then
			shouldShow = false
		end
		
		-- Only create button if requirements are met
		if shouldShow then
			actionIndex = actionIndex + 1
			self:createActionButton(action, actionIndex, accentColor, paleColor, person)
		end
	end

	-- Animate show
	self.interactOverlay.Visible = true
	self.interactShell.Position = UDim2.new(0.5, 0, 0.5, 40)
	self.interactShadow.Position = UDim2.new(0.5, 3, 0.5, 43)
	self.interactShell.BackgroundTransparency = 0.5
	self.interactShadow.BackgroundTransparency = 1

	local tweenInfo = TweenInfo.new(0.28, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
	UI.tween(self.interactShell, tweenInfo, {
		Position = UDim2.fromScale(0.5, 0.5),
		BackgroundTransparency = 0,
	})
	UI.tween(self.interactShadow, tweenInfo, {
		Position = UDim2.new(0.5, 3, 0.5, 3),
		BackgroundTransparency = 0.75,
	})
end

function RelationshipsScreen:hideInteractionModal()
	local tweenInfo = TweenInfo.new(0.18, Enum.EasingStyle.Quad, Enum.EasingDirection.In)

	UI.tween(self.interactShell, tweenInfo, {
		Position = UDim2.new(0.5, 0, 0.5, 25),
		BackgroundTransparency = 0.5,
	})
	UI.tween(self.interactShadow, tweenInfo, {
		Position = UDim2.new(0.5, 3, 0.5, 28),
		BackgroundTransparency = 1,
	})

	task.delay(0.18, function()
		if self.interactOverlay then
			self.interactOverlay.Visible = false
		end
	end)
end

function RelationshipsScreen:createActionButton(action, order, accentColor, paleColor, person)
	local money     = self:getMoney()
	local cost      = action.cost or 0
	local canAfford = (cost == 0) or (money >= cost)

	local card = Instance.new("Frame")
	card.Name = action.id
	card.Size = UDim2.new(1, 0, 0, 62)
	card.BackgroundColor3 = C.White
	card.LayoutOrder = order
	card.ZIndex = 97
	card.Parent = self.actionsScroll
	UI.corner(card, 14)
	UI.stroke(card, 1, canAfford and 0.7 or 0.88, canAfford and accentColor or C.Gray200)

	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(0.6, -70, 0, 24)  -- CRITICAL FIX: Adjusted width
	nameLabel.Position = UDim2.new(0, 16, 0, 8)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Font = F.Title
	nameLabel.TextSize = 14  -- Slightly smaller for longer names
	nameLabel.TextColor3 = canAfford and C.Gray900 or C.Gray500
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.TextTruncate = Enum.TextTruncate.AtEnd  -- CRITICAL FIX: Prevent overflow
	nameLabel.Text = action.name or "Action"
	nameLabel.ZIndex = 98
	nameLabel.Parent = card

	local effectLabel = Instance.new("TextLabel")
	effectLabel.Size = UDim2.new(0.6, -70, 0, 20)  -- CRITICAL FIX: Adjusted width
	effectLabel.Position = UDim2.new(0, 16, 0, 34)
	effectLabel.BackgroundTransparency = 1
	effectLabel.Font = F.Body
	effectLabel.TextSize = 12
	effectLabel.TextColor3 = canAfford and C.Gray500 or C.Gray400
	effectLabel.TextXAlignment = Enum.TextXAlignment.Left
	effectLabel.Text = action.effect or ""
	effectLabel.ZIndex = 98
	effectLabel.Parent = card

	if cost > 0 then
		local costBadge = Instance.new("Frame")
		costBadge.Size = UDim2.new(0, 90, 0, 26)
		costBadge.AnchorPoint = Vector2.new(1, 0)
		costBadge.Position = UDim2.new(1, -16, 0, 10)
		costBadge.BackgroundColor3 = canAfford and C.GreenPale or C.Gray200
		costBadge.ZIndex = 98
		costBadge.Parent = card
		UI.pill(costBadge)

		local costLabel = Instance.new("TextLabel")
		costLabel.Size = UDim2.fromScale(1, 1)
		costLabel.BackgroundTransparency = 1
		costLabel.Font = F.Medium
		costLabel.TextSize = 11
		costLabel.TextColor3 = canAfford and C.GreenDark or C.Gray500
		costLabel.Text = (canAfford and "- " or "Need ") .. UI.formatMoney(cost)
		costLabel.ZIndex = 99
		costLabel.Parent = costBadge
	end

	local clickArea = Instance.new("TextButton")
	clickArea.Size = UDim2.fromScale(1, 1)
	clickArea.BackgroundTransparency = 1
	clickArea.Text = ""
	clickArea.AutoButtonColor = false
	clickArea.ZIndex = 100
	clickArea.Parent = card

	if canAfford then
		clickArea.MouseEnter:Connect(function()
			UI.tween(card, TweenInfo.new(0.12), {
				BackgroundColor3 = paleColor:Lerp(C.White, 0.4),
			})
		end)
		clickArea.MouseLeave:Connect(function()
			UI.tween(card, TweenInfo.new(0.12), {
				BackgroundColor3 = C.White,
			})
		end)

		clickArea.MouseButton1Click:Connect(function()
			local relType        = self.currentInteractType
			local explicitPerson = person or self.currentInteractPerson
			self:doInteraction(action.id, relType, explicitPerson, cost)
		end)
	else
		clickArea.Active = false
	end
end

-- RESULT MODAL ------------------------------------------------------------------

function RelationshipsScreen:createResultModal()
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL REVAMP: Premium Result Modal (matching Quit Job modal style)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	self.resultModal = {}
	
	-- Close/dim overlay
	local closeArea = Instance.new("TextButton")
	closeArea.Name = "ResultModalCloseArea"
	closeArea.Size = UDim2.fromScale(1, 1)
	closeArea.BackgroundColor3 = C.Black
	closeArea.BackgroundTransparency = 0.35
	closeArea.Text = ""
	closeArea.AutoButtonColor = false
	closeArea.ZIndex = 98
	closeArea.Visible = false
	closeArea.Parent = self.screenGui
	self.resultModal.closeArea = closeArea
	self.resultModal.overlay = closeArea
	
	-- Container (CRITICAL FIX: IS_TINY_PHONE responsive sizing)
	local modalWidth = IS_TINY_PHONE and 280 or 340
	local modalHeight = IS_TINY_PHONE and 260 or 320
	
	local container = Instance.new("Frame")
	container.Name = "ResultModalContainer"
	container.Size = UDim2.new(0, modalWidth, 0, modalHeight)
	container.AnchorPoint = Vector2.new(0.5, 0.5)
	container.Position = UDim2.fromScale(0.5, 0.5)
	container.BackgroundTransparency = 1
	container.ZIndex = 99
	container.Parent = closeArea
	self.resultModal.container = container
	
	-- Premium shadow (CRITICAL FIX: IS_TINY_PHONE responsive sizing)
	local shadowPad = IS_TINY_PHONE and 8 or 12
	local shadow = Instance.new("Frame")
	shadow.Size = UDim2.new(1, shadowPad, 1, shadowPad)
	shadow.Position = UDim2.new(0, shadowPad/2, 0, shadowPad/2)
	shadow.BackgroundColor3 = C.Black
	shadow.BackgroundTransparency = 0.7
	shadow.ZIndex = 99
	shadow.Parent = container
	UI.corner(shadow, 28)
	
	-- Colored shell
	local shell = Instance.new("Frame")
	shell.Name = "Shell"
	shell.Size = UDim2.fromScale(1, 1)
	shell.BackgroundColor3 = C.Pink
	shell.ZIndex = 100
	shell.Parent = container
	UI.corner(shell, 26)
	self.resultModal.shell = shell
	
	-- Shell stroke
	local shellStroke = Instance.new("UIStroke")
	shellStroke.Color = C.PinkDark
	shellStroke.Thickness = 2
	shellStroke.Transparency = 0.5
	shellStroke.Parent = shell
	self.resultModal.shellStroke = shellStroke
	
	-- Inner white card
	local card = Instance.new("Frame")
	card.Size = UDim2.new(1, -10, 1, -10)
	card.Position = UDim2.new(0, 5, 0, 5)
	card.BackgroundColor3 = C.White
	card.ZIndex = 101
	card.Parent = shell
	UI.corner(card, 22)
	
	-- Emoji frame (CRITICAL FIX: IS_TINY_PHONE responsive sizing)
	local emojiSize = IS_TINY_PHONE and 56 or 80
	local emojiFrame = Instance.new("Frame")
	emojiFrame.Size = UDim2.new(0, emojiSize, 0, emojiSize)
	emojiFrame.AnchorPoint = Vector2.new(0.5, 0)
	emojiFrame.Position = UDim2.new(0.5, 0, 0, IS_TINY_PHONE and 12 or 20)
	emojiFrame.BackgroundColor3 = C.PinkPale
	emojiFrame.ZIndex = 102
	emojiFrame.Parent = card
	UI.corner(emojiFrame, emojiSize/2)
	self.resultModal.emojiFrame = emojiFrame
	
	-- Emoji label
	local emojiLabel = Instance.new("TextLabel")
	emojiLabel.Size = UDim2.fromScale(1, 1)
	emojiLabel.BackgroundTransparency = 1
	emojiLabel.Font = F.Body
	emojiLabel.TextSize = IS_TINY_PHONE and 32 or 44
	emojiLabel.Text = "ğŸ’•"
	emojiLabel.ZIndex = 103
	emojiLabel.Parent = emojiFrame
	self.resultModal.emojiLabel = emojiLabel
	
	-- Title (CRITICAL FIX: IS_TINY_PHONE responsive positioning)
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Size = UDim2.new(1, -32, 0, IS_TINY_PHONE and 24 or 32)
	titleLabel.AnchorPoint = Vector2.new(0.5, 0)
	titleLabel.Position = UDim2.new(0.5, 0, 0, IS_TINY_PHONE and 72 or 108)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Font = F.Title
	titleLabel.TextSize = IS_TINY_PHONE and 17 or 22
	titleLabel.TextColor3 = C.PinkDark
	titleLabel.Text = "Interaction"
	titleLabel.ZIndex = 102
	titleLabel.Parent = card
	self.resultModal.titleLabel = titleLabel
	
	-- Message
	local messageLabel = Instance.new("TextLabel")
	messageLabel.Size = UDim2.new(1, -32, 0, 70)
	messageLabel.AnchorPoint = Vector2.new(0.5, 0)
	messageLabel.Position = UDim2.new(0.5, 0, 0, 145)
	messageLabel.BackgroundTransparency = 1
	messageLabel.Font = F.Body
	messageLabel.TextSize = 15
	messageLabel.TextColor3 = C.Gray700
	messageLabel.TextWrapped = true
	messageLabel.Text = "Something happened..."
	messageLabel.ZIndex = 102
	messageLabel.Parent = card
	self.resultModal.messageLabel = messageLabel
	
	-- Button shadow (CRITICAL FIX: Must be SIBLING of button, not child)
	local btnShadow = Instance.new("Frame")
	btnShadow.Name = "OkBtnShadow"
	btnShadow.Size = UDim2.new(0.7, 4, 0, 56)
	btnShadow.AnchorPoint = Vector2.new(0.5, 0)
	btnShadow.Position = UDim2.new(0.5, 2, 0, 232)
	btnShadow.BackgroundColor3 = C.PinkDark
	btnShadow.BackgroundTransparency = 0.5
	btnShadow.ZIndex = 102
	btnShadow.Parent = card
	UI.corner(btnShadow, 14)
	self.resultModal.okBtnShadow = btnShadow
	
	-- OK Button
	local okBtn = Instance.new("TextButton")
	okBtn.Name = "OkBtn"
	okBtn.Size = UDim2.new(0.7, 0, 0, 52)
	okBtn.AnchorPoint = Vector2.new(0.5, 0)
	okBtn.Position = UDim2.new(0.5, 0, 0, 230)
	okBtn.BackgroundColor3 = C.Pink
	okBtn.Font = F.Button
	okBtn.TextSize = 17
	okBtn.TextColor3 = C.White
	okBtn.Text = "ğŸ’• Continue"
	okBtn.AutoButtonColor = false
	okBtn.ZIndex = 103
	okBtn.Parent = card
	UI.corner(okBtn, 14)
	self.resultModal.okButton = okBtn
	
	-- Button hover (CRITICAL FIX: Also animate shadow)
	okBtn.MouseEnter:Connect(function()
		UI.tween(okBtn, TweenInfo.new(0.12, Enum.EasingStyle.Quad), {
			Size = UDim2.new(0.72, 0, 0, 56),
			BackgroundColor3 = shell.BackgroundColor3:Lerp(C.Black, 0.15)
		})
		UI.tween(btnShadow, TweenInfo.new(0.12), {
			Size = UDim2.new(0.72, 4, 0, 60)
		})
	end)
	okBtn.MouseLeave:Connect(function()
		UI.tween(okBtn, TweenInfo.new(0.12), {
			Size = UDim2.new(0.7, 0, 0, 52),
			BackgroundColor3 = shell.BackgroundColor3
		})
		UI.tween(btnShadow, TweenInfo.new(0.12), {
			Size = UDim2.new(0.7, 4, 0, 56)
		})
	end)
	
	-- Custom show/hide
	self.resultModal.show = function()
		closeArea.Visible = true
		closeArea.BackgroundTransparency = 1
		container.Position = UDim2.new(0.5, 0, 0.5, 40)
		container.Size = UDim2.new(0, 320, 0, 300)
		
		UI.tween(closeArea, TweenInfo.new(0.2), { BackgroundTransparency = 0.35 })
		UI.tween(container, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
			Position = UDim2.fromScale(0.5, 0.5),
			Size = UDim2.new(0, 340, 0, 320)
		})
	end
	
	self.resultModal.hide = function(callback)
		UI.tween(closeArea, TweenInfo.new(0.15), { BackgroundTransparency = 1 })
		UI.tween(container, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			Position = UDim2.new(0.5, 0, 0.5, 25),
			Size = UDim2.new(0, 320, 0, 300)
		})
		task.delay(0.15, function()
			closeArea.Visible = false
			if callback then callback() end
		end)
	end
	
	local function onDismiss()
		self:switchTab(self.currentTab)
	end
	
	closeArea.MouseButton1Click:Connect(function()
		self.resultModal.hide(onDismiss)
	end)
	okBtn.MouseButton1Click:Connect(function()
		self.resultModal.hide(onDismiss)
	end)
end

function RelationshipsScreen:showResultModal(title, message, accentColor)
	if not self.resultModal then
		self:createResultModal()
	end

	local isPositive = true
	if message then
		local lowerMsg = message:lower()
		if lowerMsg:find("fail") or lowerMsg:find("reject") or lowerMsg:find("refused")
			or lowerMsg:find("angry") or lowerMsg:find("upset") or lowerMsg:find("worse")
			or lowerMsg:find("error") or lowerMsg:find("broke up") or lowerMsg:find("ended") then
			isPositive = false
		end
	end

	local shellColor = accentColor or (isPositive and C.Green or C.Red)
	local shellDark  = isPositive and C.GreenDark or C.RedDark
	local paleColor  = isPositive and C.GreenPale or C.RedPale

	if accentColor then
		if accentColor == C.Pink then
			shellDark = C.PinkDark
			paleColor = C.PinkPale
		elseif accentColor == C.Purple then
			shellDark = C.PurpleDark
			paleColor = C.PurplePale
		elseif accentColor == C.Cyan then
			shellDark = C.CyanDark
			paleColor = C.CyanPale
		elseif accentColor == C.Red then
			shellDark = C.RedDark
			paleColor = C.RedPale
		end
	end

	self.resultModal.shell.BackgroundColor3      = shellColor
	self.resultModal.shellStroke.Color           = shellDark
	self.resultModal.emojiFrame.BackgroundColor3 = paleColor
	self.resultModal.okButton.BackgroundColor3   = shellColor

	local emoji = isPositive and "ğŸ’•" or "ğŸ’”"
	if title and title:find("Date")      then emoji = isPositive and "â¤ï¸" or "ğŸ’”" end
	if title and title:find("Gift")      then emoji = isPositive and "ğŸ" or "ğŸ˜”" end
	if title and title:find("Talk")      then emoji = isPositive and "ğŸ’¬" or "ğŸ˜¶" end
	if title and title:find("Hug")       then emoji = isPositive and "ğŸ¤—" or "ğŸ˜" end
	if title and title:find("Propose")   then emoji = isPositive and "ğŸ’" or "ğŸ’”" end
	if title and title:find("Kiss")      then emoji = isPositive and "ğŸ’‹" or "ğŸ˜³" end
	if title and title:find("Meet")      then emoji = isPositive and "ğŸ‘‹" or "ğŸ¤·" end
	if title and title:find("Friend")    then emoji = isPositive and "ğŸ¤" or "ğŸ˜" end
	if title and title:find("Fight")     then emoji = "ğŸ‘Š" end
	if title and title:find("Insult")    then emoji = "ğŸ˜¤" end
	if title and title:find("Apologize") then emoji = isPositive and "ğŸ™" or "ğŸ˜•" end

	self.resultModal.emojiLabel.Text       = emoji
	self.resultModal.titleLabel.Text       = title or "Interaction"
	self.resultModal.titleLabel.TextColor3 = shellDark
	self.resultModal.messageLabel.Text     = message or "Something happened..."
	self.resultModal.okButton.Text         = isPositive and "ğŸ’• Continue" or "ğŸ˜” Okay..."

	-- Use custom show method if available
	if self.resultModal.show then
		self.resultModal.show()
	elseif UI.showModal then
		UI.showModal(self.resultModal)
	end
end

function RelationshipsScreen:hideResultModal()
	if not self.resultModal or not self.resultModal.overlay.Visible then
		return
	end
	if self.resultModal.hide then
		self.resultModal.hide()
	elseif UI.hideModal then
		UI.hideModal(self.resultModal)
	end
end

-- INTERACTION CALL (wired to new backend shape) --------------------------------

function RelationshipsScreen:doInteraction(actionId, relTypeOverride, personOverride, cost)
	if not DoInteraction then
		logWarn("DoInteraction Remote not found; cannot perform interaction")
		self:showResultModal("Error", "Interaction system is not ready yet.")
		return
	end

	local relType = relTypeOverride or self.currentInteractType or "family"
	
	-- CRITICAL FIX: Handle personOverride properly
	-- - If personOverride is nil, use self.currentInteractPerson (existing behavior)
	-- - If personOverride is an empty table {}, it means "create new person, no target"
	-- - If personOverride is a real person table, use that person
	local person
	if personOverride == nil then
		person = self.currentInteractPerson
	elseif type(personOverride) == "table" and personOverride.id then
		person = personOverride
	else
		-- Empty table {} or invalid value = no specific target (for meet_someone/make_friend)
		person = nil
	end

	local payload = {
		actionId              = actionId,
		relationshipType      = relType,                     -- "family","romance","friend","enemy"
		targetId              = person and person.id or nil, -- may be nil for meet_someone / make_friend
		cost                  = cost or 0,
		targetName            = person and person.name or nil,
		targetRole            = person and person.role or nil,
		relationshipStrength  = person and person.relationship or nil,
	}

	log("Firing DoInteraction:", actionId, "Type:", relType, "Target:", payload.targetId, "Cost:", payload.cost)

	-- Close interaction modal for snappy feel
	if self.interactOverlay and self.interactOverlay.Visible then
		self:hideInteractionModal()
	end

	local ok, result = pcall(function()
		if DoInteraction:IsA("RemoteFunction") then
			return DoInteraction:InvokeServer(payload)
		else
			DoInteraction:FireServer(payload)
			return nil
		end
	end)

	if not ok then
		logWarn("DoInteraction failed:", result)
		self:showResultModal("Error", "Something went wrong while performing that action.")
		self:updateInfoBar()
		if self.isVisible then
			self:switchTab(self.currentTab)
		end
		return
	end

	-- New backend: result is usually { success, message, state?/lifeState?/newState? }
	local newState
	local message
	local successFlag

	if type(result) == "table" then
		newState    = result.state or result.newState or result.lifeState or result.updatedState
		message     = result.message or result.msg or result.error or result.description
		successFlag = result.success

		if newState then
			self:updateState(newState)
		end

		if message then
			local accent = getAccentForType(relType)
			local title  = getActionDisplayName(actionId, relType)
			self:showResultModal(title, message, accent)
		end
	end

	-- Always refresh basic stats; if SyncState is driving state, this just keeps UI responsive
	self:updateInfoBar()
	if self.isVisible then
		self:switchTab(self.currentTab)
	end
end

-- PUBLIC API -------------------------------------------------------------------

function RelationshipsScreen:show(tabId)
	if self.isVisible then return end
	self.isVisible = true

	if self.showBlur then
		pcall(self.showBlur)
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #1: Add slide-in animation matching OccupationScreen
	-- User feedback: "RelationshipsScreen just opens right up instantly"
	-- All other screens are animated nicely - this one needs to match!
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	UI.slideInScreen(self.overlay, "right")

	self:updateInfoBar()
	if tabId then
		self:switchTab(tabId)
	else
		self:switchTab(self.currentTab or "family")
	end
end

function RelationshipsScreen:hide()
	if not self.isVisible then return end
	self.isVisible = false

	if self.hideBlur then
		pcall(self.hideBlur)
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #2: Add slide-out animation matching OccupationScreen
	-- Smooth exit animation for consistency with other screens
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	UI.slideOutScreen(self.overlay, "right", function()
		if self.interactOverlay then
			self.interactOverlay.Visible = false
		end
		if self.resultModal and self.resultModal.overlay then
			self.resultModal.overlay.Visible = false
		end
	end)
end

function RelationshipsScreen:toggle()
	if self.isVisible then
		self:hide()
	else
		self:show()
	end
end

return RelationshipsScreen
