local LifeStageSystem = require(script.Parent.Parent.LifeStageSystem)

local EventEngine = {}
EventEngine.EventStats = {
	total = 0,
	byCategory = {},
	byStage = {},
}

local function clone(tbl)
	if type(tbl) ~= "table" then
		return tbl
	end
	local result = {}
	for key, value in pairs(tbl) do
		result[key] = clone(value)
	end
	return result
end

function EventEngine.normalizeEvent(event)
	if not event.id then
		error("Events require id")
	end
	event.id = string.lower(event.id)
	event.choices = event.choices or {
		{ index = 1, text = "Continue", effects = {} },
	}

	event.conditions = event.conditions or {}
	event.weight = event.weight or 1

	EventEngine.EventStats.total += 1
	EventEngine.EventStats.byCategory[event.category or "uncategorized"] =
		(EventEngine.EventStats.byCategory[event.category or "uncategorized"] or 0) + 1

	local minAge = event.conditions.minAge or event.minAge or 0
	local stage = LifeStageSystem.getStage(minAge)
	local stageId = stage and stage.id or "all"
	EventEngine.EventStats.byStage[stageId] = (EventEngine.EventStats.byStage[stageId] or 0) + 1

	return event
end

local function meetsProbability(probability)
	if not probability then
		return true
	end
	return Random.new():NextNumber() <= probability
end

function EventEngine.isEligible(event, state)
	if event.probability and not meetsProbability(event.probability) then
		return false
	end
	return LifeStageSystem.validateEvent(event, state)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX #53/#76/#94: Apply mafia effects from choices
-- Extended with full mob state management, heat decay, and operation tracking
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function applyMafiaEffect(state, mafiaEffect)
	if not mafiaEffect then return end
	
	-- CRITICAL FIX #76: Initialize MobState if needed
	if not state.MobState then
		state.MobState = {
			inMob = false,
			familyId = nil,
			familyName = nil,
			familyEmoji = nil,
			rankIndex = 1,
			rankLevel = 1,
			rankName = "Associate",
			rankEmoji = "ğŸ‘¤",
			respect = 0,
			notoriety = 0,
			heat = 0,
			loyalty = 100,
			kills = 0,
			earnings = 0,
			yearsInMob = 0,
			operationsCompleted = 0,
			operationsFailed = 0,
		}
	end
	
	local mobState = state.MobState
	state.Flags = state.Flags or {}
	
	if mafiaEffect.respect then
		mobState.respect = (mobState.respect or 0) + mafiaEffect.respect
		-- Check for automatic rank-up based on respect thresholds
		if mobState.respect >= 500 and mobState.rankIndex < 5 then
			mobState.rankIndex = math.min((mobState.rankIndex or 1) + 1, 5)
			mobState.rankLevel = mobState.rankIndex
		end
	end
	if mafiaEffect.heat then
		mobState.heat = math.clamp((mobState.heat or 0) + mafiaEffect.heat, 0, 100)
	end
	-- CRITICAL FIX #94: Heat decay support
	if mafiaEffect.heatDecay then
		mobState.heat = math.max(0, (mobState.heat or 0) - mafiaEffect.heatDecay)
	end
	if mafiaEffect.loyalty then
		mobState.loyalty = math.clamp((mobState.loyalty or 100) + mafiaEffect.loyalty, 0, 100)
	end
	if mafiaEffect.money then
		state.Money = (state.Money or 0) + mafiaEffect.money
		mobState.earnings = (mobState.earnings or 0) + mafiaEffect.money
	end
	if mafiaEffect.kills then
		mobState.kills = (mobState.kills or 0) + mafiaEffect.kills
		mobState.notoriety = (mobState.notoriety or 0) + (mafiaEffect.kills * 10)
	end
	if mafiaEffect.joinFamily then
		mobState.inMob = true
		mobState.yearsInMob = 0
		state.Flags.in_mob = true
		state.Flags.mafia_member = true
		-- Set family info if provided
		if type(mafiaEffect.joinFamily) == "table" then
			mobState.familyId = mafiaEffect.joinFamily.id
			mobState.familyName = mafiaEffect.joinFamily.name
			mobState.familyEmoji = mafiaEffect.joinFamily.emoji
		end
	end
	if mafiaEffect.kicked then
		mobState.inMob = false
		state.Flags.in_mob = nil
		state.Flags.kicked_from_mob = true
	end
	if mafiaEffect.initiated then
		state.Flags.initiated = true
		mobState.rankName = "Soldier"
		mobState.rankEmoji = "ğŸ”«"
	end
	if mafiaEffect.madeMember then
		state.Flags.made_member = true
		mobState.rankName = "Made Man"
		mobState.rankEmoji = "ğŸ’€"
		mobState.rankIndex = math.max(mobState.rankIndex or 1, 2)
	end
	if mafiaEffect.rankUp then
		mobState.rankIndex = math.min((mobState.rankIndex or 1) + 1, 5)
		mobState.rankLevel = mobState.rankIndex
		-- Update rank names based on index
		local rankNames = {"Associate", "Soldier", "Capo", "Underboss", "Boss"}
		local rankEmojis = {"ğŸ‘¤", "ğŸ”«", "ğŸ’€", "ğŸ©", "ğŸ‘‘"}
		mobState.rankName = rankNames[mobState.rankIndex] or "Associate"
		mobState.rankEmoji = rankEmojis[mobState.rankIndex] or "ğŸ‘¤"
		state.Flags.got_promoted_mob = true
	end
	if mafiaEffect.becomeBoss then
		mobState.rankIndex = 5
		mobState.rankLevel = 5
		mobState.rankName = "Boss"
		mobState.rankEmoji = "ğŸ‘‘"
		state.Flags.mob_boss = true
	end
	if mafiaEffect.arrested then
		state.InJail = true
		state.JailYearsLeft = mafiaEffect.jailYears or 5
		state.Flags.in_prison = true
		state.Flags.arrested_for_crime = true
	end
	if mafiaEffect.escaped then
		state.InJail = false
		state.JailYearsLeft = 0
		state.Flags.in_prison = nil
		state.Flags.incarcerated = nil -- CRITICAL FIX: Also clear incarcerated flag!
		state.Flags.in_jail = nil -- CRITICAL FIX: Also clear in_jail flag!
		state.Flags.escaped_prison = true
		mobState.heat = math.min(100, (mobState.heat or 0) + 30) -- Escaping adds heat
	end
	if mafiaEffect.operationSuccess then
		mobState.operationsCompleted = (mobState.operationsCompleted or 0) + 1
	end
	if mafiaEffect.operationFailed then
		mobState.operationsFailed = (mobState.operationsFailed or 0) + 1
	end
	if mafiaEffect.territoryGain then
		mobState.territories = mobState.territories or {}
		table.insert(mobState.territories, mafiaEffect.territoryGain)
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX #54/#71/#75: Apply royalty effects from choices
-- Extended to handle all royal state changes including succession and duties
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function applyRoyaltyEffect(state, royaltyEffect)
	if not royaltyEffect then return end
	
	-- CRITICAL FIX #75: Initialize RoyalState if needed
	if not state.RoyalState then
		state.RoyalState = {
			isRoyal = false,
			isMonarch = false,
			popularity = 50,
			scandals = 0,
			dutiesCompleted = 0,
			dutyStreak = 0,
			reignYears = 0,
			wealth = 0,
			lineOfSuccession = 99,
		}
	end
	
	local royalState = state.RoyalState
	
	if royaltyEffect.popularity then
		royalState.popularity = math.clamp((royalState.popularity or 50) + royaltyEffect.popularity, 0, 100)
	end
	if royaltyEffect.scandals then
		royalState.scandals = (royalState.scandals or 0) + royaltyEffect.scandals
	end
	if royaltyEffect.wealth then
		royalState.wealth = (royalState.wealth or 0) + royaltyEffect.wealth
		state.Money = (state.Money or 0) + royaltyEffect.wealth
	end
	
	-- CRITICAL FIX #71: Handle succession line changes
	if royaltyEffect.successionChange then
		royalState.lineOfSuccession = math.max(1, (royalState.lineOfSuccession or 99) + royaltyEffect.successionChange)
	end
	
	-- CRITICAL FIX #92: Handle becoming monarch
	if royaltyEffect.becomeMonarch then
		royalState.isMonarch = true
		royalState.lineOfSuccession = 0
		royalState.reignYears = 0
		state.Flags = state.Flags or {}
		state.Flags.is_monarch = true
		state.Flags.became_monarch = true
	end
	
	-- CRITICAL FIX #99: Handle coronation
	if royaltyEffect.coronation then
		royalState.coronationYear = state.Year
		state.Flags = state.Flags or {}
		state.Flags.coronated = true
	end
	
	-- Handle duty completion tracking
	if royaltyEffect.dutyCompleted then
		royalState.dutiesCompleted = (royalState.dutiesCompleted or 0) + 1
		royalState.dutyStreak = (royalState.dutyStreak or 0) + 1
	end
	
	-- Handle abdication
	if royaltyEffect.abdicate then
		royalState.isMonarch = false
		royalState.lineOfSuccession = 99
		state.Flags = state.Flags or {}
		state.Flags.abdicated = true
		state.Flags.is_monarch = nil
	end
	
	-- Handle exile
	if royaltyEffect.exile then
		royalState.isRoyal = false
		royalState.isMonarch = false
		state.Flags = state.Flags or {}
		state.Flags.exiled = true
		state.Flags.is_royalty = nil
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX #57/#77/#93/#100: Apply fame effects from choices
-- Extended to handle career progression, scandals, awards, and breakthrough moments
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function applyFameEffect(state, fameEffect)
	if not fameEffect then return end
	
	-- CRITICAL FIX #77: Initialize FameState if needed
	if not state.FameState then
		state.FameState = {
			isFamous = false,
			careerPath = nil,
			careerName = nil,
			currentStage = 1, -- CRITICAL FIX: Lua is 1-indexed
			stageName = nil,
			yearsInCareer = 0,
			followers = 0,
			endorsements = {},
			awards = {},
			scandals = 0,
			fameLevel = "Unknown",
		}
	end
	
	local fameState = state.FameState
	
	-- fameEffect can be a number or a table
	local fameChange = type(fameEffect) == "number" and fameEffect or (fameEffect.fame or 0)
	state.Fame = math.clamp((state.Fame or 0) + fameChange, 0, 100)
	
	if type(fameEffect) == "table" then
		if fameEffect.followers then
			fameState.followers = (fameState.followers or 0) + fameEffect.followers
		end
		
		-- CRITICAL FIX #93: Handle fame decay
		if fameEffect.decay then
			state.Fame = math.max(0, (state.Fame or 0) - fameEffect.decay)
		end
		
		-- CRITICAL FIX #100: Handle career breakthrough
		if fameEffect.breakthrough then
			fameState.isFamous = true
			state.Flags = state.Flags or {}
			state.Flags.fame_breakthrough = true
			state.Flags.famous = true
		end
		
		-- Handle scandals
		if fameEffect.scandal then
			fameState.scandals = (fameState.scandals or 0) + (fameEffect.scandal or 1)
			state.Fame = math.max(0, (state.Fame or 0) - 5)
		end
		
		-- Handle awards
		if fameEffect.award then
			fameState.awards = fameState.awards or {}
			table.insert(fameState.awards, {
				name = fameEffect.award,
				year = state.Year,
			})
			state.Fame = math.min(100, (state.Fame or 0) + 10)
			state.Flags = state.Flags or {}
			state.Flags.award_winner = true
		end
		
		-- Handle career stage advancement
		if fameEffect.promotion then
			fameState.currentStage = (fameState.currentStage or 1) + 1 -- CRITICAL FIX: Default to 1, not 0
			fameState.lastPromotionYear = state.Year
		end
		
		-- Handle starting a fame career
		if fameEffect.startCareer then
			fameState.isFamous = true
			fameState.careerPath = fameEffect.startCareer.path
			fameState.careerName = fameEffect.startCareer.name
			fameState.currentStage = 1
			fameState.yearsInCareer = 0
			state.Flags = state.Flags or {}
			state.Flags.fame_career = true
			state.Flags["career_" .. fameEffect.startCareer.path] = true
		end
		
		-- Handle endorsements
		if fameEffect.endorsement then
			fameState.endorsements = fameState.endorsements or {}
			table.insert(fameState.endorsements, {
				brand = fameEffect.endorsement.brand or "Unknown Brand",
				value = fameEffect.endorsement.value or 10000,
				year = state.Year,
			})
			state.Money = (state.Money or 0) + (fameEffect.endorsement.value or 10000)
		end
	end
end

local function applyChoiceEffects(state, choice, isSuccess)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #52: Handle successChance - use success/fail effects appropriately
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local effectsToApply = choice.effects
	local moneyToApply = choice.money
	local feedToUse = choice.feed
	
	-- If success/fail effects exist, use those instead
	if isSuccess == true then
		effectsToApply = choice.successEffects or choice.effects
		moneyToApply = choice.successMoney or choice.money
		feedToUse = choice.successFeed or choice.feed
	elseif isSuccess == false then
		effectsToApply = choice.failEffects or {}
		moneyToApply = choice.failMoney or 0
		feedToUse = choice.failFeed or choice.failMessage or choice.feed
	end
	
	-- Apply stat effects
	if effectsToApply then
		for stat, delta in pairs(effectsToApply) do
			if stat ~= "Money" then -- Handle money separately
				-- CRITICAL FIX: Handle range-based effects like { Health = {5, 12} }
				local actualDelta = delta
				if type(delta) == "table" and delta[1] and delta[2] then
					actualDelta = math.random(delta[1], delta[2])
				end
				
				if state.ModifyStat then
					state:ModifyStat(stat, actualDelta)
				elseif state.Stats and state.Stats[stat] then
					state.Stats[stat] = math.clamp(state.Stats[stat] + actualDelta, 0, 100)
				end
			end
		end
		-- Check for Money in effects
		if effectsToApply.Money then
			-- CRITICAL FIX: Handle range-based money effects
			local moneyDelta = effectsToApply.Money
			if type(moneyDelta) == "table" and moneyDelta[1] and moneyDelta[2] then
				moneyDelta = math.random(moneyDelta[1], moneyDelta[2])
			end
			moneyToApply = (moneyToApply or 0) + moneyDelta
		end
	end

	if moneyToApply and moneyToApply ~= 0 then
		local amount = moneyToApply
		if state.AddMoney then
			state:AddMoney(amount, choice.text)
		else
			-- CRITICAL FIX: Prevent negative money when applying money changes
			state.Money = math.max(0, (state.Money or 0) + amount)
		end
	end
	
	-- CRITICAL FIX: Handle 'cost' field from ActivityEvents and MedicalActivityEvents
	-- This was completely missing, meaning costs were never actually deducted!
	if choice.cost and choice.cost > 0 then
		if state.AddMoney then
			state:AddMoney(-choice.cost, choice.text .. " (cost)")
		else
			-- CRITICAL FIX: Prevent negative money
			state.Money = math.max(0, (state.Money or 0) - choice.cost)
		end
	end

	if choice.flags then
		if choice.flags.set then
			for _, flag in ipairs(choice.flags.set) do
				if state.SetFlag then
					state:SetFlag(flag, true)
				else
					state.Flags[flag] = true
				end
			end
		end
		if choice.flags.clear then
			for _, flag in ipairs(choice.flags.clear) do
				if state.ClearFlag then
					state:ClearFlag(flag)
				else
					state.Flags[flag] = nil
				end
			end
		end
	end
	
	-- CRITICAL FIX: Handle setFlags shorthand (many events use this)
	if choice.setFlags then
		state.Flags = state.Flags or {}
		for flag, value in pairs(choice.setFlags) do
			state.Flags[flag] = value
		end
	end
	
	-- CRITICAL FIX #53: Apply mafia effects
	local mafiaEffectToApply = choice.mafiaEffect
	if isSuccess == true and choice.successMafiaEffect then
		mafiaEffectToApply = choice.successMafiaEffect
	elseif isSuccess == false and choice.failMafiaEffect then
		mafiaEffectToApply = choice.failMafiaEffect
	end
	if mafiaEffectToApply then
		applyMafiaEffect(state, mafiaEffectToApply)
	end
	
	-- CRITICAL FIX #54: Apply royalty effects
	if choice.royaltyEffect then
		applyRoyaltyEffect(state, choice.royaltyEffect)
	end
	
	-- CRITICAL FIX #57: Apply fame effects
	local fameEffectToApply = choice.fameEffect
	if isSuccess == true and choice.successFame then
		fameEffectToApply = choice.successFame
	elseif isSuccess == false and choice.failFame then
		fameEffectToApply = choice.failFame
	end
	if fameEffectToApply then
		applyFameEffect(state, fameEffectToApply)
	end
	
	-- Handle fameGain shorthand (common in celebrity events)
	if choice.fameGain then
		state.Fame = math.clamp((state.Fame or 0) + choice.fameGain, 0, 100)
	end
	if isSuccess == false and choice.failFameLoss then
		state.Fame = math.clamp((state.Fame or 0) - choice.failFameLoss, 0, 100)
	end
	
	-- Handle salaryBonus (common in career events)
	if choice.salaryBonus then
		state.Money = (state.Money or 0) + choice.salaryBonus
	end
	
	-- BUG FIX #11: Handle followersGain (celebrity/influencer events)
	if choice.followersGain then
		state.FameState = state.FameState or {}
		state.FameState.followers = (state.FameState.followers or 0) + choice.followersGain
		state.FameState.socialFollowers = (state.FameState.socialFollowers or 0) + choice.followersGain
	end
	
	-- BUG FIX #11: Handle subscribersGain (streamer events)
	if choice.subscribersGain then
		state.FameState = state.FameState or {}
		state.FameState.subscribers = (state.FameState.subscribers or 0) + choice.subscribersGain
	end
	
	-- BUG FIX #11: Handle subscribersLoss (platform ban, etc.)
	if choice.subscribersLoss then
		state.FameState = state.FameState or {}
		local currentSubs = state.FameState.subscribers or 0
		local lossAmount = math.floor(currentSubs * (choice.subscribersLoss / 100))
		state.FameState.subscribers = math.max(0, currentSubs - lossAmount)
	end
	
	-- Handle healthLoss/healthGain
	if choice.healthLoss then
		if state.ModifyStat then
			state:ModifyStat("Health", -choice.healthLoss)
		elseif state.Stats then
			state.Stats.Health = math.clamp((state.Stats.Health or 50) - choice.healthLoss, 0, 100)
		end
	end
	if choice.healthGain then
		if state.ModifyStat then
			state:ModifyStat("Health", choice.healthGain)
		elseif state.Stats then
			state.Stats.Health = math.clamp((state.Stats.Health or 50) + choice.healthGain, 0, 100)
		end
	end
	
	-- Set feed message
	if feedToUse and state.AddFeed then
		state:AddFeed(feedToUse)
	elseif feedToUse then
		state.PendingFeed = feedToUse
	end
	
	return isSuccess
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AAA FIX: Check if a choice is eligible (affordable, meets requirements)
-- Returns: eligible (bool), reason (string or nil)
-- CRITICAL FIX: Added handling for 'cost' field used by ActivityEvents and MedicalActivityEvents
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function EventEngine.isChoiceEligible(choice, state)
	if not choice then return false, "Invalid choice" end
	if not state then return false, "Invalid state" end
	
	local money = state.Money or 0
	local flags = state.Flags or {}
	
	-- Check affordability
	if choice.minMoney and money < choice.minMoney then
		return false, string.format("Can't afford $%d %s", choice.minMoney, choice.moneyReason or "")
	end
	
	-- CRITICAL FIX: Check 'cost' field (used by ActivityEvents and MedicalActivityEvents)
	-- This was missing and allowed players to select choices they couldn't afford!
	if choice.cost and choice.cost > 0 and money < choice.cost then
		return false, string.format("Can't afford $%d", choice.cost)
	end
	
	-- Check cost in effects
	if choice.money and choice.money < 0 and money < math.abs(choice.money) then
		return false, string.format("Can't afford $%d", math.abs(choice.money))
	end
	
	-- Check effects.Money
	-- CRITICAL FIX: Handle range-based Money effects safely
	if choice.effects and choice.effects.Money then
		local moneyEffect = choice.effects.Money
		-- If it's a range, use the minimum value for affordability check
		if type(moneyEffect) == "table" and moneyEffect[1] and moneyEffect[2] then
			moneyEffect = math.min(moneyEffect[1], moneyEffect[2])
		end
		if type(moneyEffect) == "number" and moneyEffect < 0 then
			if money < math.abs(moneyEffect) then
				return false, string.format("Can't afford $%d", math.abs(moneyEffect))
			end
		end
	end
	
	-- Check required flags
	if choice.requiresFlags then
		for _, flag in ipairs(choice.requiresFlags) do
			if not flags[flag] then
				return false, string.format("Missing requirement: %s", flag)
			end
		end
	end
	
	-- Check blocked flags
	if choice.blockedByFlags then
		for flag, _ in pairs(choice.blockedByFlags) do
			if flags[flag] then
				return false, string.format("Blocked by: %s", flag)
			end
		end
	end
	
	-- Check asset requirements (e.g., "You don't have a car to live in")
	if choice.requiresCar then
		local hasVehicle = state.Assets and state.Assets.Vehicles and #state.Assets.Vehicles > 0
		if not hasVehicle then
			return false, "You don't have a car to live in"
		end
	end
	
	if choice.requiresHome then
		local hasHome = state.Assets and state.Assets.Properties and #state.Assets.Properties > 0
		if not hasHome then
			return false, "You don't own a home"
		end
	end
	
	-- Custom eligibility function
	-- CRITICAL FIX: Use pcall to handle errors in eligibility functions gracefully
	if choice.eligibility then
		local success, eligible, reason = pcall(choice.eligibility, state)
		if not success then
			-- Eligibility function errored - treat as ineligible
			warn("[EventEngine] Choice eligibility function error: " .. tostring(eligible))
			return false, "Choice unavailable"
		end
		if not eligible then
			return false, reason or "Custom requirement not met"
		end
	end
	
	return true, nil
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AAA FIX: Filter event choices to only show eligible ones
-- Adds _ineligibleReason to ineligible choices so UI can show why
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function EventEngine.filterEligibleChoices(event, state)
	if not event or not event.choices then return event end
	
	for i, choice in ipairs(event.choices) do
		local eligible, reason = EventEngine.isChoiceEligible(choice, state)
		choice._eligible = eligible
		choice._ineligibleReason = reason
		
		-- Log ineligible choices for debugging (but don't spam)
		if not eligible and reason then
			-- Only log once per event
			if not event._loggedIneligible then
				event._loggedIneligible = {}
			end
			if not event._loggedIneligible[i] then
				-- Debug log only, not warn (reduces console spam)
				-- warn(string.format("[EventEngine] Choice eligibility failed: %s choice: %d reason: %s", 
				-- 	event.id, i, reason))
				event._loggedIneligible[i] = true
			end
		end
	end
	
	return event
end

-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
-- â•‘                      AAA EVENT PIPELINE                                       â•‘
-- â•‘  select â†’ validate â†’ resolve â†’ apply patch â†’ heal â†’ publish                  â•‘
-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EventEngine.Pipeline = {}

-- Step 1: Build context for event eligibility
function EventEngine.Pipeline.buildContext(state)
	if not state then return {} end
	
	-- CRITICAL FIX: Check both flag AND relationship object for partner detection
	-- Some events set only the flag, others set only the relationship object
	local hasPartnerFlag = state.Flags and state.Flags.has_partner
	local hasPartnerObject = state.Relationships and state.Relationships.partner ~= nil
	-- Also check for spouse (married but using partner checks)
	local hasSpouseObject = state.Relationships and state.Relationships.spouse ~= nil
	-- Check for any romantic relationship in the table
	local hasRomanticRelation = false
	if state.Relationships then
		for key, rel in pairs(state.Relationships) do
			if type(rel) == "table" and (rel.type == "romantic" or rel.type == "partner" or rel.type == "spouse" or rel.type == "fiance") then
				hasRomanticRelation = true
				break
			end
		end
	end
	
	return {
		age = state.Age or 0,
		money = state.Money or 0,
		health = state.Stats and state.Stats.Health or 50,
		happiness = state.Stats and state.Stats.Happiness or 50,
		smarts = state.Stats and state.Stats.Smarts or 50,
		looks = state.Stats and state.Stats.Looks or 50,
		hasJob = state.CurrentJob ~= nil,
		jobCategory = state.CurrentJob and state.CurrentJob.category,
		isRoyalty = state.Flags and (state.Flags.is_royalty or state.Flags.royal_birth),
		inMob = state.Flags and state.Flags.in_mob,
		isFamous = state.Flags and (state.Flags.fame_career or state.Flags.is_famous),
		inJail = state.InJail,
		-- CRITICAL FIX: Comprehensive partner check
		hasPartner = hasPartnerFlag or hasPartnerObject or hasSpouseObject or hasRomanticRelation,
		isMarried = state.Flags and state.Flags.married,
		flags = state.Flags or {},
	}
end

-- Step 2: Create a patch from choice effects (NO direct state mutations)
function EventEngine.Pipeline.createPatch(choice, isSuccess)
	local patch = {
		stats = {},
		money = 0,
		flags = {},
		relationships = {},
		feed = nil,
		_source = "event",
	}
	
	local effects = choice.effects or {}
	
	-- Use success/fail effects if applicable
	if isSuccess == true and choice.successEffects then
		effects = choice.successEffects
		patch.feed = choice.successFeed or choice.feedText
	elseif isSuccess == false and choice.failEffects then
		effects = choice.failEffects
		patch.feed = choice.failFeed or choice.feedText
	else
		patch.feed = choice.feedText
	end
	
	-- Extract stat changes
	-- CRITICAL FIX: Handle range-based effects like { Health = {5, 12} }
	local function resolveValue(val)
		if type(val) == "table" and val[1] and val[2] then
			return math.random(val[1], val[2])
		end
		return val
	end
	
	if effects.Health then patch.stats.Health = resolveValue(effects.Health) end
	if effects.Happiness then patch.stats.Happiness = resolveValue(effects.Happiness) end
	if effects.Smarts then patch.stats.Smarts = resolveValue(effects.Smarts) end
	if effects.Looks then patch.stats.Looks = resolveValue(effects.Looks) end
	
	-- Extract money
	if effects.Money then patch.money = resolveValue(effects.Money) end
	if effects.money then patch.money = resolveValue(effects.money) end
	
	-- CRITICAL FIX: Handle 'cost' field from ActivityEvents and MedicalActivityEvents
	if choice.cost and choice.cost > 0 then
		patch.money = (patch.money or 0) - choice.cost
	end
	
	-- Extract flags
	if effects.flags then
		for k, v in pairs(effects.flags) do
			patch.flags[k] = v
		end
	end
	if effects.setFlag then
		patch.flags[effects.setFlag] = true
	end
	if effects.clearFlag then
		patch.flags[effects.clearFlag] = nil
	end
	
	return patch
end

-- Step 3: Apply patch to state (single mutation point)
function EventEngine.Pipeline.applyPatch(state, patch)
	if not state or not patch then return false end
	
	-- Apply stats
	for statName, delta in pairs(patch.stats or {}) do
		state.Stats = state.Stats or {}
		local current = state.Stats[statName] or 50
		if type(delta) == "number" then
			state.Stats[statName] = math.max(0, math.min(100, current + delta))
		end
	end
	
	-- Sync stat shortcuts
	if state.Stats then
		state.Health = state.Stats.Health
		state.Happiness = state.Stats.Happiness
		state.Smarts = state.Stats.Smarts
		state.Looks = state.Stats.Looks
	end
	
	-- Apply money - CRITICAL FIX: Prevent negative money
	if patch.money and patch.money ~= 0 then
		state.Money = math.max(0, (state.Money or 0) + patch.money)
	end
	
	-- Apply flags
	state.Flags = state.Flags or {}
	for flagName, value in pairs(patch.flags or {}) do
		if value == nil then
			state.Flags[flagName] = nil
		else
			state.Flags[flagName] = value
		end
	end
	
	-- Apply relationship changes
	if state.Relationships then
		for relId, changes in pairs(patch.relationships or {}) do
			local rel = state.Relationships[relId]
			if rel and changes.delta then
				rel.relationship = math.max(0, math.min(100, (rel.relationship or 50) + changes.delta))
			end
		end
	end
	
	return true
end

-- Step 4: Record event occurrence
function EventEngine.Pipeline.recordOccurrence(state, eventId)
	if not state or not eventId then return end
	
	state.EventHistory = state.EventHistory or { occurrences = {} }
	state.EventHistory.occurrences = state.EventHistory.occurrences or {}
	state.EventHistory.occurrences[eventId] = (state.EventHistory.occurrences[eventId] or 0) + 1
	state.EventHistory.lastEventId = eventId
	state.EventHistory.lastEventAge = state.Age
end

-- Full pipeline execution
function EventEngine.Pipeline.execute(event, choiceIndex, state)
	-- Step 1: Validate
	local choice = event.choices[choiceIndex]
	if not choice then
		return { success = false, error = "Invalid choice" }
	end
	
	-- Step 2: Check eligibility
	local eligible, reason = EventEngine.isChoiceEligible(choice, state)
	if not eligible then
		return { success = false, error = reason or "Choice not available" }
	end
	
	-- Step 3: Resolve success/failure
	local isSuccess = nil
	if choice.successChance then
		local roll = Random.new():NextNumber() * 100
		isSuccess = roll <= choice.successChance
	end
	
	-- Step 4: Create patch
	local patch = EventEngine.Pipeline.createPatch(choice, isSuccess)
	
	-- Step 5: Apply patch
	EventEngine.Pipeline.applyPatch(state, patch)
	
	-- Step 6: Call callbacks
	if choice.onResolve then
		pcall(choice.onResolve, state, choice, event, isSuccess)
	end
	if event.onComplete then
		pcall(event.onComplete, state, choice, event, { wasSuccessful = isSuccess })
	end
	
	-- Step 7: Record occurrence
	EventEngine.Pipeline.recordOccurrence(state, event.id)
	
	return {
		success = true,
		isSuccess = isSuccess,
		patch = patch,
		feedText = patch.feed,
	}
end

function EventEngine.completeEvent(event, choiceIndex, state)
	local choice = event.choices[choiceIndex]
	if not choice then
		return nil, "Invalid choice"
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- AAA FIX: Check choice eligibility before processing
	-- Prevents players from selecting choices they can't afford
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local eligible, reason = EventEngine.isChoiceEligible(choice, state)
	if not eligible then
		warn(string.format("[EventEngine] Choice eligibility failed: %s choice: %d reason: %s", 
			event.id or "unknown", choiceIndex, reason or "unknown"))
		return nil, reason or "You can't select this choice right now."
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #52: Handle successChance for choices with random outcomes
	-- Many events have choices like "Win the Oscar" with 25% success chance
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local isSuccess = nil -- nil means no success/fail mechanic
	
	if choice.successChance then
		local roll = Random.new():NextNumber() * 100
		isSuccess = roll <= choice.successChance
		
		-- Store result for UI feedback
		choice._wasSuccessful = isSuccess
		choice._rollResult = roll
	end
	
	applyChoiceEffects(state, choice, isSuccess)
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- AAA FIX: Add compatibility methods to state for event callbacks
	-- Many events call state:ModifyStat() and state:AddFeed() which may not exist
	-- This ensures all event callbacks work without crashing
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	if not state.ModifyStat then
		state.ModifyStat = function(self, statName, delta)
			self.Stats = self.Stats or {}
			local current = self.Stats[statName]
			if type(current) ~= "number" then
				current = self[statName]
			end
			if type(current) ~= "number" then
				current = 50
			end
			local newVal = math.max(0, math.min(100, current + (delta or 0)))
			self.Stats[statName] = newVal
			self[statName] = newVal
		end
	end
	
	if not state.AddFeed then
		state.AddFeed = function(self, msg)
			if not msg or msg == "" then return end
			self.PendingFeed = self.PendingFeed and (self.PendingFeed .. " " .. msg) or msg
		end
	end
	
	if not state.AddMoney then
		state.AddMoney = function(self, amount)
			self.Money = (self.Money or 0) + (amount or 0)
		end
	end
	
	if not state.SetFlag then
		state.SetFlag = function(self, flagName, value)
			self.Flags = self.Flags or {}
			if value == nil then value = true end
			self.Flags[flagName] = value
		end
	end
	
	if not state.HasFlag then
		state.HasFlag = function(self, flagName)
			return self.Flags and self.Flags[flagName] ~= nil and self.Flags[flagName] ~= false
		end
	end
	
	-- CRITICAL FIX: Call choice-level onResolve callback
	if choice.onResolve then
		local success, err = pcall(choice.onResolve, state, choice, event, isSuccess)
		if not success then
			warn("[LifeEvents] Choice handler error:", err)
		end
	end
	
	-- CRITICAL FIX: Also call event-level onComplete callback!
	-- This is needed for events like parent_divorce that update relationship statuses
	if event.onComplete then
		local outcome = {
			choiceIndex = choiceIndex,
			choice = choice,
			wasSuccessful = isSuccess,
		}
		local success, err = pcall(event.onComplete, state, choice, event, outcome)
		if not success then
			warn("[LifeEvents] Event onComplete error:", err)
		end
	end

	if state.RecordEvent then
		state:RecordEvent(event.id, { choice = choiceIndex, success = isSuccess })
	end

	return choice, isSuccess
end

local function weightedPick(events)
	local total = 0
	for _, event in ipairs(events) do
		total += event.weight or 1
	end
	local roll = Random.new():NextNumber() * total
	for _, event in ipairs(events) do
		roll -= event.weight or 1
		if roll <= 0 then
			return event
		end
	end
	return events[#events]
end

function EventEngine.selectYearEvents(events, state, options)
	options = options or {}
	local eligible = {}
	for _, event in ipairs(events) do
		if EventEngine.isEligible(event, state) then
			table.insert(eligible, event)
		end
	end

	if #eligible == 0 then
		return {}
	end

	local maxEvents = options.maxEvents or 2
	local selected = {}
	for i = 1, math.min(maxEvents, #eligible) do
		local pick = weightedPick(eligible)
		table.insert(selected, clone(pick))
	end
	return selected
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX #486-488: ENHANCED EVENT SELECTION WITH DEDUPLICATION
-- Prevents same event appearing multiple times in a year
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function EventEngine.selectYearEventsEnhanced(events, state, options)
	options = options or {}
	local eligible = {}
	local usedEventIds = {}
	local eventHistory = state.EventHistory or {}
	
	for _, event in ipairs(events) do
		if EventEngine.isEligible(event, state) then
			-- Check cooldown
			local cooldown = event.cooldown or 0
			local lastOccurrence = eventHistory[event.id]
			
			if lastOccurrence then
				local yearsSince = (state.Age or 0) - (lastOccurrence.age or 0)
				if yearsSince < cooldown then
					-- Skip - still on cooldown
					continue
				end
			end
			
			-- Check one-time events
			if event.oneTime or event.maxOccurrences == 1 then
				if eventHistory[event.id] then
					continue
				end
			end
			
			-- Check max occurrences
			if event.maxOccurrences then
				local occurrences = lastOccurrence and lastOccurrence.count or 0
				if occurrences >= event.maxOccurrences then
					continue
				end
			end
			
			table.insert(eligible, event)
		end
	end

	if #eligible == 0 then
		return {}
	end

	-- Sort by priority first
	table.sort(eligible, function(a, b)
		local priorityA = a.priority == "high" and 3 or (a.priority == "medium" and 2 or 1)
		local priorityB = b.priority == "high" and 3 or (b.priority == "medium" and 2 or 1)
		return priorityA > priorityB
	end)

	local maxEvents = options.maxEvents or 3
	local selected = {}
	
	-- Always include high priority events first
	for _, event in ipairs(eligible) do
		if event.priority == "high" and not usedEventIds[event.id] then
			table.insert(selected, clone(event))
			usedEventIds[event.id] = true
		end
		if #selected >= maxEvents then
			break
		end
	end
	
	-- Fill remaining slots with weighted random selection
	while #selected < maxEvents and #eligible > 0 do
		-- Filter out already used events
		local remaining = {}
		for _, event in ipairs(eligible) do
			if not usedEventIds[event.id] then
				table.insert(remaining, event)
			end
		end
		
		if #remaining == 0 then
			break
		end
		
		local pick = weightedPick(remaining)
		if pick and not usedEventIds[pick.id] then
			table.insert(selected, clone(pick))
			usedEventIds[pick.id] = true
		end
	end
	
	return selected
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX #489-491: EVENT HISTORY TRACKING
-- Records event occurrences for cooldown and one-time tracking
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function EventEngine.recordEventOccurrence(state, eventId)
	state.EventHistory = state.EventHistory or {}
	
	local existing = state.EventHistory[eventId]
	if existing then
		existing.count = (existing.count or 1) + 1
		existing.lastAge = state.Age
		existing.lastYear = state.Year
	else
		state.EventHistory[eventId] = {
			count = 1,
			firstAge = state.Age,
			lastAge = state.Age,
			firstYear = state.Year,
			lastYear = state.Year,
		}
	end
end

function EventEngine.getEventOccurrenceCount(state, eventId)
	if not state.EventHistory or not state.EventHistory[eventId] then
		return 0
	end
	return state.EventHistory[eventId].count or 0
end

function EventEngine.hasEventOccurred(state, eventId)
	return state.EventHistory and state.EventHistory[eventId] ~= nil
end

function EventEngine.getLastEventAge(state, eventId)
	if not state.EventHistory or not state.EventHistory[eventId] then
		return nil
	end
	return state.EventHistory[eventId].lastAge
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX #492-494: IMPROVED WEIGHTED SELECTION WITH CATEGORY BALANCING
-- Ensures diverse event categories appear
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function EventEngine.selectBalancedEvents(events, state, options)
	options = options or {}
	local eligible = {}
	local byCategory = {}
	
	for _, event in ipairs(events) do
		if EventEngine.isEligible(event, state) then
			table.insert(eligible, event)
			
			local category = event.category or "misc"
			byCategory[category] = byCategory[category] or {}
			table.insert(byCategory[category], event)
		end
	end

	if #eligible == 0 then
		return {}
	end

	local maxEvents = options.maxEvents or 3
	local selected = {}
	local usedCategories = {}
	
	-- First pass: try to get events from different categories
	for category, categoryEvents in pairs(byCategory) do
		if #selected >= maxEvents then
			break
		end
		
		if not usedCategories[category] then
			local pick = weightedPick(categoryEvents)
			if pick then
				table.insert(selected, clone(pick))
				usedCategories[category] = true
			end
		end
	end
	
	-- Second pass: fill remaining slots with any eligible event
	while #selected < maxEvents and #eligible > 0 do
		local pick = weightedPick(eligible)
		if pick then
			-- Avoid duplicates
			local isDuplicate = false
			for _, existing in ipairs(selected) do
				if existing.id == pick.id then
					isDuplicate = true
					break
				end
			end
			
			if not isDuplicate then
				table.insert(selected, clone(pick))
			else
				-- Remove from eligible to avoid infinite loop
				for i, e in ipairs(eligible) do
					if e.id == pick.id then
						table.remove(eligible, i)
						break
					end
				end
			end
		end
	end
	
	return selected
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX #495-497: DYNAMIC WEIGHT CALCULATION
-- Adjusts event weights based on player state and history
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
-- â•‘                    AAA DYNAMIC WEIGHT SYSTEM                                  â•‘
-- â•‘  Events are weighted based on player state, history, and relevance           â•‘
-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- AAA: Category priority weights - ensures balanced event distribution
EventEngine.CATEGORY_PRIORITY = {
	death = 10.0,         -- Death events are critical
	prison = 8.0,         -- Prison release/events are important
	career_special = 7.0, -- Career milestones
	royalty = 6.0,        -- Premium content
	mafia = 6.0,          -- Premium content
	fame = 6.0,           -- Premium content
	health_critical = 5.0, -- Health emergencies
	relationships = 4.0,  -- Relationship events
	family = 3.5,         -- Family events
	career = 3.0,         -- Career events
	health = 2.5,         -- Health events
	education = 2.0,      -- Education events
	random = 1.5,         -- Random life events
	misc = 1.0,           -- Misc events
}

function EventEngine.calculateDynamicWeight(event, state)
	local baseWeight = event.weight or 1
	local multiplier = 1.0
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- AAA FIX: Category priority system
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local category = event.category or "misc"
	local categoryPriority = EventEngine.CATEGORY_PRIORITY[category] or 1.0
	multiplier = multiplier * categoryPriority
	
	-- Boost events relevant to player's flags
	local flags = state.Flags or {}
	if event.boostIfFlag then
		for _, flag in ipairs(event.boostIfFlag) do
			if flags[flag] then
				multiplier = multiplier * 1.5
			end
		end
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- AAA FIX: Improved freshness system
	-- Recently seen events have lower weight, but never 0
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	if state.EventHistory and state.EventHistory[event.id] then
		local history = state.EventHistory[event.id]
		local yearsSince = (state.Age or 0) - (history.lastAge or 0)
		local occurrences = history.count or 1
		
		-- More occurrences = lower weight
		local occurrenceMultiplier = 1.0 / (1 + occurrences * 0.1)
		
		-- Recency penalty
		if yearsSince < 3 then
			multiplier = multiplier * 0.2 * occurrenceMultiplier
		elseif yearsSince < 5 then
			multiplier = multiplier * 0.5 * occurrenceMultiplier
		elseif yearsSince < 10 then
			multiplier = multiplier * 0.8 * occurrenceMultiplier
		end
	else
		-- Never seen before - slight boost
		multiplier = multiplier * 1.2
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- AAA FIX: Contextual boosts based on player state
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	-- Career events for employed players
	if (event.category == "career" or event.category == "career_special") and state.CurrentJob then
		multiplier = multiplier * 1.5
		-- Extra boost if event matches job category
		if event.jobCategory and state.CurrentJob.category == event.jobCategory then
			multiplier = multiplier * 1.5
		end
	end
	
	-- Relationship events for people with partners
	if event.category == "relationships" then
		if flags.married then
			multiplier = multiplier * 1.3
		elseif flags.has_partner or flags.dating then
			multiplier = multiplier * 1.2
		end
	end
	
	-- Health events scale with age
	if event.category == "health" or event.category == "health_critical" then
		local age = state.Age or 0
		if age > 70 then
			multiplier = multiplier * 2.0
		elseif age > 50 then
			multiplier = multiplier * 1.5
		elseif age > 30 then
			multiplier = multiplier * 1.2
		end
	end
	
	-- Family events for players with children/spouse
	if event.category == "family" then
		if flags.has_children then
			multiplier = multiplier * 1.4
		end
		if flags.married then
			multiplier = multiplier * 1.2
		end
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- AAA FIX: Premium feature GUARANTEED boosts
	-- Premium path events ALWAYS get high priority for those players
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	-- Mafia members MUST get mafia events
	if event.requiresMob or event.category == "mafia" then
		if state.MobState and state.MobState.inMob then
			multiplier = multiplier * 3.0 -- Guaranteed visibility
		else
			multiplier = multiplier * 0.1 -- Nearly invisible to non-mafia
		end
	end
	
	-- Royalty MUST get royal events
	if event.requiresRoyal or event.category == "royalty" then
		if state.RoyalState and state.RoyalState.isRoyal then
			multiplier = multiplier * 3.0 -- Guaranteed visibility
		else
			multiplier = multiplier * 0.1 -- Nearly invisible to non-royals
		end
	end
	
	-- Fame MUST get fame events
	if event.requiresFame or event.category == "fame" then
		if state.FameState and (state.FameState.isFamous or state.FameState.careerPath) then
			multiplier = multiplier * 3.0 -- Guaranteed visibility
		else
			multiplier = multiplier * 0.2 -- Low visibility for non-famous
		end
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- AAA FIX: Stat-based relevance
	-- Low health = more health events, low happiness = more mood events
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local stats = state.Stats or {}
	if event.category == "health" and (stats.Health or 50) < 30 then
		multiplier = multiplier * 2.0 -- Sick people get more health events
	end
	
	if event.category == "relationships" and (stats.Happiness or 50) < 30 then
		multiplier = multiplier * 1.5 -- Unhappy people get more relationship opportunities
	end
	
	-- Minimum weight to prevent 0 weights
	return math.max(0.01, baseWeight * multiplier)
end

function EventEngine.selectEventsWithDynamicWeights(events, state, options)
	options = options or {}
	local eligible = {}
	
	for _, event in ipairs(events) do
		if EventEngine.isEligible(event, state) then
			local eventCopy = clone(event)
			eventCopy._dynamicWeight = EventEngine.calculateDynamicWeight(event, state)
			table.insert(eligible, eventCopy)
		end
	end

	if #eligible == 0 then
		return {}
	end

	-- Use dynamic weights for selection
	local function dynamicWeightedPick(eventList)
		local total = 0
		for _, event in ipairs(eventList) do
			total = total + (event._dynamicWeight or event.weight or 1)
		end
		local roll = Random.new():NextNumber() * total
		for _, event in ipairs(eventList) do
			roll = roll - (event._dynamicWeight or event.weight or 1)
			if roll <= 0 then
				return event
			end
		end
		return eventList[#eventList]
	end

	local maxEvents = options.maxEvents or 3
	local selected = {}
	local usedEventIds = {}
	
	for i = 1, maxEvents do
		local remaining = {}
		for _, event in ipairs(eligible) do
			if not usedEventIds[event.id] then
				table.insert(remaining, event)
			end
		end
		
		if #remaining == 0 then
			break
		end
		
		local pick = dynamicWeightedPick(remaining)
		if pick and not usedEventIds[pick.id] then
			-- AAA FIX: Filter eligible choices before returning event
			EventEngine.filterEligibleChoices(pick, state)
			table.insert(selected, pick)
			usedEventIds[pick.id] = true
		end
	end
	
	return selected
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: createRelationship function for friend/relationship creation
-- This was missing and causing friend creation to fail silently!
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function EventEngine.createRelationship(state, relType, options)
	options = options or {}

	-- Initialize relationships table if needed
	state.Relationships = state.Relationships or {
		family = {},
		friends = {},
		romantic = {},
		enemies = {},
	}

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Better age generation for new relationships
	-- For romance, age should be within reasonable dating range for player's age
	-- For friends, can be any age within +/- 15 years
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local playerAge = state.Age or 25
	local newAge
	if relType == "romance" or relType == "partner" then
		-- Romance partners: typically within 10-15 years of player's age
		-- But at least 18 years old
		local minPartnerAge = math.max(18, playerAge - 15)
		local maxPartnerAge = math.min(90, playerAge + 15)
		newAge = math.random(minPartnerAge, maxPartnerAge)
	else
		-- Friends: can be wider range
		local minFriendAge = math.max(10, playerAge - 20)
		local maxFriendAge = math.min(100, playerAge + 20)
		newAge = math.random(minFriendAge, maxFriendAge)
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Determine appropriate gender for new relationship based on player
	-- BUG REPORTED: "As a girl it only lets me romance girls"
	-- The issue: gender was just options.gender (undefined), not based on player!
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local newGender = options.gender
	if not newGender and (relType == "romance" or relType == "partner") then
		-- Romance partners: opposite gender by default
		-- BUG FIX: Normalize gender to lowercase for comparison, reduce same-gender chance to 5%
		local playerGender = (state.Gender or "male"):lower()
		if playerGender == "female" then
			-- Female player: default to male partner
			newGender = "male"
			if math.random() < 0.05 then
				newGender = "female" -- Rare same-gender relationship
			end
		else
			-- Male player: default to female partner
			newGender = "female"
			if math.random() < 0.05 then
				newGender = "male" -- Rare same-gender relationship
			end
		end
	elseif not newGender then
		-- Friends/enemies: random gender
		newGender = math.random() > 0.5 and "male" or "female"
	end
	
	-- Generate a new relationship
	local relId = "rel_" .. tostring(os.time()) .. "_" .. math.random(1000, 9999)
	local relationship = {
		id = relId,
		type = relType,
		name = options.name or EventEngine.generateRandomName(state, newGender),
		age = options.age or newAge,
		relationship = options.initialRelationship or 50,
		yearsKnown = 0,
		createdAt = playerAge,
		alive = true,
		gender = newGender,
	}

	-- Add type-specific fields
	if relType == "friend" then
		relationship.role = options.role or "Friend"
		relationship.metAt = options.metAt or "randomly"
		relationship.category = "friend"
		-- CRITICAL FIX: Store both in the flat lookup AND typed arrays
		state.Relationships[relId] = relationship
		if type(state.Relationships.friends) == "table" then
			table.insert(state.Relationships.friends, relationship)
		end
	elseif relType == "romance" or relType == "partner" then
		relationship.role = options.role or "Partner"
		relationship.metAt = options.metAt or "dating"
		relationship.isMarried = options.isMarried or false
		relationship.category = "romance"
		-- CRITICAL FIX: Store in flat lookup, as partner, AND typed array
		state.Relationships[relId] = relationship
		state.Relationships.partner = relationship
		state.Flags = state.Flags or {}
		state.Flags.has_partner = true
		state.Flags.dating = true
		if type(state.Relationships.romantic) == "table" then
			table.insert(state.Relationships.romantic, relationship)
		end
	elseif relType == "enemy" then
		relationship.role = options.role or "Enemy"
		relationship.reason = options.reason or "unknown"
		relationship.category = "enemy"
		state.Relationships[relId] = relationship
		if type(state.Relationships.enemies) == "table" then
			table.insert(state.Relationships.enemies, relationship)
		end
	end

	-- CRITICAL FIX: Return just the relationship, not (true, relationship)
	-- LifeBackend expects just a relationship object or nil
	return relationship
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- Helper: Generate random name for new relationships
-- CRITICAL FIX: Now accepts gender parameter to generate appropriate names!
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function EventEngine.generateRandomName(state, gender)
	local maleFirstNames = {
		"James", "John", "Michael", "David", "Robert", "William", "Daniel", "Matthew",
		"Anthony", "Mark", "Joshua", "Andrew", "Joseph", "Christopher", "Ryan", "Tyler",
		"Brandon", "Kevin", "Justin", "Jason", "Brian", "Eric", "Steven", "Thomas",
		"Oliver", "Liam", "Noah", "Lucas", "Mason", "Ethan", "Aiden", "Sebastian",
	}
	local femaleFirstNames = {
		"Emma", "Olivia", "Sophia", "Isabella", "Mia", "Charlotte", "Amelia", "Harper",
		"Evelyn", "Abigail", "Emily", "Elizabeth", "Sofia", "Ella", "Avery", "Scarlett",
		"Grace", "Chloe", "Victoria", "Madison", "Luna", "Penelope", "Layla", "Riley",
		"Sarah", "Jessica", "Ashley", "Rachel", "Nicole", "Samantha", "Hannah", "Lauren",
	}
	local lastNames = {
		"Smith", "Johnson", "Williams", "Brown", "Jones", "Garcia", "Miller", "Davis",
		"Rodriguez", "Martinez", "Hernandez", "Lopez", "Gonzalez", "Wilson", "Anderson",
		"Thomas", "Taylor", "Moore", "Jackson", "Martin", "Lee", "Perez", "Thompson",
		"White", "Harris", "Clark", "Lewis", "Robinson", "Walker", "Hall", "Young",
	}

	local firstName
	if gender == "male" then
		firstName = maleFirstNames[math.random(#maleFirstNames)]
	elseif gender == "female" then
		firstName = femaleFirstNames[math.random(#femaleFirstNames)]
	else
		-- Random if no gender specified
		local allNames = {}
		for _, n in ipairs(maleFirstNames) do table.insert(allNames, n) end
		for _, n in ipairs(femaleFirstNames) do table.insert(allNames, n) end
		firstName = allNames[math.random(#allNames)]
	end
	
	return firstName .. " " .. lastNames[math.random(#lastNames)]
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
-- AAA PIPELINE SYSTEM
-- Core idea: "select â†’ resolve â†’ apply patch â†’ heal â†’ publish"
-- Never let events freely mutate state everywhere. That's where ghost flags come from.
-- â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- STATE PATCH SYSTEM
-- All state mutations go through patches for traceability and consistency
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EventEngine.StatePatch = {}

-- Create a new empty patch
function EventEngine.StatePatch.new()
	return {
		stats = {},      -- { Health = 5, Happiness = -10 }
		money = 0,       -- Amount to add/subtract
		flags = {        -- { set = {"flag1"}, clear = {"flag2"} }
			set = {},
			clear = {},
		},
		feed = nil,      -- Feed message to display
		relationships = {}, -- Relationship changes
		premium = {},    -- Premium state changes (mob, royal, fame)
		meta = {         -- Metadata for debugging
			eventId = nil,
			choiceIndex = nil,
			timestamp = os.time(),
			success = nil,
		},
	}
end

-- Apply a patch to state (SINGLE MUTATION POINT)
function EventEngine.StatePatch.apply(state, patch)
	if not state or not patch then return false end
	
	-- Apply stat changes
	if patch.stats then
		state.Stats = state.Stats or {}
		for stat, delta in pairs(patch.stats) do
			if type(delta) == "number" then
				if state.ModifyStat then
					state:ModifyStat(stat, delta)
				else
					local current = state.Stats[stat] or state[stat] or 50
					local newValue = math.max(0, math.min(100, current + delta))
					state.Stats[stat] = newValue
					state[stat] = newValue
				end
			end
		end
	end
	
	-- Apply money changes - CRITICAL FIX: Prevent negative money
	if patch.money and patch.money ~= 0 then
		if state.AddMoney then
			state:AddMoney(patch.money, patch.meta and patch.meta.eventId)
		else
			-- CRITICAL FIX: Prevent negative money values
			state.Money = math.max(0, (state.Money or 0) + patch.money)
		end
	end
	
	-- Apply flag changes
	if patch.flags then
		state.Flags = state.Flags or {}
		if patch.flags.set then
			for _, flag in ipairs(patch.flags.set) do
				state.Flags[flag] = true
			end
		end
		if patch.flags.clear then
			for _, flag in ipairs(patch.flags.clear) do
				state.Flags[flag] = nil
			end
		end
		-- Also support direct flag values
		if patch.flags.values then
			for flag, value in pairs(patch.flags.values) do
				if value == nil or value == false then
					state.Flags[flag] = nil
				else
					state.Flags[flag] = value
				end
			end
		end
	end
	
	-- Apply feed message
	if patch.feed then
		if state.AddFeed then
			state:AddFeed(patch.feed)
		else
			state.PendingFeed = patch.feed
		end
	end
	
	-- Apply premium state changes
	if patch.premium then
		if patch.premium.mob then
			state.MobState = state.MobState or {}
			for k, v in pairs(patch.premium.mob) do
				state.MobState[k] = v
			end
		end
		if patch.premium.royal then
			state.RoyalState = state.RoyalState or {}
			for k, v in pairs(patch.premium.royal) do
				state.RoyalState[k] = v
			end
		end
		if patch.premium.fame then
			state.FameState = state.FameState or {}
			for k, v in pairs(patch.premium.fame) do
				state.FameState[k] = v
			end
		end
	end
	
	return true
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- AAA PIPELINE EXECUTION
-- select â†’ resolve â†’ patch â†’ heal â†’ publish
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Build context for event selection (age, job, flags, stage, etc.)
function EventEngine.buildContext(state)
	if not state then return {} end
	
	-- CRITICAL FIX: Comprehensive partner detection 
	-- Must check BOTH flag AND relationship objects (some events only set one)
	local hasPartnerFlag = state.Flags and state.Flags.has_partner
	local hasPartnerObject = state.Relationships and state.Relationships.partner ~= nil
	local hasSpouseObject = state.Relationships and state.Relationships.spouse ~= nil
	local hasRomanticRelation = false
	if state.Relationships then
		for key, rel in pairs(state.Relationships) do
			if type(rel) == "table" and (rel.type == "romantic" or rel.type == "partner" or rel.type == "spouse" or rel.type == "fiance") then
				hasRomanticRelation = true
				break
			end
		end
	end
	
	local context = {
		age = state.Age or 0,
		year = state.Year or 2025,
		money = state.Money or 0,
		flags = state.Flags or {},
		
		-- Job context
		hasJob = state.CurrentJob ~= nil,
		jobId = state.CurrentJob and state.CurrentJob.id,
		jobCategory = state.CurrentJob and state.CurrentJob.category,
		
		-- Education context
		education = state.Education or "none",
		inSchool = state.EducationData and state.EducationData.Status == "enrolled",
		
		-- Relationship context
		-- CRITICAL FIX: Check both flag AND relationship objects
		hasPartner = hasPartnerFlag or hasPartnerObject or hasSpouseObject or hasRomanticRelation,
		isMarried = state.Flags and state.Flags.married,
		hasFriends = state.Relationships and (
			(state.Relationships.friends and #state.Relationships.friends > 0) or
			next(state.Relationships) ~= nil
		),
		
		-- Premium context
		isRoyal = state.RoyalState and state.RoyalState.isRoyal,
		isInMob = state.MobState and state.MobState.inMob,
		isFamous = state.FameState and state.FameState.isFamous,
		
		-- Prison context
		inPrison = state.InJail == true,
		
		-- Stats
		health = state.Stats and state.Stats.Health or 50,
		happiness = state.Stats and state.Stats.Happiness or 50,
		smarts = state.Stats and state.Stats.Smarts or 50,
		looks = state.Stats and state.Stats.Looks or 50,
	}
	
	-- Compute life stage
	local age = context.age
	if age <= 4 then
		context.stage = "toddler"
	elseif age <= 12 then
		context.stage = "child"
	elseif age <= 17 then
		context.stage = "teen"
	elseif age <= 29 then
		context.stage = "young_adult"
	elseif age <= 49 then
		context.stage = "adult"
	elseif age <= 64 then
		context.stage = "middle_age"
	else
		context.stage = "senior"
	end
	
	return context
end

-- Enhanced eligibility check with detailed failure reasons
function EventEngine.checkEligibilityDetailed(event, state, context)
	context = context or EventEngine.buildContext(state)
	local reasons = {}
	
	-- Age check
	local minAge = event.minAge or event.conditions and event.conditions.minAge or 0
	local maxAge = event.maxAge or event.conditions and event.conditions.maxAge or 999
	if context.age < minAge then
		table.insert(reasons, string.format("Too young (need %d, have %d)", minAge, context.age))
	end
	if context.age > maxAge then
		table.insert(reasons, string.format("Too old (max %d, have %d)", maxAge, context.age))
	end
	
	-- Money check
	if event.minMoney and context.money < event.minMoney then
		table.insert(reasons, string.format("Can't afford $%d", event.minMoney))
	end
	
	-- Job check
	if event.requiresJob and not context.hasJob then
		table.insert(reasons, "Requires a job")
	end
	if event.requiresNoJob and context.hasJob then
		table.insert(reasons, "Must be unemployed")
	end
	
	-- Partner check
	if event.requiresPartner and not context.hasPartner then
		table.insert(reasons, "Requires a partner")
	end
	if event.requiresSingle and context.hasPartner then
		table.insert(reasons, "Must be single")
	end
	
	-- Prison check
	if event.blockedByFlags and event.blockedByFlags.in_prison and context.inPrison then
		table.insert(reasons, "Can't do this in prison")
	end
	
	-- Flag requirements
	if event.requiresFlags then
		for _, flag in ipairs(event.requiresFlags) do
			if not context.flags[flag] then
				table.insert(reasons, string.format("Missing flag: %s", flag))
			end
		end
	end
	
	-- Blocked flags
	if event.blockedByFlags then
		for flag, _ in pairs(event.blockedByFlags) do
			if context.flags[flag] then
				table.insert(reasons, string.format("Blocked by flag: %s", flag))
			end
		end
	end
	
	-- Custom eligibility function
	-- CRITICAL FIX: Use pcall to handle errors in eligibility functions gracefully
	if event.eligibility then
		local success, eligible, reason = pcall(event.eligibility, state)
		if not success then
			-- Eligibility function errored - treat as ineligible
			warn("[EventEngine] Event eligibility function error for " .. tostring(event.id) .. ": " .. tostring(eligible))
			table.insert(reasons, "Eligibility check failed")
		elseif not eligible then
			table.insert(reasons, reason or "Custom eligibility failed")
		end
	end
	
	-- Cooldown check
	if event.cooldown and state.EventHistory then
		local history = state.EventHistory[event.id]
		if history then
			local lastAge = history.lastAge or history.age or 0
			local yearsSince = context.age - lastAge
			if yearsSince < event.cooldown then
				table.insert(reasons, string.format("On cooldown (%d more years)", event.cooldown - yearsSince))
			end
		end
	end
	
	-- One-time check
	if event.oneTime and state.EventHistory and state.EventHistory[event.id] then
		table.insert(reasons, "Already happened (one-time event)")
	end
	
	return #reasons == 0, reasons
end

-- Full AAA pipeline execution for a single event
function EventEngine.executeEventPipeline(event, choiceIndex, state, options)
	options = options or {}
	local result = {
		success = false,
		patch = nil,
		errors = {},
		warnings = {},
	}
	
	-- Step 1: Validate choice
	local choice = event.choices and event.choices[choiceIndex]
	if not choice then
		table.insert(result.errors, "Invalid choice index: " .. tostring(choiceIndex))
		return result
	end
	
	-- Step 2: Check choice eligibility (affordability, requirements)
	if choice.minMoney then
		local money = state.Money or 0
		if money < choice.minMoney then
			table.insert(result.errors, string.format("Can't afford $%d (have $%d)", choice.minMoney, money))
			-- Log this for the [EventEngine] Choice eligibility failed messages
			warn(string.format("[EventEngine] Choice eligibility failed: %s choice: %d reason: Can't afford $%d",
				event.id, choiceIndex, choice.minMoney))
			return result
		end
	end
	
	-- Step 3: Create patch
	local patch = EventEngine.StatePatch.new()
	patch.meta.eventId = event.id
	patch.meta.choiceIndex = choiceIndex
	
	-- Step 4: Resolve success/failure (if applicable)
	local isSuccess = nil
	if choice.successChance then
		local roll = Random.new():NextNumber() * 100
		isSuccess = roll <= choice.successChance
		patch.meta.success = isSuccess
	end
	
	-- Step 5: Build patch from choice effects
	local effectsToUse = choice.effects or {}
	local feedToUse = choice.feedText or choice.feed
	local moneyToUse = choice.money or 0
	
	if isSuccess == true then
		effectsToUse = choice.successEffects or effectsToUse
		feedToUse = choice.successFeed or feedToUse
		moneyToUse = choice.successMoney or moneyToUse
	elseif isSuccess == false then
		effectsToUse = choice.failEffects or {}
		feedToUse = choice.failFeed or choice.failMessage or feedToUse
		moneyToUse = choice.failMoney or 0
	end
	
	-- Apply effects to patch
	-- CRITICAL FIX: Handle range-based effects like { Health = {5, 12} }
	for stat, delta in pairs(effectsToUse) do
		local actualDelta = delta
		if type(delta) == "table" and delta[1] and delta[2] then
			actualDelta = math.random(delta[1], delta[2])
		end
		
		if stat ~= "Money" then
			patch.stats[stat] = actualDelta
		else
			patch.money = (patch.money or 0) + actualDelta
		end
	end
	patch.money = patch.money + moneyToUse
	patch.feed = feedToUse
	
	-- CRITICAL FIX: Handle 'cost' field from ActivityEvents and MedicalActivityEvents
	if choice.cost and choice.cost > 0 then
		patch.money = (patch.money or 0) - choice.cost
	end
	
	-- Apply flag changes to patch
	if choice.setFlags then
		for flag, value in pairs(choice.setFlags) do
			if value then
				table.insert(patch.flags.set, flag)
			else
				table.insert(patch.flags.clear, flag)
			end
		end
	end
	if choice.flags then
		if choice.flags.set then
			for _, flag in ipairs(choice.flags.set) do
				table.insert(patch.flags.set, flag)
			end
		end
		if choice.flags.clear then
			for _, flag in ipairs(choice.flags.clear) do
				table.insert(patch.flags.clear, flag)
			end
		end
	end
	
	-- Step 6: Apply patch to state
	EventEngine.StatePatch.apply(state, patch)
	
	-- Step 7: Call choice's onResolve if exists
	if choice.onResolve then
		local success, err = pcall(choice.onResolve, state, choice, event, isSuccess)
		if not success then
			table.insert(result.warnings, "onResolve error: " .. tostring(err))
			warn("[EventEngine] Choice onResolve error:", err)
		end
	end
	
	-- Step 8: Call event's onComplete if exists
	if event.onComplete then
		local outcome = {
			choiceIndex = choiceIndex,
			choice = choice,
			wasSuccessful = isSuccess,
			patch = patch,
		}
		local success, err = pcall(event.onComplete, state, choice, event, outcome)
		if not success then
			table.insert(result.warnings, "onComplete error: " .. tostring(err))
			warn("[EventEngine] Event onComplete error:", err)
		end
	end
	
	-- Step 9: Record event occurrence
	EventEngine.recordEventOccurrence(state, event.id)
	
	result.success = true
	result.patch = patch
	return result
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- ACTION TRACE SYSTEM
-- Stores last 10 actions for debugging "what broke"
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

EventEngine.ActionTrace = {}

function EventEngine.ActionTrace.record(state, action)
	state._actionTrace = state._actionTrace or {}
	
	table.insert(state._actionTrace, {
		type = action.type or "unknown",
		id = action.id,
		success = action.success,
		error = action.error,
		timestamp = os.time(),
		age = state.Age,
	})
	
	-- Keep only last 10
	while #state._actionTrace > 10 do
		table.remove(state._actionTrace, 1)
	end
end

function EventEngine.ActionTrace.get(state)
	return state._actionTrace or {}
end

function EventEngine.ActionTrace.getLastError(state)
	local trace = state._actionTrace or {}
	for i = #trace, 1, -1 do
		if trace[i].error then
			return trace[i]
		end
	end
	return nil
end

return EventEngine
