-- Minigames.lua
-- Interactive minigames for deep story events (polished version)

local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")

local Minigames = {}
Minigames.__index = Minigames

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: Mobile detection and responsive scaling (DYNAMIC!)
-- Now updates on screen resize/orientation changes
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local IS_MOBILE = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled

-- Dynamic screen size detection - call these functions instead of using static vars
local function getScreenSize()
	local cam = workspace.CurrentCamera
	if cam then
		return cam.ViewportSize
	end
	return Vector2.new(400, 800) -- Safe fallback
end

local function isSmallScreen()
	local size = getScreenSize()
	return size.X < 700 or size.Y < 500  -- CRITICAL FIX: Increased thresholds for more devices
end

local function isTinyPhone()
	local size = getScreenSize()
	return size.X < 450 or size.Y < 350  -- CRITICAL FIX: Increased thresholds
end

-- Mobile-responsive scaling helpers (now dynamic!)
local function px(base)
	if isTinyPhone() then return math.floor(base * 0.65) end  -- More aggressive scaling
	if isSmallScreen() then return math.floor(base * 0.8) end
	return base
end

local function textSize(base)
	if isTinyPhone() then return math.floor(base * 0.7) end
	if isSmallScreen() then return math.floor(base * 0.8) end
	return base
end

local function touchTarget(base)
	if IS_MOBILE then return math.max(44, base * 1.2) end
	return base
end

-- CRITICAL FIX: Get card height that fits on screen (max 85% of screen height)
local function getCardHeight(desiredHeight)
	local screenHeight = getScreenSize().Y
	local maxHeight = screenHeight * 0.85
	if isTinyPhone() then
		return math.min(desiredHeight * 0.65, maxHeight)
	elseif isSmallScreen() then
		return math.min(desiredHeight * 0.8, maxHeight)
	end
	return math.min(desiredHeight, maxHeight)
end

-- Premium Colors
local C = {
	Navy = Color3.fromRGB(30, 58, 138),
	NavyDark = Color3.fromRGB(23, 37, 84),
	Blue = Color3.fromRGB(37, 99, 235),
	BlueDark = Color3.fromRGB(29, 78, 216),
	BluePale = Color3.fromRGB(219, 234, 254),
	Green = Color3.fromRGB(34, 197, 94),
	GreenDark = Color3.fromRGB(22, 163, 74),
	GreenPale = Color3.fromRGB(220, 252, 231),
	Red = Color3.fromRGB(239, 68, 68),
	RedDark = Color3.fromRGB(220, 38, 38),
	RedPale = Color3.fromRGB(254, 226, 226),
	Amber = Color3.fromRGB(245, 158, 11),
	AmberDark = Color3.fromRGB(217, 119, 6),
	AmberPale = Color3.fromRGB(254, 243, 199),
	Purple = Color3.fromRGB(147, 51, 234),
	PurplePale = Color3.fromRGB(243, 232, 255),
	Gold = Color3.fromRGB(234, 179, 8),
	White = Color3.fromRGB(255, 255, 255),
	Gray100 = Color3.fromRGB(243, 244, 246),
	Gray200 = Color3.fromRGB(229, 231, 235),
	Gray300 = Color3.fromRGB(209, 213, 219),
	Gray400 = Color3.fromRGB(156, 163, 175),
	Gray500 = Color3.fromRGB(107, 114, 128),
	Gray600 = Color3.fromRGB(75, 85, 99),
	Gray700 = Color3.fromRGB(55, 65, 81),
	Gray800 = Color3.fromRGB(31, 41, 55),
	Gray900 = Color3.fromRGB(17, 24, 39),
	Black = Color3.fromRGB(0, 0, 0),
}

local F = {
	Title = Enum.Font.GothamBold,
	Body = Enum.Font.Gotham,
	Medium = Enum.Font.GothamMedium,
	Button = Enum.Font.GothamBold,
}

-- UI helpers
local function corner(p, r)
	local c = Instance.new("UICorner")
	c.CornerRadius = UDim.new(0, r)
	c.Parent = p
	return c
end

local function pill(p)
	local c = Instance.new("UICorner")
	c.CornerRadius = UDim.new(0.5, 0)
	c.Parent = p
	return c
end

local function stroke(p, t, tr, col)
	local s = Instance.new("UIStroke")
	s.Thickness = t
	s.Transparency = tr or 0
	s.Color = col or C.White
	s.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	s.Parent = p
	return s
end

local function pad(p, l, r, t, b)
	local pd = Instance.new("UIPadding")
	pd.PaddingLeft = UDim.new(0, l or 0)
	pd.PaddingRight = UDim.new(0, r or 0)
	pd.PaddingTop = UDim.new(0, t or 0)
	pd.PaddingBottom = UDim.new(0, b or 0)
	pd.Parent = p
	return pd
end

local function tween(o, info, props)
	local t = TweenService:Create(o, info, props)
	t:Play()
	return t
end

local function disconnect(conn)
	if conn and conn.Connected then
		conn:Disconnect()
	end
end

local function disconnectAll(tbl)
	if not tbl then return end
	for key, conn in pairs(tbl) do
		if typeof(conn) == "RBXScriptConnection" then
			disconnect(conn)
			tbl[key] = nil
		end
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- TYPEWRITER EFFECT - For dramatic text reveals (Purge, etc.)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function typeText(label, fullText, cps, tokenTbl)
	cps = cps or 45
	if not label then return end
	label.Text = ""

	-- tokenTbl is a tiny mutable table used to cancel old typing
	if tokenTbl then
		tokenTbl.id = (tokenTbl.id or 0) + 1
	end
	local myId = tokenTbl and tokenTbl.id or 0

	local len = utf8.len(fullText) or #fullText
	for i = 1, len do
		if tokenTbl and tokenTbl.id ~= myId then
			return -- cancelled
		end

		local sub = string.sub(fullText, 1, i)
		label.Text = sub
		task.wait(1 / cps)
	end
end

function Minigames.new(screenGui)
	local self = setmetatable({}, Minigames)
	self.screenGui = screenGui
	self.activeGame = nil
	self.callback = nil

	-- Connection tracking
	self._debateButtonConnections = {}
	self._debateTimerConnection = nil

	self._heistNumConnections = {}
	self._getawayButtonConnections = {}
	self._getawayCopChaseThread = nil

	self._qteTapConnection = nil

	self._prisonArrowConnections = {}
	self._prisonGuardThread = nil

	self._mashConnection = nil
	self._mashTimerThread = nil

	self._hackKeyConnections = {}
	self._hackTimerConnection = nil
	
	-- PURGE minigame connections
	self._purgeChoiceConnections = {}
	self._purgeBeginConnection = nil
	self._purgeContinueConnection = nil
	self._purgeAutoThread = nil
	self._purgeTypingToken = { id = 0 }

	-- COMBAT minigame connections
	self._combatConnections = {}
	self._combatPhase = nil

	-- Build UI once
	self:createDebateGame()
	self:createHeistGame()
	self:createGetawayGame()
	self:createQuickTimeGame()
	self:createPrisonEscapeGame()
	self:createMashGame()
	self:createHackingGame()
	self:createPurgeGame()
	self:createCombatGame()

	return self
end

----------------------------------------------------------------
-- DEBATE/CHALLENGE MINIGAME (Used for multiple contexts)
-- CRITICAL FIX: Title is now DYNAMIC based on context!
-- This minigame is used for: job interviews, debates, arguments, tests, etc.
----------------------------------------------------------------

function Minigames:createDebateGame()
	self.debateOverlay = Instance.new("Frame")
	self.debateOverlay.Size = UDim2.fromScale(1, 1)
	self.debateOverlay.BackgroundColor3 = C.Black
	self.debateOverlay.BackgroundTransparency = 0.3
	self.debateOverlay.Visible = false
	self.debateOverlay.ZIndex = 200
	self.debateOverlay.Parent = self.screenGui

	self.debateCard = Instance.new("Frame")
	self.debateCard.Size = UDim2.new(0.95, 0, 0.85, 0)
	self.debateCard.AnchorPoint = Vector2.new(0.5, 0.5)
	self.debateCard.Position = UDim2.fromScale(0.5, 0.5)
	self.debateCard.BackgroundColor3 = Color3.fromRGB(20, 30, 50)
	self.debateCard.ClipsDescendants = true  -- Prevent overflow on mobile
	self.debateCard.ZIndex = 201
	self.debateCard.Parent = self.debateOverlay
	corner(self.debateCard, 20)

	-- Stage background
	local stage = Instance.new("Frame")
	stage.Size = UDim2.new(1, 0, 0, 80)
	stage.BackgroundColor3 = C.Navy
	stage.ZIndex = 202
	stage.Parent = self.debateCard
	corner(stage, 20)

	local stageFix = Instance.new("Frame")
	stageFix.Size = UDim2.new(1, 0, 0, 40)
	stageFix.Position = UDim2.new(0, 0, 0, 45)
	stageFix.BackgroundColor3 = C.Navy
	stageFix.ZIndex = 202
	stageFix.Parent = stage

	-- CRITICAL FIX: Store reference to title so we can update it dynamically!
	self.debateStageTitle = Instance.new("TextLabel")
	self.debateStageTitle.Size = UDim2.new(1, 0, 1, 0)
	self.debateStageTitle.BackgroundTransparency = 1
	self.debateStageTitle.Font = F.Title
	self.debateStageTitle.TextSize = isTinyPhone() and 18 or (isSmallScreen() and 20 or 24)
	self.debateStageTitle.TextColor3 = C.White
	self.debateStageTitle.Text = "ğŸ¤ CHALLENGE"  -- Default - will be overridden
	self.debateStageTitle.ZIndex = 203
	self.debateStageTitle.Parent = stage

	-- Score display
	self.debateScoreFrame = Instance.new("Frame")
	self.debateScoreFrame.Size = UDim2.new(0.9, 0, 0, 50)
	self.debateScoreFrame.AnchorPoint = Vector2.new(0.5, 0)
	self.debateScoreFrame.Position = UDim2.new(0.5, 0, 0, 90)
	self.debateScoreFrame.BackgroundTransparency = 1
	self.debateScoreFrame.ZIndex = 202
	self.debateScoreFrame.Parent = self.debateCard

	-- Your score
	local yourScoreBox = Instance.new("Frame")
	yourScoreBox.Size = UDim2.new(0.45, 0, 1, 0)
	yourScoreBox.BackgroundColor3 = C.Green
	yourScoreBox.ZIndex = 203
	yourScoreBox.Parent = self.debateScoreFrame
	corner(yourScoreBox, 12)

	local yourLabel = Instance.new("TextLabel")
	yourLabel.Size = UDim2.new(1, 0, 0.5, 0)
	yourLabel.BackgroundTransparency = 1
	yourLabel.Font = F.Medium
	yourLabel.TextSize = 11
	yourLabel.TextColor3 = C.White
	yourLabel.Text = "YOU"
	yourLabel.ZIndex = 204
	yourLabel.Parent = yourScoreBox

	self.yourScoreLabel = Instance.new("TextLabel")
	self.yourScoreLabel.Size = UDim2.new(1, 0, 0.5, 0)
	self.yourScoreLabel.Position = UDim2.new(0, 0, 0.5, 0)
	self.yourScoreLabel.BackgroundTransparency = 1
	self.yourScoreLabel.Font = F.Title
	self.yourScoreLabel.TextSize = 20
	self.yourScoreLabel.TextColor3 = C.White
	self.yourScoreLabel.Text = "0"
	self.yourScoreLabel.ZIndex = 204
	self.yourScoreLabel.Parent = yourScoreBox

	-- Opponent score
	local oppScoreBox = Instance.new("Frame")
	oppScoreBox.Size = UDim2.new(0.45, 0, 1, 0)
	oppScoreBox.Position = UDim2.new(0.55, 0, 0, 0)
	oppScoreBox.BackgroundColor3 = C.Red
	oppScoreBox.ZIndex = 203
	oppScoreBox.Parent = self.debateScoreFrame
	corner(oppScoreBox, 12)

	local oppLabel = Instance.new("TextLabel")
	oppLabel.Size = UDim2.new(1, 0, 0.5, 0)
	oppLabel.BackgroundTransparency = 1
	oppLabel.Font = F.Medium
	oppLabel.TextSize = 11
	oppLabel.TextColor3 = C.White
	oppLabel.Text = "OPPONENT"
	oppLabel.ZIndex = 204
	oppLabel.Parent = oppScoreBox

	self.oppScoreLabel = Instance.new("TextLabel")
	self.oppScoreLabel.Size = UDim2.new(1, 0, 0.5, 0)
	self.oppScoreLabel.Position = UDim2.new(0, 0, 0.5, 0)
	self.oppScoreLabel.BackgroundTransparency = 1
	self.oppScoreLabel.Font = F.Title
	self.oppScoreLabel.TextSize = 20
	self.oppScoreLabel.TextColor3 = C.White
	self.oppScoreLabel.Text = "0"
	self.oppScoreLabel.ZIndex = 204
	self.oppScoreLabel.Parent = oppScoreBox

	-- Timer bar
	self.debateTimerBg = Instance.new("Frame")
	self.debateTimerBg.Size = UDim2.new(0.9, 0, 0, 12)
	self.debateTimerBg.AnchorPoint = Vector2.new(0.5, 0)
	self.debateTimerBg.Position = UDim2.new(0.5, 0, 0, 150)
	self.debateTimerBg.BackgroundColor3 = C.Gray700
	self.debateTimerBg.ZIndex = 202
	self.debateTimerBg.Parent = self.debateCard
	pill(self.debateTimerBg)

	self.debateTimerFill = Instance.new("Frame")
	self.debateTimerFill.Size = UDim2.new(1, 0, 1, 0)
	self.debateTimerFill.BackgroundColor3 = C.Amber
	self.debateTimerFill.ZIndex = 203
	self.debateTimerFill.Parent = self.debateTimerBg
	pill(self.debateTimerFill)

	-- Question display
	self.debateQuestion = Instance.new("TextLabel")
	self.debateQuestion.Size = UDim2.new(0.9, 0, 0, 80)
	self.debateQuestion.AnchorPoint = Vector2.new(0.5, 0)
	self.debateQuestion.Position = UDim2.new(0.5, 0, 0, 175)
	self.debateQuestion.BackgroundColor3 = C.Gray800
	self.debateQuestion.Font = F.Medium
	self.debateQuestion.TextSize = 16
	self.debateQuestion.TextColor3 = C.White
	self.debateQuestion.TextWrapped = true
	self.debateQuestion.Text = "Question loading..."
	self.debateQuestion.ZIndex = 202
	self.debateQuestion.Parent = self.debateCard
	corner(self.debateQuestion, 12)

	-- Answer buttons container
	self.debateAnswers = Instance.new("Frame")
	self.debateAnswers.Size = UDim2.new(0.9, 0, 0, 200)
	self.debateAnswers.AnchorPoint = Vector2.new(0.5, 0)
	self.debateAnswers.Position = UDim2.new(0.5, 0, 0, 270)
	self.debateAnswers.BackgroundTransparency = 1
	self.debateAnswers.ZIndex = 202
	self.debateAnswers.Parent = self.debateCard

	local answerLayout = Instance.new("UIListLayout")
	answerLayout.Padding = UDim.new(0, 10)
	answerLayout.Parent = self.debateAnswers

	self.debateAnswerBtns = {}
	for i = 1, 4 do
		local btn = Instance.new("TextButton")
		btn.Size = UDim2.new(1, 0, 0, 44)
		btn.BackgroundColor3 = C.Blue
		btn.Font = F.Button
		btn.TextSize = 14
		btn.TextColor3 = C.White
		btn.Text = "Answer " .. i
		btn.TextWrapped = true
		btn.AutoButtonColor = false
		btn.LayoutOrder = i
		btn.ZIndex = 203
		btn.Parent = self.debateAnswers
		corner(btn, 12)

		self.debateAnswerBtns[i] = btn
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Context-specific debate questions database
	-- Presidential questions ONLY for political context!
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	self.contextQuestions = {
		-- POLITICAL/PRESIDENTIAL DEBATES ONLY
		political = {
			{ q = "The moderator asks: What is your plan to address climate change?", answers = {
				{ text = "Invest in renewable energy and green jobs", correct = true },
				{ text = "Climate change is a hoax", correct = false },
				{ text = "Let the market figure it out", correct = false },
				{ text = "I don't understand the question", correct = false },
			}},
			{ q = "A citizen asks: How will you make healthcare more affordable?", answers = {
				{ text = "Expand coverage and negotiate better prices", correct = true },
				{ text = "Eliminate all healthcare programs", correct = false },
				{ text = "Healthcare is not a government issue", correct = false },
				{ text = "I'll think about it later", correct = false },
			}},
			{ q = "The moderator asks: How will you handle the economy?", answers = {
				{ text = "Invest in infrastructure and education", correct = true },
				{ text = "Cut all government spending", correct = false },
				{ text = "Print more money", correct = false },
				{ text = "Economy? What economy?", correct = false },
			}},
			{ q = "On foreign policy: How will you handle international relations?", answers = {
				{ text = "Strengthen alliances and diplomacy first", correct = true },
				{ text = "Isolate from the world", correct = false },
				{ text = "Declare war on everyone", correct = false },
				{ text = "Foreign policy isn't important", correct = false },
			}},
			{ q = "A voter asks: How will you reduce crime?", answers = {
				{ text = "Community programs and smart policing", correct = true },
				{ text = "Abolish all laws", correct = false },
				{ text = "Lock everyone up forever", correct = false },
				{ text = "Crime is fine actually", correct = false },
			}},
		},
		-- HEATED ARGUMENTS / RELATIONSHIP CONFLICTS
		argument = {
			{ q = "They say: You never listen to me!", answers = {
				{ text = "I hear you, let's talk about this calmly", correct = true },
				{ text = "Whatever, you're overreacting", correct = false },
				{ text = "No YOU never listen!", correct = false },
				{ text = "I'm leaving", correct = false },
			}},
			{ q = "They accuse: You always put yourself first!", answers = {
				{ text = "I'm sorry you feel that way, let's work on this", correct = true },
				{ text = "So what if I do?", correct = false },
				{ text = "That's ridiculous!", correct = false },
				{ text = "Maybe I should!", correct = false },
			}},
			{ q = "They're upset: You broke your promise!", answers = {
				{ text = "You're right, I'm sorry. How can I make it up?", correct = true },
				{ text = "It wasn't that important anyway", correct = false },
				{ text = "I never promised anything!", correct = false },
				{ text = "Deal with it", correct = false },
			}},
			{ q = "They demand: Explain yourself right now!", answers = {
				{ text = "Okay, let me explain what happened", correct = true },
				{ text = "I don't owe you an explanation", correct = false },
				{ text = "You're being crazy!", correct = false },
				{ text = "Make me!", correct = false },
			}},
			{ q = "They say: I can't trust you anymore!", answers = {
				{ text = "I understand, let me earn your trust back", correct = true },
				{ text = "Then don't, I don't care", correct = false },
				{ text = "You're being paranoid!", correct = false },
				{ text = "Good, I can't trust you either!", correct = false },
			}},
			{ q = "They're crying: You really hurt my feelings!", answers = {
				{ text = "I'm so sorry, that wasn't my intention", correct = true },
				{ text = "Stop being so sensitive", correct = false },
				{ text = "You hurt mine too!", correct = false },
				{ text = "Here we go again...", correct = false },
			}},
		},
		-- JOB INTERVIEWS
		interview = {
			{ q = "Interviewer: Why should we hire you?", answers = {
				{ text = "I bring unique skills and dedication to succeed", correct = true },
				{ text = "Because I need money", correct = false },
				{ text = "I dunno, you tell me", correct = false },
				{ text = "Because I'm awesome obviously", correct = false },
			}},
			{ q = "Interviewer: What's your biggest weakness?", answers = {
				{ text = "I work too hard sometimes, but I'm learning balance", correct = true },
				{ text = "I'm perfect, no weaknesses", correct = false },
				{ text = "I'm always late", correct = false },
				{ text = "I hate working", correct = false },
			}},
			{ q = "Interviewer: Where do you see yourself in 5 years?", answers = {
				{ text = "Growing with this company and taking on more responsibility", correct = true },
				{ text = "Definitely not here", correct = false },
				{ text = "Rich and retired", correct = false },
				{ text = "I don't plan that far ahead", correct = false },
			}},
			{ q = "Interviewer: Why did you leave your last job?", answers = {
				{ text = "I'm looking for new growth opportunities", correct = true },
				{ text = "My boss was terrible", correct = false },
				{ text = "I got fired for fighting", correct = false },
				{ text = "I was bored", correct = false },
			}},
			{ q = "Interviewer: How do you handle pressure?", answers = {
				{ text = "I stay calm and prioritize tasks effectively", correct = true },
				{ text = "I usually panic", correct = false },
				{ text = "I avoid stressful situations", correct = false },
				{ text = "Pressure? What's that?", correct = false },
			}},
		},
		-- CONFRONTATIONS / INTIMIDATION
		confrontation = {
			{ q = "They get in your face: What's your problem?!", answers = {
				{ text = "Let's talk about this like adults", correct = true },
				{ text = "YOU'RE my problem!", correct = false },
				{ text = "Back off before I make you!", correct = false },
				{ text = "I-I don't have a problem...", correct = false },
			}},
			{ q = "They threaten: You're gonna regret this!", answers = {
				{ text = "I don't want trouble, let's resolve this peacefully", correct = true },
				{ text = "Try me!", correct = false },
				{ text = "You're the one who'll regret it!", correct = false },
				{ text = "Please don't hurt me!", correct = false },
			}},
			{ q = "They mock: You think you're tough?", answers = {
				{ text = "I'm not looking for a fight", correct = true },
				{ text = "Tougher than you!", correct = false },
				{ text = "Yeah, what about it?!", correct = false },
				{ text = "N-no, not really...", correct = false },
			}},
			{ q = "They demand: Give me what I want or else!", answers = {
				{ text = "Let's find a solution that works for both of us", correct = true },
				{ text = "Or else what?!", correct = false },
				{ text = "You'll get nothing!", correct = false },
				{ text = "O-okay, here, take it...", correct = false },
			}},
			{ q = "They sneer: You don't belong here!", answers = {
				{ text = "I have every right to be here", correct = true },
				{ text = "Make me leave!", correct = false },
				{ text = "YOU don't belong here!", correct = false },
				{ text = "Sorry, I'll go...", correct = false },
			}},
		},
		-- FAMILY DRAMA
		family = {
			{ q = "Parent says: I'm disappointed in your choices!", answers = {
				{ text = "I understand, can we talk about your concerns?", correct = true },
				{ text = "I don't care what you think!", correct = false },
				{ text = "You're always disappointed!", correct = false },
				{ text = "Whatever...", correct = false },
			}},
			{ q = "Sibling argues: You always got special treatment!", answers = {
				{ text = "I'm sorry you feel that way, that wasn't intentional", correct = true },
				{ text = "Because I deserved it!", correct = false },
				{ text = "No, YOU did!", correct = false },
				{ text = "Stop whining about the past", correct = false },
			}},
			{ q = "Relative asks: When are you getting married?", answers = {
				{ text = "When the time is right for me", correct = true },
				{ text = "None of your business!", correct = false },
				{ text = "Never, just to spite you!", correct = false },
				{ text = "Stop asking me that!", correct = false },
			}},
			{ q = "Family member: You need to take more responsibility!", answers = {
				{ text = "You're right, I'll work on that", correct = true },
				{ text = "I take plenty of responsibility!", correct = false },
				{ text = "You're not my parent!", correct = false },
				{ text = "Mind your own business!", correct = false },
			}},
			{ q = "Parent asks: Why don't you visit more often?", answers = {
				{ text = "I'll try to come by more, I've been busy", correct = true },
				{ text = "Because I don't want to!", correct = false },
				{ text = "You never visit ME!", correct = false },
				{ text = "I have my own life!", correct = false },
			}},
		},
		-- FRIENDSHIP DISPUTES
		friendship = {
			{ q = "Friend says: You've been ignoring me lately!", answers = {
				{ text = "I'm sorry, I've been going through stuff. Let's hang out!", correct = true },
				{ text = "Maybe because you're annoying", correct = false },
				{ text = "You ignore me too!", correct = false },
				{ text = "I have other friends you know", correct = false },
			}},
			{ q = "Friend accuses: You told my secret!", answers = {
				{ text = "I'm really sorry, I made a mistake and I regret it", correct = true },
				{ text = "It wasn't that big of a secret", correct = false },
				{ text = "I never said anything!", correct = false },
				{ text = "Everyone already knew!", correct = false },
			}},
			{ q = "Friend asks: Why weren't you at my party?", answers = {
				{ text = "I'm so sorry I missed it, something came up", correct = true },
				{ text = "I didn't feel like going", correct = false },
				{ text = "I forgot about it", correct = false },
				{ text = "Your parties are boring anyway", correct = false },
			}},
			{ q = "Friend upset: You chose them over me!", answers = {
				{ text = "I value our friendship, it's not a competition", correct = true },
				{ text = "Yeah, they're cooler", correct = false },
				{ text = "You're being jealous!", correct = false },
				{ text = "I can have multiple friends!", correct = false },
			}},
			{ q = "Friend questions: Are we even real friends?", answers = {
				{ text = "Of course we are! You mean a lot to me", correct = true },
				{ text = "I don't know, are we?", correct = false },
				{ text = "If you have to ask...", correct = false },
				{ text = "We're just acquaintances really", correct = false },
			}},
		},
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX: MCAT / MEDICAL SCHOOL EXAM QUESTIONS
		-- User complaint: "MCAT EXAM IS ARGUMENTS NOT ACTUAL MEDICAL QUESTIONS"
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		medical = {
			{ q = "MCAT: Which organ is primarily responsible for detoxification?", answers = {
				{ text = "Liver", correct = true },
				{ text = "Kidneys", correct = false },
				{ text = "Heart", correct = false },
				{ text = "Lungs", correct = false },
			}},
			{ q = "MCAT: What type of blood cells fight infection?", answers = {
				{ text = "White blood cells", correct = true },
				{ text = "Red blood cells", correct = false },
				{ text = "Platelets", correct = false },
				{ text = "Plasma cells", correct = false },
			}},
			{ q = "MCAT: Which part of the brain controls balance and coordination?", answers = {
				{ text = "Cerebellum", correct = true },
				{ text = "Cerebrum", correct = false },
				{ text = "Medulla", correct = false },
				{ text = "Hypothalamus", correct = false },
			}},
			{ q = "MCAT: DNA replication occurs during which cell phase?", answers = {
				{ text = "S phase (Synthesis)", correct = true },
				{ text = "G1 phase", correct = false },
				{ text = "G2 phase", correct = false },
				{ text = "M phase (Mitosis)", correct = false },
			}},
			{ q = "MCAT: Which hormone regulates blood sugar levels?", answers = {
				{ text = "Insulin", correct = true },
				{ text = "Cortisol", correct = false },
				{ text = "Adrenaline", correct = false },
				{ text = "Thyroxine", correct = false },
			}},
			{ q = "MCAT: The heart's pacemaker is located in the:", answers = {
				{ text = "Sinoatrial (SA) node", correct = true },
				{ text = "Atrioventricular (AV) node", correct = false },
				{ text = "Bundle of His", correct = false },
				{ text = "Purkinje fibers", correct = false },
			}},
		},
		mcat = {}, -- Will be populated to point to medical
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- LSAT / LAW SCHOOL EXAM QUESTIONS
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		law = {
			{ q = "LSAT: If all lawyers are professionals, and some professionals are wealthy, which must be true?", answers = {
				{ text = "Some lawyers may be wealthy", correct = true },
				{ text = "All lawyers are wealthy", correct = false },
				{ text = "No lawyers are wealthy", correct = false },
				{ text = "All wealthy people are lawyers", correct = false },
			}},
			{ q = "LSAT: Which amendment protects against unreasonable searches?", answers = {
				{ text = "Fourth Amendment", correct = true },
				{ text = "First Amendment", correct = false },
				{ text = "Fifth Amendment", correct = false },
				{ text = "Second Amendment", correct = false },
			}},
			{ q = "LSAT: The principle of 'stare decisis' means:", answers = {
				{ text = "Courts should follow prior rulings", correct = true },
				{ text = "Defendants are innocent until proven guilty", correct = false },
				{ text = "Laws must be written clearly", correct = false },
				{ text = "Judges cannot be sued", correct = false },
			}},
			{ q = "LSAT: Which type of crime requires proving criminal intent?", answers = {
				{ text = "Mens rea crimes", correct = true },
				{ text = "Strict liability crimes", correct = false },
				{ text = "Civil infractions", correct = false },
				{ text = "Traffic violations", correct = false },
			}},
			{ q = "LSAT: A contract requires all of the following EXCEPT:", answers = {
				{ text = "A written document in all cases", correct = true },
				{ text = "Offer and acceptance", correct = false },
				{ text = "Consideration", correct = false },
				{ text = "Capacity to contract", correct = false },
			}},
			{ q = "LSAT: 'Habeas corpus' protects against:", answers = {
				{ text = "Unlawful detention", correct = true },
				{ text = "Double jeopardy", correct = false },
				{ text = "Self-incrimination", correct = false },
				{ text = "Cruel punishment", correct = false },
			}},
		},
		lsat = {}, -- Will be populated to point to law
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- GMAT / BUSINESS SCHOOL EXAM QUESTIONS
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		business = {
			{ q = "GMAT: If revenue is $100K and costs are $60K, what's the profit margin?", answers = {
				{ text = "40%", correct = true },
				{ text = "60%", correct = false },
				{ text = "140%", correct = false },
				{ text = "30%", correct = false },
			}},
			{ q = "GMAT: Which financial statement shows a company's assets and liabilities?", answers = {
				{ text = "Balance Sheet", correct = true },
				{ text = "Income Statement", correct = false },
				{ text = "Cash Flow Statement", correct = false },
				{ text = "P&L Statement", correct = false },
			}},
			{ q = "GMAT: 'SWOT' analysis includes all EXCEPT:", answers = {
				{ text = "Tactics", correct = true },
				{ text = "Strengths", correct = false },
				{ text = "Weaknesses", correct = false },
				{ text = "Opportunities", correct = false },
			}},
			{ q = "GMAT: The 'break-even point' is when:", answers = {
				{ text = "Total revenue equals total costs", correct = true },
				{ text = "Profits are maximized", correct = false },
				{ text = "All debts are paid off", correct = false },
				{ text = "Sales exceed projections", correct = false },
			}},
			{ q = "GMAT: A company's 'market cap' is calculated by:", answers = {
				{ text = "Stock price Ã— shares outstanding", correct = true },
				{ text = "Total revenue - expenses", correct = false },
				{ text = "Assets - liabilities", correct = false },
				{ text = "Net income Ã— PE ratio", correct = false },
			}},
			{ q = "GMAT: ROI stands for:", answers = {
				{ text = "Return on Investment", correct = true },
				{ text = "Rate of Inflation", correct = false },
				{ text = "Revenue over Income", correct = false },
				{ text = "Risk of Investment", correct = false },
			}},
		},
		gmat = {}, -- Will be populated to point to business
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- STREET HUSTLER / STREET SMARTS QUESTIONS
		-- User complaint: "STREET HUSTLER HAS SAME INTERVIEWS AS EVERYTHING"
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		street = {
			{ q = "Someone's trying to short-change you. What do you do?", answers = {
				{ text = "Count the money carefully in front of them", correct = true },
				{ text = "Trust them and walk away", correct = false },
				{ text = "Start a fight immediately", correct = false },
				{ text = "Just take whatever they give", correct = false },
			}},
			{ q = "A rival crew is moving into your territory. How do you respond?", answers = {
				{ text = "Talk to their leader and negotiate boundaries", correct = true },
				{ text = "Attack them without warning", correct = false },
				{ text = "Run away and hide", correct = false },
				{ text = "Call the police", correct = false },
			}},
			{ q = "A customer is asking for credit. What's the smart move?", answers = {
				{ text = "Only extend credit to regulars with a good track record", correct = true },
				{ text = "Give everyone unlimited credit", correct = false },
				{ text = "Never give anyone credit ever", correct = false },
				{ text = "Double the price for credit", correct = false },
			}},
			{ q = "The cops are asking questions about you. What's the play?", answers = {
				{ text = "Say nothing and get a lawyer", correct = true },
				{ text = "Tell them everything to be helpful", correct = false },
				{ text = "Run away as fast as possible", correct = false },
				{ text = "Try to bribe them on the spot", correct = false },
			}},
			{ q = "Someone wants to partner up. How do you vet them?", answers = {
				{ text = "Test them with small jobs first, watch how they handle pressure", correct = true },
				{ text = "Trust them immediately because they seem nice", correct = false },
				{ text = "Never work with anyone ever", correct = false },
				{ text = "Give them full access to everything right away", correct = false },
			}},
			{ q = "You find out someone's been talking to the feds. What now?", answers = {
				{ text = "Cut all ties quietly and secure your operations", correct = true },
				{ text = "Confront them violently", correct = false },
				{ text = "Ignore it and hope it goes away", correct = false },
				{ text = "Turn yourself in first", correct = false },
			}},
		},
		street_hustler = {}, -- Will be populated to point to street
		hustler = {}, -- Alias
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- SCHOOL EXAMS (K-12)
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		school = {
			{ q = "Math: What is 15% of 200?", answers = {
				{ text = "30", correct = true },
				{ text = "15", correct = false },
				{ text = "45", correct = false },
				{ text = "20", correct = false },
			}},
			{ q = "Science: What planet is closest to the Sun?", answers = {
				{ text = "Mercury", correct = true },
				{ text = "Venus", correct = false },
				{ text = "Mars", correct = false },
				{ text = "Earth", correct = false },
			}},
			{ q = "History: Who was the first President of the United States?", answers = {
				{ text = "George Washington", correct = true },
				{ text = "Abraham Lincoln", correct = false },
				{ text = "Thomas Jefferson", correct = false },
				{ text = "Benjamin Franklin", correct = false },
			}},
			{ q = "English: Which word is a verb?", answers = {
				{ text = "Run", correct = true },
				{ text = "Beautiful", correct = false },
				{ text = "Quickly", correct = false },
				{ text = "Book", correct = false },
			}},
			{ q = "Geography: What is the capital of France?", answers = {
				{ text = "Paris", correct = true },
				{ text = "London", correct = false },
				{ text = "Berlin", correct = false },
				{ text = "Rome", correct = false },
			}},
			{ q = "Science: What do plants need to make food through photosynthesis?", answers = {
				{ text = "Sunlight, water, and carbon dioxide", correct = true },
				{ text = "Soil and fertilizer", correct = false },
				{ text = "Air and darkness", correct = false },
				{ text = "Just water", correct = false },
			}},
		},
		exam = {}, -- Will be populated to point to school
		test = {}, -- Alias
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- COLLEGE EXAMS
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		college = {
			{ q = "Statistics: What does a p-value less than 0.05 typically indicate?", answers = {
				{ text = "Statistically significant results", correct = true },
				{ text = "The experiment failed", correct = false },
				{ text = "No relationship between variables", correct = false },
				{ text = "Sample size is too small", correct = false },
			}},
			{ q = "Economics: What happens when demand exceeds supply?", answers = {
				{ text = "Prices tend to rise", correct = true },
				{ text = "Prices tend to fall", correct = false },
				{ text = "Nothing changes", correct = false },
				{ text = "Government intervenes always", correct = false },
			}},
			{ q = "Psychology: Who developed the hierarchy of needs?", answers = {
				{ text = "Abraham Maslow", correct = true },
				{ text = "Sigmund Freud", correct = false },
				{ text = "Carl Jung", correct = false },
				{ text = "B.F. Skinner", correct = false },
			}},
			{ q = "Chemistry: What is the pH of a neutral solution?", answers = {
				{ text = "7", correct = true },
				{ text = "0", correct = false },
				{ text = "14", correct = false },
				{ text = "1", correct = false },
			}},
			{ q = "Philosophy: 'I think, therefore I am' was said by:", answers = {
				{ text = "RenÃ© Descartes", correct = true },
				{ text = "Plato", correct = false },
				{ text = "Aristotle", correct = false },
				{ text = "Socrates", correct = false },
			}},
		},
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- DRIVING TEST
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		driving = {
			{ q = "Driving: At a 4-way stop, who has the right of way?", answers = {
				{ text = "The first car to arrive", correct = true },
				{ text = "The biggest vehicle", correct = false },
				{ text = "The fastest car", correct = false },
				{ text = "No one - everyone goes at once", correct = false },
			}},
			{ q = "Driving: What should you do when approaching a yellow light?", answers = {
				{ text = "Slow down and prepare to stop", correct = true },
				{ text = "Speed up to beat the red", correct = false },
				{ text = "Stop immediately", correct = false },
				{ text = "Honk your horn", correct = false },
			}},
			{ q = "Driving: The legal blood alcohol limit for adults in most states is:", answers = {
				{ text = "0.08%", correct = true },
				{ text = "0.10%", correct = false },
				{ text = "0.05%", correct = false },
				{ text = "0.00%", correct = false },
			}},
			{ q = "Driving: When should you use your headlights?", answers = {
				{ text = "30 minutes before sunset to 30 minutes after sunrise", correct = true },
				{ text = "Only when it's completely dark", correct = false },
				{ text = "Only when raining", correct = false },
				{ text = "Never during daytime", correct = false },
			}},
			{ q = "Driving: What does a flashing red light mean?", answers = {
				{ text = "Stop, then proceed when safe", correct = true },
				{ text = "Slow down only", correct = false },
				{ text = "Proceed with caution", correct = false },
				{ text = "Stop and wait for green", correct = false },
			}},
		},
		dmv = {}, -- Alias for driving
		
		-- GENERAL QUICK THINKING (fallback for unmatched contexts)
		general = {
			{ q = "Quick! What's the best approach to a new challenge?", answers = {
				{ text = "Stay calm and think it through", correct = true },
				{ text = "Panic and give up", correct = false },
				{ text = "Ignore it completely", correct = false },
				{ text = "Blame someone else", correct = false },
			}},
			{ q = "Someone needs your help. What do you do?", answers = {
				{ text = "Assess the situation and offer assistance", correct = true },
				{ text = "Pretend you didn't notice", correct = false },
				{ text = "Walk away quickly", correct = false },
				{ text = "Make it about yourself", correct = false },
			}},
			{ q = "You made a mistake. The best response is:", answers = {
				{ text = "Acknowledge it and learn from it", correct = true },
				{ text = "Blame everyone else", correct = false },
				{ text = "Pretend it never happened", correct = false },
				{ text = "Get angry at those who noticed", correct = false },
			}},
			{ q = "A difficult decision is ahead. How do you proceed?", answers = {
				{ text = "Gather information and consider the consequences", correct = true },
				{ text = "Flip a coin", correct = false },
				{ text = "Let someone else decide", correct = false },
				{ text = "Avoid making any choice", correct = false },
			}},
			{ q = "You're facing pressure. What's your strategy?", answers = {
				{ text = "Take a deep breath and prioritize", correct = true },
				{ text = "Shut down completely", correct = false },
				{ text = "Lash out at others", correct = false },
				{ text = "Quit immediately", correct = false },
			}},
		},
	}

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Set up alias tables to point to main question pools
	-- This ensures aliases like "mcat" properly use "medical" questions
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	self.contextQuestions.mcat = self.contextQuestions.medical
	self.contextQuestions.lsat = self.contextQuestions.law
	self.contextQuestions.gmat = self.contextQuestions.business
	self.contextQuestions.street_hustler = self.contextQuestions.street
	self.contextQuestions.hustler = self.contextQuestions.street
	self.contextQuestions.exam = self.contextQuestions.school
	self.contextQuestions.test = self.contextQuestions.school
	self.contextQuestions.dmv = self.contextQuestions.driving

	-- Default to general questions for backwards compatibility
	self.debateQuestions = self.contextQuestions.general
end

function Minigames:startDebate(callback, options)
	self.callback = callback
	self.debateOverlay.Visible = true
	self.activeGame = "debate"

	-- CRITICAL FIX: Dynamic title based on context!
	-- Options can contain: title, context, difficulty
	options = options or {}
	local context = options.context or "general"
	local title = options.title
	
	-- Set appropriate title based on context
	-- CRITICAL FIX: Expanded context handling to prevent "Presidential Debate" from showing incorrectly
	if title then
		self.debateStageTitle.Text = title
	elseif context == "interview" or context == "job" then
		self.debateStageTitle.Text = "ğŸ¤ JOB INTERVIEW"
	elseif context == "argument" or context == "relationship" then
		self.debateStageTitle.Text = "ğŸ’¬ HEATED ARGUMENT"
	elseif context == "cheating_confrontation" then
		self.debateStageTitle.Text = "ğŸ’” CONFRONTATION"
	elseif context == "office_confrontation" or context == "office" then
		self.debateStageTitle.Text = "ğŸ˜¤ OFFICE SHOWDOWN"
	elseif context == "exam" or context == "test" or context == "school" then
		self.debateStageTitle.Text = "ğŸ“ EXAM TIME"
	-- CRITICAL FIX: Specific exam titles for different school types!
	elseif context == "mcat" or context == "medical" or context == "med_school" then
		self.debateStageTitle.Text = "ğŸ¥ MCAT EXAM"
	elseif context == "lsat" or context == "law" or context == "law_school" then
		self.debateStageTitle.Text = "âš–ï¸ LSAT EXAM"
	elseif context == "gmat" or context == "business" or context == "business_school" then
		self.debateStageTitle.Text = "ğŸ’¼ GMAT EXAM"
	elseif context == "driving" or context == "dmv" or context == "drivers_test" then
		self.debateStageTitle.Text = "ğŸš— DRIVING TEST"
	elseif context == "college" or context == "university" then
		self.debateStageTitle.Text = "ğŸ“ COLLEGE EXAM"
	elseif context == "street" or context == "street_hustler" or context == "hustler" then
		self.debateStageTitle.Text = "ğŸ”¥ STREET SMARTS"
	elseif context == "karaoke" or context == "singing" then
		self.debateStageTitle.Text = "ğŸ¤ KARAOKE BATTLE"
	elseif context == "extortion" or context == "intimidation" then
		self.debateStageTitle.Text = "ğŸ˜¤ INTIMIDATION"
	elseif context == "politics" or context == "political" then
		self.debateStageTitle.Text = "ğŸ›ï¸ POLITICAL DEBATE"
	elseif context == "internet" or context == "online" then
		self.debateStageTitle.Text = "ğŸ’» ONLINE ARGUMENT"
	elseif context == "negotiation" or context == "deal" then
		self.debateStageTitle.Text = "ğŸ¤ NEGOTIATION"
	elseif context == "court" or context == "legal" or context == "trial" then
		self.debateStageTitle.Text = "âš–ï¸ COURT BATTLE"
	elseif context == "family" or context == "relatives" then
		self.debateStageTitle.Text = "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ FAMILY DRAMA"
	elseif context == "friendship" or context == "friends" then
		self.debateStageTitle.Text = "ğŸ‘« FRIEND DISPUTE"
	else
		self.debateStageTitle.Text = "ğŸ¤ QUICK THINKING"
	end

	self.yourScore = 0
	self.oppScore = 0
	self.currentQuestion = 0
	self.totalQuestions = options.questionCount or 5

	self.yourScoreLabel.Text = "0"
	self.oppScoreLabel.Text = "0"

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Select questions based on CONTEXT!
	-- Presidential questions ONLY for political context!
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	self.selectedQuestions = {}
	local shuffled = {}

	-- Map context to question pool
	-- CRITICAL FIX: Added more relationship-specific context mappings
	-- User complaint: "argument minigame has unrelated replies for relationship arguments"
	local contextMap = {
		politics = "political", political = "political", president = "political", election = "political",
		-- RELATIONSHIP ARGUMENTS - all map to "argument" pool which has relationship-focused questions
		argument = "argument", relationship = "argument", cheating_confrontation = "argument",
		relationship_argument = "argument", partner_argument = "argument", spouse_argument = "argument",
		dating_argument = "argument", boyfriend_argument = "argument", girlfriend_argument = "argument",
		marriage_argument = "argument", couple_argument = "argument", lover_argument = "argument",
		-- INTERVIEWS
		interview = "interview", job = "interview", job_interview = "interview",
		-- CONFRONTATIONS (non-relationship)
		confrontation = "confrontation", intimidation = "confrontation", extortion = "confrontation",
		mafia_intimidation = "confrontation", gang_confrontation = "confrontation",
		-- FAMILY
		family = "family", relatives = "family", parent_argument = "family", sibling_argument = "family",
		-- FRIENDS
		friendship = "friendship", friends = "friendship", friend_argument = "friendship",
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX: EXAM TYPES - User complained about broken exam questions!
		-- "MCAT EXAM IS ARGUMENTS NOT ACTUAL MEDICAL QUESTIONS"
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- MEDICAL SCHOOL / MCAT
		mcat = "medical", medical = "medical", med_school = "medical", 
		medical_school = "medical", premed = "medical", doctor_exam = "medical",
		-- LAW SCHOOL / LSAT
		lsat = "law", law = "law", law_school = "law", bar_exam = "law",
		lawyer_exam = "law", legal_exam = "law", attorney = "law",
		-- BUSINESS SCHOOL / GMAT
		gmat = "business", business = "business", business_school = "business",
		mba = "business", finance_exam = "business", accounting_exam = "business",
		-- DRIVING TEST
		driving = "driving", dmv = "driving", drivers_test = "driving",
		license_test = "driving", driving_exam = "driving",
		-- COLLEGE GENERAL
		college = "college", university = "college", college_exam = "college",
		finals = "college", midterms = "college",
		-- SCHOOL (K-12)
		school = "school", exam = "school", test = "school", highschool = "school",
		grade_school = "school", middle_school = "school",
		-- STREET HUSTLER
		street = "street", street_hustler = "street", hustler = "street",
		street_smarts = "street", hustle = "street", dealing = "street",
	}

	-- Get the right question pool for this context
	local questionPool = contextMap[context] or "general"
	local questions = self.contextQuestions[questionPool] or self.contextQuestions.general

	print("[Minigames] Using question pool: " .. questionPool .. " for context: " .. tostring(context))

	for _, q in ipairs(questions) do
		table.insert(shuffled, q)
	end
	for i = #shuffled, 2, -1 do
		local j = math.random(i)
		shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
	end
	for i = 1, math.min(self.totalQuestions, #shuffled) do
		table.insert(self.selectedQuestions, shuffled[i])
	end

	self:showNextDebateQuestion()
end

function Minigames:showNextDebateQuestion()
	self.currentQuestion += 1

	if self.currentQuestion > #self.selectedQuestions then
		self:endDebate()
		return
	end

	local q = self.selectedQuestions[self.currentQuestion]
	-- CRITICAL FIX: Guard against nil question
	if not q or not q.q then
		warn("[Minigames] Question is nil at index:", self.currentQuestion)
		self:endDebate()
		return
	end
	self.debateQuestion.Text = "Q" .. self.currentQuestion .. "/" .. #self.selectedQuestions .. ": " .. q.q

	-- Shuffle answers
	local shuffledAnswers = {}
	for _, a in ipairs(q.answers) do
		table.insert(shuffledAnswers, a)
	end
	for i = #shuffledAnswers, 2, -1 do
		local j = math.random(i)
		shuffledAnswers[i], shuffledAnswers[j] = shuffledAnswers[j], shuffledAnswers[i]
	end

	-- Clear old button connections
	disconnectAll(self._debateButtonConnections)
	self._debateButtonConnections = {}

	-- Set up buttons
	for i, btn in ipairs(self.debateAnswerBtns) do
		local answer = shuffledAnswers[i]
		if answer then
			btn.Visible = true
			btn.Text = answer.text
			btn.BackgroundColor3 = C.Blue

			self._debateButtonConnections[i] = btn.MouseButton1Click:Connect(function()
				self:handleDebateAnswer(answer.correct)
			end)
		else
			btn.Visible = false
		end
	end

	-- Timer animation
	self.debateTimerFill.Size = UDim2.new(1, 0, 1, 0)

	if self._debateTimerConnection then
		pcall(function() task.cancel(self._debateTimerConnection) end)
		self._debateTimerConnection = nil
	end

	tween(self.debateTimerFill, TweenInfo.new(8, Enum.EasingStyle.Linear), {
		Size = UDim2.new(0, 0, 1, 0),
	})

	self._debateTimerConnection = task.delay(8, function()
		if self.activeGame == "debate" then
			self:handleDebateAnswer(false) -- timeout
		end
	end)
end

function Minigames:handleDebateAnswer(correct)
	if self._debateTimerConnection then
		pcall(function() task.cancel(self._debateTimerConnection) end)
		self._debateTimerConnection = nil
	end

	if correct then
		self.yourScore += 1
		self.yourScoreLabel.Text = tostring(self.yourScore)
		for _, btn in ipairs(self.debateAnswerBtns) do
			if btn.Visible then
				btn.BackgroundColor3 = C.Green
			end
		end
	else
		self.oppScore += 1
		self.oppScoreLabel.Text = tostring(self.oppScore)
		for _, btn in ipairs(self.debateAnswerBtns) do
			if btn.Visible then
				btn.BackgroundColor3 = C.Red
			end
		end
	end

	task.delay(0.8, function()
		if self.activeGame == "debate" then
			self:showNextDebateQuestion()
		end
	end)
end

function Minigames:endDebate()
	self.activeGame = nil
	self.debateOverlay.Visible = false

	disconnectAll(self._debateButtonConnections)
	self._debateButtonConnections = {}
	if self._debateTimerConnection then
		pcall(function() task.cancel(self._debateTimerConnection) end)
		self._debateTimerConnection = nil
	end

	local won = self.yourScore > self.oppScore
	if self.callback then
		self.callback(won, { yourScore = self.yourScore, oppScore = self.oppScore })
		self.callback = nil
	end
end

----------------------------------------------------------------
-- HEIST MINIGAME (Criminal Path)
----------------------------------------------------------------

function Minigames:createHeistGame()
	self.heistOverlay = Instance.new("Frame")
	self.heistOverlay.Size = UDim2.fromScale(1, 1)
	self.heistOverlay.BackgroundColor3 = C.Black
	self.heistOverlay.BackgroundTransparency = 0.2
	self.heistOverlay.Visible = false
	self.heistOverlay.ZIndex = 200
	self.heistOverlay.Parent = self.screenGui

	self.heistCard = Instance.new("Frame")
	-- CRITICAL FIX: Use percentage height for mobile compatibility
	self.heistCard.Size = UDim2.new(0.95, 0, 0.85, 0)
	self.heistCard.ClipsDescendants = true
	self.heistCard.AnchorPoint = Vector2.new(0.5, 0.5)
	self.heistCard.Position = UDim2.fromScale(0.5, 0.5)
	self.heistCard.BackgroundColor3 = Color3.fromRGB(30, 30, 35)
	self.heistCard.ZIndex = 201
	self.heistCard.Parent = self.heistOverlay
	corner(self.heistCard, 20)

	-- Title
	local heistTitle = Instance.new("TextLabel")
	heistTitle.Size = UDim2.new(1, 0, 0, 60)
	heistTitle.BackgroundColor3 = Color3.fromRGB(180, 50, 50)
	heistTitle.Font = F.Title
	heistTitle.TextSize = 24
	heistTitle.TextColor3 = C.White
	heistTitle.Text = "ğŸ”“ CRACK THE SAFE"
	heistTitle.ZIndex = 202
	heistTitle.Parent = self.heistCard
	corner(heistTitle, 20)

	local titleFix = Instance.new("Frame")
	titleFix.Size = UDim2.new(1, 0, 0, 30)
	titleFix.Position = UDim2.new(0, 0, 0, 35)
	titleFix.BackgroundColor3 = Color3.fromRGB(180, 50, 50)
	titleFix.ZIndex = 202
	titleFix.Parent = heistTitle

	-- Instructions
	self.heistInstructions = Instance.new("TextLabel")
	self.heistInstructions.Size = UDim2.new(0.9, 0, 0, 40)
	self.heistInstructions.AnchorPoint = Vector2.new(0.5, 0)
	self.heistInstructions.Position = UDim2.new(0.5, 0, 0, 70)
	self.heistInstructions.BackgroundTransparency = 1
	self.heistInstructions.Font = F.Body
	self.heistInstructions.TextSize = 14
	self.heistInstructions.TextColor3 = C.Gray300
	self.heistInstructions.TextWrapped = true
	self.heistInstructions.Text = "Find the 4-digit code! Green = correct digit & position. Yellow = correct digit, wrong position."
	self.heistInstructions.ZIndex = 202
	self.heistInstructions.Parent = self.heistCard

	-- Attempts remaining
	self.heistAttempts = Instance.new("TextLabel")
	self.heistAttempts.Size = UDim2.new(0.9, 0, 0, 30)
	self.heistAttempts.AnchorPoint = Vector2.new(0.5, 0)
	self.heistAttempts.Position = UDim2.new(0.5, 0, 0, 110)
	self.heistAttempts.BackgroundTransparency = 1
	self.heistAttempts.Font = F.Button
	self.heistAttempts.TextSize = 16
	self.heistAttempts.TextColor3 = C.Amber
	self.heistAttempts.Text = "Attempts: 6 remaining"
	self.heistAttempts.ZIndex = 202
	self.heistAttempts.Parent = self.heistCard

	-- Code input display
	self.heistCodeDisplay = Instance.new("Frame")
	self.heistCodeDisplay.Size = UDim2.new(0.8, 0, 0, 60)
	self.heistCodeDisplay.AnchorPoint = Vector2.new(0.5, 0)
	self.heistCodeDisplay.Position = UDim2.new(0.5, 0, 0, 150)
	self.heistCodeDisplay.BackgroundColor3 = C.Gray800
	self.heistCodeDisplay.ZIndex = 202
	self.heistCodeDisplay.Parent = self.heistCard
	corner(self.heistCodeDisplay, 12)

	local codeLayout = Instance.new("UIListLayout")
	codeLayout.FillDirection = Enum.FillDirection.Horizontal
	codeLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	codeLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	codeLayout.Padding = UDim.new(0, 8)
	codeLayout.Parent = self.heistCodeDisplay

	self.heistDigitLabels = {}
	for i = 1, 4 do
		local digitFrame = Instance.new("Frame")
		digitFrame.Size = UDim2.new(0, 50, 0, 50)
		digitFrame.BackgroundColor3 = C.Gray700
		digitFrame.LayoutOrder = i
		digitFrame.ZIndex = 203
		digitFrame.Parent = self.heistCodeDisplay
		corner(digitFrame, 8)

		local digitLabel = Instance.new("TextLabel")
		digitLabel.Size = UDim2.fromScale(1, 1)
		digitLabel.BackgroundTransparency = 1
		digitLabel.Font = F.Title
		digitLabel.TextSize = 28
		digitLabel.TextColor3 = C.White
		digitLabel.Text = "_"
		digitLabel.ZIndex = 204
		digitLabel.Parent = digitFrame

		self.heistDigitLabels[i] = { frame = digitFrame, label = digitLabel }
	end

	-- Number pad
	self.heistNumpad = Instance.new("Frame")
	self.heistNumpad.Size = UDim2.new(0.8, 0, 0, 180)
	self.heistNumpad.AnchorPoint = Vector2.new(0.5, 0)
	self.heistNumpad.Position = UDim2.new(0.5, 0, 0, 225)
	self.heistNumpad.BackgroundTransparency = 1
	self.heistNumpad.ZIndex = 202
	self.heistNumpad.Parent = self.heistCard

	local numpadLayout = Instance.new("UIGridLayout")
	numpadLayout.CellSize = UDim2.new(0.3, 0, 0.22, 0)
	numpadLayout.CellPadding = UDim2.new(0.025, 0, 0.04, 0)
	numpadLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	numpadLayout.Parent = self.heistNumpad

	local numOrder = { "1", "2", "3", "4", "5", "6", "7", "8", "9", "âŒ«", "0", "âœ“" }
	self.heistNumBtns = {}
	for i, num in ipairs(numOrder) do
		local btn = Instance.new("TextButton")
		btn.BackgroundColor3 = (num == "âœ“" and C.Green) or (num == "âŒ«" and C.Red) or C.Gray600
		btn.Font = F.Title
		btn.TextSize = 24
		btn.TextColor3 = C.White
		btn.Text = num
		btn.AutoButtonColor = false
		btn.LayoutOrder = i
		btn.ZIndex = 203
		btn.Parent = self.heistNumpad
		corner(btn, 12)

		self.heistNumBtns[num] = btn
	end

	-- Previous guesses
	self.heistHistory = Instance.new("Frame")
	self.heistHistory.Size = UDim2.new(0.9, 0, 0, 80)
	self.heistHistory.AnchorPoint = Vector2.new(0.5, 0)
	self.heistHistory.Position = UDim2.new(0.5, 0, 0, 415)
	self.heistHistory.BackgroundColor3 = C.Gray800
	self.heistHistory.ZIndex = 202
	self.heistHistory.Parent = self.heistCard
	corner(self.heistHistory, 12)

	local historyLayout = Instance.new("UIListLayout")
	historyLayout.FillDirection = Enum.FillDirection.Horizontal
	historyLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	historyLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	historyLayout.Padding = UDim.new(0, 8)
	historyLayout.Parent = self.heistHistory

	self.heistHistoryLabels = {}
end

function Minigames:startHeist(callback)
	self.callback = callback
	self.heistOverlay.Visible = true
	self.activeGame = "heist"

	-- Generate secret code
	self.heistSecretCode = ""
	for _ = 1, 4 do
		self.heistSecretCode ..= tostring(math.random(0, 9))
	end

	self.heistCurrentInput = ""
	self.heistAttemptsLeft = 6
	self.heistGuesses = {}

	self.heistAttempts.Text = "Attempts: " .. self.heistAttemptsLeft .. " remaining"

	for _, data in ipairs(self.heistDigitLabels) do
		data.label.Text = "_"
		data.frame.BackgroundColor3 = C.Gray700
	end

	for _, child in ipairs(self.heistHistory:GetChildren()) do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end

	disconnectAll(self._heistNumConnections)
	self._heistNumConnections = {}

	for num, btn in pairs(self.heistNumBtns) do
		self._heistNumConnections[num] = btn.MouseButton1Click:Connect(function()
			self:handleHeistInput(num)
		end)
	end
end

function Minigames:handleHeistInput(input)
	if self.activeGame ~= "heist" then return end

	if input == "âŒ«" then
		if #self.heistCurrentInput > 0 then
			self.heistCurrentInput = string.sub(self.heistCurrentInput, 1, -2)
		end
	elseif input == "âœ“" then
		if #self.heistCurrentInput == 4 then
			self:submitHeistGuess()
		end
	else
		if #self.heistCurrentInput < 4 then
			self.heistCurrentInput ..= input
		end
	end

	for i, data in ipairs(self.heistDigitLabels) do
		local char = string.sub(self.heistCurrentInput, i, i)
		data.label.Text = (char ~= "" and char) or "_"
	end
end

function Minigames:submitHeistGuess()
	local guess = self.heistCurrentInput
	if #guess ~= 4 then return end

	self.heistAttemptsLeft -= 1
	self.heistAttempts.Text = "Attempts: " .. self.heistAttemptsLeft .. " remaining"

	local results = {}

	-- First pass: exact matches
	for i = 1, 4 do
		if string.sub(guess, i, i) == string.sub(self.heistSecretCode, i, i) then
			results[i] = "green"
		end
	end

	-- Second: correct digit, wrong position
	for i = 1, 4 do
		if not results[i] then
			local guessChar = string.sub(guess, i, i)
			local found = false
			for j = 1, 4 do
				if not results[j] and string.sub(self.heistSecretCode, j, j) == guessChar then
					results[i] = "yellow"
					found = true
					break
				end
			end
			if not found then
				results[i] = "gray"
			end
		end
	end

	for i, data in ipairs(self.heistDigitLabels) do
		if results[i] == "green" then
			data.frame.BackgroundColor3 = C.Green
		elseif results[i] == "yellow" then
			data.frame.BackgroundColor3 = C.Amber
		else
			data.frame.BackgroundColor3 = C.Gray500
		end
	end

	local historyEntry = Instance.new("Frame")
	historyEntry.Size = UDim2.new(0, 60, 0, 50)
	historyEntry.BackgroundColor3 = C.Gray700
	historyEntry.ZIndex = 203
	historyEntry.Parent = self.heistHistory
	corner(historyEntry, 8)

	local historyLabel = Instance.new("TextLabel")
	historyLabel.Size = UDim2.fromScale(1, 1)
	historyLabel.BackgroundTransparency = 1
	historyLabel.Font = F.Button
	historyLabel.TextSize = 14
	historyLabel.TextColor3 = C.White
	historyLabel.Text = guess
	historyLabel.ZIndex = 204
	historyLabel.Parent = historyEntry

	if guess == self.heistSecretCode then
		self:endHeist(true)
		return
	end

	if self.heistAttemptsLeft <= 0 then
		self:endHeist(false)
		return
	end

	self.heistCurrentInput = ""
	task.delay(0.5, function()
		if self.activeGame ~= "heist" then return end
		for _, data in ipairs(self.heistDigitLabels) do
			data.label.Text = "_"
			data.frame.BackgroundColor3 = C.Gray700
		end
	end)
end

function Minigames:endHeist(won)
	self.activeGame = nil
	self.heistOverlay.Visible = false

	disconnectAll(self._heistNumConnections)
	self._heistNumConnections = {}

	if self.callback then
		self.callback(won, {
			secretCode = self.heistSecretCode,
			attempts = 6 - self.heistAttemptsLeft,
		})
		self.callback = nil
	end
end

----------------------------------------------------------------
-- GETAWAY MINIGAME (Criminal Path)
----------------------------------------------------------------

function Minigames:createGetawayGame()
	self.getawayOverlay = Instance.new("Frame")
	self.getawayOverlay.Size = UDim2.fromScale(1, 1)
	self.getawayOverlay.BackgroundColor3 = C.Black
	self.getawayOverlay.BackgroundTransparency = 0.2
	self.getawayOverlay.Visible = false
	self.getawayOverlay.ZIndex = 200
	self.getawayOverlay.Parent = self.screenGui

	self.getawayCard = Instance.new("Frame")
	-- CRITICAL FIX: Use percentage-based height that fits on mobile screens
	self.getawayCard.Size = UDim2.new(0.95, 0, 0.85, 0)  -- 85% of screen height
	self.getawayCard.AnchorPoint = Vector2.new(0.5, 0.5)
	self.getawayCard.Position = UDim2.fromScale(0.5, 0.5)
	-- VISUAL FIX: More car-chase themed dark gradient background
	self.getawayCard.BackgroundColor3 = Color3.fromRGB(15, 25, 40)
	self.getawayCard.ZIndex = 201
	self.getawayCard.ClipsDescendants = true  -- CRITICAL: Prevent content overflow
	self.getawayCard.Parent = self.getawayOverlay
	corner(self.getawayCard, 20)
	
	-- Add a subtle border glow effect
	local cardStroke = Instance.new("UIStroke")
	cardStroke.Color = Color3.fromRGB(255, 140, 0)  -- Orange glow
	cardStroke.Thickness = 2
	cardStroke.Transparency = 0.5
	cardStroke.Parent = self.getawayCard

	local getawayTitle = Instance.new("TextLabel")
	getawayTitle.Size = UDim2.new(1, 0, 0, 60)
	-- VISUAL FIX: More vibrant orange-red gradient for urgency
	getawayTitle.BackgroundColor3 = Color3.fromRGB(220, 80, 30)
	getawayTitle.Font = F.Title
	getawayTitle.TextSize = 26
	getawayTitle.TextColor3 = C.White
	getawayTitle.Text = "ğŸš—ğŸ’¨ GRAND THEFT AUTO!"
	getawayTitle.ZIndex = 202
	getawayTitle.Parent = self.getawayCard
	corner(getawayTitle, 20)

	local titleFix = Instance.new("Frame")
	titleFix.Size = UDim2.new(1, 0, 0, 30)
	titleFix.Position = UDim2.new(0, 0, 0, 35)
	titleFix.BackgroundColor3 = Color3.fromRGB(220, 80, 30)
	titleFix.ZIndex = 202
	titleFix.Parent = getawayTitle

	self.getawayInstructions = Instance.new("TextLabel")
	self.getawayInstructions.Size = UDim2.new(0.9, 0, 0, 45)
	self.getawayInstructions.AnchorPoint = Vector2.new(0.5, 0)
	self.getawayInstructions.Position = UDim2.new(0.5, 0, 0, 70)
	self.getawayInstructions.BackgroundTransparency = 1
	self.getawayInstructions.Font = F.Medium
	self.getawayInstructions.TextSize = 15
	self.getawayInstructions.TextColor3 = Color3.fromRGB(255, 200, 100)  -- Yellow-orange for visibility
	self.getawayInstructions.TextWrapped = true
	-- VISUAL FIX: Clearer, more exciting instructions
	self.getawayInstructions.Text = "ğŸ”µ Watch the pattern â†’ Repeat the directions â†’ Escape before cops catch you!"
	self.getawayInstructions.ZIndex = 202
	self.getawayInstructions.Parent = self.getawayCard

	self.getawayProgressBg = Instance.new("Frame")
	self.getawayProgressBg.Size = UDim2.new(0.85, 0, 0, 20)
	self.getawayProgressBg.AnchorPoint = Vector2.new(0.5, 0)
	self.getawayProgressBg.Position = UDim2.new(0.5, 0, 0, 115)
	self.getawayProgressBg.BackgroundColor3 = C.Gray700
	self.getawayProgressBg.ZIndex = 202
	self.getawayProgressBg.Parent = self.getawayCard
	pill(self.getawayProgressBg)

	self.getawayProgressFill = Instance.new("Frame")
	self.getawayProgressFill.Size = UDim2.new(0, 0, 1, 0)
	self.getawayProgressFill.BackgroundColor3 = C.Green
	self.getawayProgressFill.ZIndex = 203
	self.getawayProgressFill.Parent = self.getawayProgressBg
	pill(self.getawayProgressFill)

	self.copProgressFill = Instance.new("Frame")
	self.copProgressFill.Size = UDim2.new(0, 0, 1, 0)
	self.copProgressFill.AnchorPoint = Vector2.new(1, 0)
	self.copProgressFill.Position = UDim2.new(1, 0, 0, 0)
	self.copProgressFill.BackgroundColor3 = C.Red
	self.copProgressFill.ZIndex = 203
	self.copProgressFill.Parent = self.getawayProgressBg
	pill(self.copProgressFill)

	self.getawayGrid = Instance.new("Frame")
	self.getawayGrid.Size = UDim2.new(0.9, 0, 0, 260)
	self.getawayGrid.AnchorPoint = Vector2.new(0.5, 0)
	self.getawayGrid.Position = UDim2.new(0.5, 0, 0, 150)
	self.getawayGrid.BackgroundTransparency = 1
	self.getawayGrid.ZIndex = 202
	self.getawayGrid.Parent = self.getawayCard

	local gridLayout = Instance.new("UIGridLayout")
	gridLayout.CellSize = UDim2.new(0.3, 0, 0.3, 0)
	gridLayout.CellPadding = UDim2.new(0.025, 0, 0.04, 0)
	gridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	gridLayout.Parent = self.getawayGrid

	local directions = { "â†–", "â†‘", "â†—", "â†", "â¬¤", "â†’", "â†™", "â†“", "â†˜" }
	self.getawayBtns = {}
	for i, dir in ipairs(directions) do
		local btn = Instance.new("TextButton")
		btn.BackgroundColor3 = C.Gray600
		btn.Font = F.Title
		btn.TextSize = 36
		btn.TextColor3 = C.White
		btn.Text = dir
		btn.AutoButtonColor = false
		btn.LayoutOrder = i
		btn.ZIndex = 203
		btn.Parent = self.getawayGrid
		corner(btn, 16)
		self.getawayBtns[i] = btn
	end
end

function Minigames:startGetaway(callback)
	self.callback = callback
	self.getawayOverlay.Visible = true
	self.activeGame = "getaway"

	self.getawayProgress = 0
	self.copProgress = 0
	self.getawaySequence = {}
	self.currentSequenceIndex = 1
	self.getawayRound = 1

	self.getawayProgressFill.Size = UDim2.new(0, 0, 1, 0)
	self.copProgressFill.Size = UDim2.new(0, 0, 1, 0)

	disconnectAll(self._getawayButtonConnections)
	self._getawayButtonConnections = {}

	for i, btn in ipairs(self.getawayBtns) do
		self._getawayButtonConnections[i] = btn.MouseButton1Click:Connect(function()
			self:handleGetawayInput(i)
		end)
	end

	self:showNextGetawaySequence()
	self:startCopChase()
end

function Minigames:showNextGetawaySequence()
	local seqLength = 2 + self.getawayRound
	self.getawaySequence = {}
	for _ = 1, seqLength do
		table.insert(self.getawaySequence, math.random(1, 9))
	end
	self.currentSequenceIndex = 1

	for _, btn in ipairs(self.getawayBtns) do
		btn.BackgroundColor3 = C.Gray600
	end

	-- CRITICAL FIX: SLOWER arrow display timing so players can actually follow!
	-- Was 0.4s between arrows, 0.3s visible - way too fast!
	-- Now 0.7s between arrows, 0.55s visible - much easier to track
	local ARROW_INTERVAL = 0.7  -- Time between each arrow showing
	local ARROW_VISIBLE_TIME = 0.55  -- How long each arrow stays lit

	for i, btnIndex in ipairs(self.getawaySequence) do
		task.delay(i * ARROW_INTERVAL, function()
			if self.activeGame ~= "getaway" then return end
			local btn = self.getawayBtns[btnIndex]
			btn.BackgroundColor3 = C.Amber
			task.delay(ARROW_VISIBLE_TIME, function()
				if self.activeGame ~= "getaway" then return end
				btn.BackgroundColor3 = C.Gray600
			end)
		end)
	end

	task.delay((#self.getawaySequence + 1) * ARROW_INTERVAL, function()
		if self.activeGame ~= "getaway" then return end
		self:highlightCurrentTarget()
	end)
end

function Minigames:highlightCurrentTarget()
	if self.currentSequenceIndex > #self.getawaySequence then return end
	for _, btn in ipairs(self.getawayBtns) do
		btn.BackgroundColor3 = C.Gray600
	end
	local targetIndex = self.getawaySequence[self.currentSequenceIndex]
	self.getawayBtns[targetIndex].BackgroundColor3 = C.Blue
end

function Minigames:handleGetawayInput(btnIndex)
	if self.activeGame ~= "getaway" then return end
	if self.currentSequenceIndex > #self.getawaySequence then return end

	local targetIndex = self.getawaySequence[self.currentSequenceIndex]

	if btnIndex == targetIndex then
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX: Made getaway minigame EASIER and more visually rewarding
		-- User complaint: "it's a bit weird kinda but ensure its pretty easy too"
		-- - Increased progress per correct input from 0.1 to 0.15 (need ~7 to win vs 10)
		-- - Better visual feedback with brighter colors
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		self.getawayBtns[btnIndex].BackgroundColor3 = Color3.fromRGB(50, 205, 50) -- Bright green
		self.currentSequenceIndex += 1

		-- EASIER: More progress per correct input (0.15 = need ~7 to win instead of 10)
		self.getawayProgress = self.getawayProgress + 0.15
		tween(self.getawayProgressFill, TweenInfo.new(0.2), {
			Size = UDim2.new(math.min(1, self.getawayProgress), 0, 1, 0),
		})

		if self.getawayProgress >= 1 then
			self:endGetaway(true)
			return
		end

		if self.currentSequenceIndex > #self.getawaySequence then
			self.getawayRound += 1
			task.delay(0.5, function()
				if self.activeGame == "getaway" then
					self:showNextGetawaySequence()
				end
			end)
		else
			task.delay(0.2, function()
				if self.activeGame == "getaway" then
					self:highlightCurrentTarget()
				end
			end)
		end
	else
		-- EASIER: Reduced cop penalty from 0.15 to 0.10 (more forgiving mistakes)
		self.getawayBtns[btnIndex].BackgroundColor3 = Color3.fromRGB(255, 50, 50) -- Bright red
		self.copProgress = self.copProgress + 0.10
		tween(self.copProgressFill, TweenInfo.new(0.2), {
			Size = UDim2.new(math.min(1, self.copProgress), 0, 1, 0),
		})

		if self.copProgress >= 1 then
			self:endGetaway(false)
		end
	end
end

function Minigames:startCopChase()
	if self._getawayCopChaseThread then
		pcall(function() task.cancel(self._getawayCopChaseThread) end)
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Made cop chase SLOWER for easier gameplay
	-- User complaint: "ensure its pretty easy too"
	-- - Increased wait from 2s to 2.5s between cop progress ticks
	-- - Reduced cop progress from 0.05 to 0.04 per tick
	-- This gives players more time to complete sequences without pressure
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	self._getawayCopChaseThread = task.spawn(function()
		while self.activeGame == "getaway" do
			task.wait(2.5)  -- EASIER: Was 2s, now 2.5s
			if self.activeGame ~= "getaway" then break end

			self.copProgress = self.copProgress + 0.04  -- EASIER: Was 0.05, now 0.04
			tween(self.copProgressFill, TweenInfo.new(0.3), {
				Size = UDim2.new(math.min(1, self.copProgress), 0, 1, 0),
			})

			if self.copProgress >= 1 then
				self:endGetaway(false)
				break
			end
		end
	end)
end

function Minigames:endGetaway(escaped)
	self.activeGame = nil
	self.getawayOverlay.Visible = false

	disconnectAll(self._getawayButtonConnections)
	self._getawayButtonConnections = {}

	if self._getawayCopChaseThread then
		pcall(function() task.cancel(self._getawayCopChaseThread) end)
		self._getawayCopChaseThread = nil
	end

	if self.callback then
		self.callback(escaped, { progress = self.getawayProgress })
		self.callback = nil
	end
end

----------------------------------------------------------------
-- QUICK TIME EVENT (Universal)
----------------------------------------------------------------

function Minigames:createQuickTimeGame()
	self.qteOverlay = Instance.new("Frame")
	self.qteOverlay.Size = UDim2.fromScale(1, 1)
	self.qteOverlay.BackgroundColor3 = C.Black
	self.qteOverlay.BackgroundTransparency = 0.3
	self.qteOverlay.Visible = false
	self.qteOverlay.ZIndex = 200
	self.qteOverlay.Parent = self.screenGui

	-- CRITICAL UI FIX: Responsive card for mobile compatibility
	self.qteCard = Instance.new("Frame")
	self.qteCard.Size = UDim2.new(0.92, 0, 0.8, 0)  -- 80% of screen height
	self.qteCard.ClipsDescendants = true
	self.qteCard.AnchorPoint = Vector2.new(0.5, 0.5)
	self.qteCard.Position = UDim2.fromScale(0.5, 0.5)
	self.qteCard.BackgroundColor3 = C.Gray800
	self.qteCard.ZIndex = 201
	self.qteCard.Parent = self.qteOverlay
	corner(self.qteCard, 24)
	pad(self.qteCard, 16, 16, 16, 16)

	self.qteTitle = Instance.new("TextLabel")
	self.qteTitle.Size = UDim2.new(1, 0, 0, 50)
	self.qteTitle.BackgroundTransparency = 1
	self.qteTitle.Font = F.Title
	self.qteTitle.TextSize = 26
	self.qteTitle.TextColor3 = C.White
	self.qteTitle.Text = "âš¡ QUICK TIME EVENT"
	self.qteTitle.ZIndex = 202
	self.qteTitle.Parent = self.qteCard

	self.qteInstructions = Instance.new("TextLabel")
	self.qteInstructions.Size = UDim2.new(0.9, 0, 0, 50)
	self.qteInstructions.AnchorPoint = Vector2.new(0.5, 0)
	self.qteInstructions.Position = UDim2.new(0.5, 0, 0, 55)
	self.qteInstructions.BackgroundTransparency = 1
	self.qteInstructions.Font = F.Body
	self.qteInstructions.TextSize = 18
	self.qteInstructions.TextColor3 = C.Gray300
	self.qteInstructions.TextWrapped = true
	self.qteInstructions.Text = "TAP when the bar is in the green zone!"
	self.qteInstructions.ZIndex = 202
	self.qteInstructions.Parent = self.qteCard

	-- CRITICAL UI FIX: Larger bar for easier visibility
	self.qteBarBg = Instance.new("Frame")
	self.qteBarBg.Size = UDim2.new(0.9, 0, 0, 70)
	self.qteBarBg.AnchorPoint = Vector2.new(0.5, 0)
	self.qteBarBg.Position = UDim2.new(0.5, 0, 0, 120)
	self.qteBarBg.BackgroundColor3 = C.Gray600
	self.qteBarBg.ZIndex = 202
	self.qteBarBg.Parent = self.qteCard
	corner(self.qteBarBg, 14)

	self.qteGreenZone = Instance.new("Frame")
	self.qteGreenZone.Size = UDim2.new(0.2, 0, 1, 0)
	self.qteGreenZone.Position = UDim2.new(0.4, 0, 0, 0)
	self.qteGreenZone.BackgroundColor3 = C.Green
	self.qteGreenZone.BackgroundTransparency = 0.3
	self.qteGreenZone.ZIndex = 203
	self.qteGreenZone.Parent = self.qteBarBg
	corner(self.qteGreenZone, 10)

	self.qteIndicator = Instance.new("Frame")
	self.qteIndicator.Size = UDim2.new(0.04, 0, 1.2, 0)
	self.qteIndicator.AnchorPoint = Vector2.new(0.5, 0.5)
	self.qteIndicator.Position = UDim2.new(0, 0, 0.5, 0)
	self.qteIndicator.BackgroundColor3 = C.White
	self.qteIndicator.ZIndex = 204
	self.qteIndicator.Parent = self.qteBarBg
	corner(self.qteIndicator, 4)

	-- CRITICAL MOBILE FIX: Even larger tap button for easy mobile tapping!
	self.qteTapBtn = Instance.new("TextButton")
	-- MOBILE OPTIMIZATION: Button is 90% width for massive tap target
	self.qteTapBtn.Size = UDim2.new(0.9, 0, 0, 120)
	self.qteTapBtn.AnchorPoint = Vector2.new(0.5, 0)
	self.qteTapBtn.Position = UDim2.new(0.5, 0, 0, 200)
	self.qteTapBtn.BackgroundColor3 = C.Blue
	self.qteTapBtn.Font = F.Title
	self.qteTapBtn.TextSize = 36
	self.qteTapBtn.TextColor3 = C.White
	self.qteTapBtn.Text = "ğŸ¯ TAP NOW!"
	self.qteTapBtn.AutoButtonColor = false
	self.qteTapBtn.ZIndex = 202
	self.qteTapBtn.Parent = self.qteCard
	corner(self.qteTapBtn, 24)
	
	-- MOBILE OPTIMIZATION: Visual feedback on touch
	self.qteTapBtn.MouseButton1Down:Connect(function()
		self.qteTapBtn.BackgroundColor3 = Color3.fromRGB(0, 180, 0) -- Green on press
		self.qteTapBtn.Size = UDim2.new(0.88, 0, 0, 116) -- Slight shrink for feedback
	end)
	self.qteTapBtn.MouseButton1Up:Connect(function()
		self.qteTapBtn.BackgroundColor3 = C.Blue
		self.qteTapBtn.Size = UDim2.new(0.9, 0, 0, 120) -- Back to normal
	end)

	self.qteResult = Instance.new("TextLabel")
	self.qteResult.Size = UDim2.new(1, 0, 0, 50)
	self.qteResult.AnchorPoint = Vector2.new(0.5, 0)
	self.qteResult.Position = UDim2.new(0.5, 0, 0, 330)
	self.qteResult.BackgroundTransparency = 1
	self.qteResult.Font = F.Title
	self.qteResult.TextSize = 24
	self.qteResult.TextColor3 = C.White
	self.qteResult.Text = ""
	self.qteResult.ZIndex = 202
	self.qteResult.Parent = self.qteCard
end

function Minigames:startQTE(callback, difficulty)
	self.callback = callback
	self.qteOverlay.Visible = true
	self.activeGame = "qte"
	self.qteResult.Text = ""

	difficulty = difficulty or "medium"
	local greenZoneSize = (difficulty == "easy" and 0.3) or (difficulty == "hard" and 0.12) or 0.2
	local speed = (difficulty == "easy" and 1.5) or (difficulty == "hard" and 0.8) or 1.2

	self.qteGreenZone.Size = UDim2.new(greenZoneSize, 0, 1, 0)
	self.qteGreenZone.Position = UDim2.new(0.5 - greenZoneSize / 2, 0, 0, 0)

	self.qteIndicator.Position = UDim2.new(0, 0, 0.5, 0)
	self.qteAnimating = true
	self.qteDirection = 1

	task.spawn(function()
		while self.qteAnimating and self.activeGame == "qte" do
			local currentX = self.qteIndicator.Position.X.Scale
			local newX = currentX + (0.02 * self.qteDirection / speed)

			if newX >= 1 then
				newX = 1
				self.qteDirection = -1
			elseif newX <= 0 then
				newX = 0
				self.qteDirection = 1
			end

			self.qteIndicator.Position = UDim2.new(newX, 0, 0.5, 0)
			task.wait(0.016)
		end
	end)

	disconnect(self._qteTapConnection)
	self._qteTapConnection = self.qteTapBtn.MouseButton1Click:Connect(function()
		self:handleQTETap()
	end)
end

function Minigames:handleQTETap()
	if self.activeGame ~= "qte" then return end

	self.qteAnimating = false
	local indicatorX = self.qteIndicator.Position.X.Scale
	local greenStart = self.qteGreenZone.Position.X.Scale
	local greenEnd = greenStart + self.qteGreenZone.Size.X.Scale

	local success = indicatorX >= greenStart and indicatorX <= greenEnd

	if success then
		self.qteResult.Text = "âœ… PERFECT!"
		self.qteResult.TextColor3 = C.Green
		self.qteIndicator.BackgroundColor3 = C.Green
	else
		self.qteResult.Text = "âŒ MISSED!"
		self.qteResult.TextColor3 = C.Red
		self.qteIndicator.BackgroundColor3 = C.Red
	end

	task.delay(1, function()
		self:endQTE(success)
	end)
end

function Minigames:endQTE(success)
	self.activeGame = nil
	self.qteOverlay.Visible = false
	self.qteAnimating = false

	disconnect(self._qteTapConnection)
	self._qteTapConnection = nil

	if self.callback then
		self.callback(success, {})
		self.callback = nil
	end
end

----------------------------------------------------------------
-- PRISON ESCAPE MINIGAME
----------------------------------------------------------------

function Minigames:createPrisonEscapeGame()
	self.prisonOverlay = Instance.new("Frame")
	self.prisonOverlay.Size = UDim2.fromScale(1, 1)
	self.prisonOverlay.BackgroundColor3 = C.Black
	self.prisonOverlay.BackgroundTransparency = 0.2
	self.prisonOverlay.Visible = false
	self.prisonOverlay.ZIndex = 200
	self.prisonOverlay.Parent = self.screenGui

	self.prisonCard = Instance.new("Frame")
	-- CRITICAL FIX: Responsive height for mobile
	self.prisonCard.Size = UDim2.new(0.95, 0, 0.85, 0)
	self.prisonCard.ClipsDescendants = true
	self.prisonCard.AnchorPoint = Vector2.new(0.5, 0.5)
	self.prisonCard.Position = UDim2.fromScale(0.5, 0.5)
	self.prisonCard.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
	self.prisonCard.ZIndex = 201
	self.prisonCard.Parent = self.prisonOverlay
	corner(self.prisonCard, 20)

	local prisonTitle = Instance.new("TextLabel")
	prisonTitle.Size = UDim2.new(1, 0, 0, 60)
	prisonTitle.BackgroundColor3 = Color3.fromRGB(80, 80, 90)
	prisonTitle.Font = F.Title
	prisonTitle.TextSize = 24
	prisonTitle.TextColor3 = C.White
	prisonTitle.Text = "ğŸ” PRISON ESCAPE"
	prisonTitle.ZIndex = 202
	prisonTitle.Parent = self.prisonCard
	corner(prisonTitle, 20)

	local titleFix = Instance.new("Frame")
	titleFix.Size = UDim2.new(1, 0, 0, 30)
	titleFix.Position = UDim2.new(0, 0, 0, 35)
	titleFix.BackgroundColor3 = Color3.fromRGB(80, 80, 90)
	titleFix.ZIndex = 202
	titleFix.Parent = prisonTitle

	self.prisonInstructions = Instance.new("TextLabel")
	self.prisonInstructions.Size = UDim2.new(0.9, 0, 0, 40)
	self.prisonInstructions.AnchorPoint = Vector2.new(0.5, 0)
	self.prisonInstructions.Position = UDim2.new(0.5, 0, 0, 70)
	self.prisonInstructions.BackgroundTransparency = 1
	self.prisonInstructions.Font = F.Body
	self.prisonInstructions.TextSize = 14
	self.prisonInstructions.TextColor3 = C.Gray300
	self.prisonInstructions.TextWrapped = true
	self.prisonInstructions.Text = "Navigate through the maze! Follow the highlighted arrow directions."
	self.prisonInstructions.ZIndex = 202
	self.prisonInstructions.Parent = self.prisonCard

	-- Progress display
	self.prisonProgressBg = Instance.new("Frame")
	self.prisonProgressBg.Size = UDim2.new(0.85, 0, 0, 20)
	self.prisonProgressBg.AnchorPoint = Vector2.new(0.5, 0)
	self.prisonProgressBg.Position = UDim2.new(0.5, 0, 0, 115)
	self.prisonProgressBg.BackgroundColor3 = C.Gray700
	self.prisonProgressBg.ZIndex = 202
	self.prisonProgressBg.Parent = self.prisonCard
	pill(self.prisonProgressBg)

	self.prisonProgressFill = Instance.new("Frame")
	self.prisonProgressFill.Size = UDim2.new(0, 0, 1, 0)
	self.prisonProgressFill.BackgroundColor3 = C.Green
	self.prisonProgressFill.ZIndex = 203
	self.prisonProgressFill.Parent = self.prisonProgressBg
	pill(self.prisonProgressFill)

	-- Guard alert bar
	self.guardAlertBg = Instance.new("Frame")
	self.guardAlertBg.Size = UDim2.new(0.85, 0, 0, 12)
	self.guardAlertBg.AnchorPoint = Vector2.new(0.5, 0)
	self.guardAlertBg.Position = UDim2.new(0.5, 0, 0, 140)
	self.guardAlertBg.BackgroundColor3 = C.Gray700
	self.guardAlertBg.ZIndex = 202
	self.guardAlertBg.Parent = self.prisonCard
	pill(self.guardAlertBg)

	self.guardAlertFill = Instance.new("Frame")
	self.guardAlertFill.Size = UDim2.new(0, 0, 1, 0)
	self.guardAlertFill.BackgroundColor3 = C.Red
	self.guardAlertFill.ZIndex = 203
	self.guardAlertFill.Parent = self.guardAlertBg
	pill(self.guardAlertFill)

	local guardLabel = Instance.new("TextLabel")
	guardLabel.Size = UDim2.new(0, 100, 0, 12)
	guardLabel.Position = UDim2.new(0, 0, 0, -14)
	guardLabel.BackgroundTransparency = 1
	guardLabel.Font = F.Medium
	guardLabel.TextSize = 10
	guardLabel.TextColor3 = C.Red
	guardLabel.TextXAlignment = Enum.TextXAlignment.Left
	guardLabel.Text = "âš ï¸ GUARD ALERT"
	guardLabel.ZIndex = 203
	guardLabel.Parent = self.guardAlertBg

	-- Arrow grid
	self.prisonGrid = Instance.new("Frame")
	self.prisonGrid.Size = UDim2.new(0.9, 0, 0, 260)
	self.prisonGrid.AnchorPoint = Vector2.new(0.5, 0)
	self.prisonGrid.Position = UDim2.new(0.5, 0, 0, 165)
	self.prisonGrid.BackgroundTransparency = 1
	self.prisonGrid.ZIndex = 202
	self.prisonGrid.Parent = self.prisonCard

	local gridLayout = Instance.new("UIGridLayout")
	gridLayout.CellSize = UDim2.new(0.3, 0, 0.3, 0)
	gridLayout.CellPadding = UDim2.new(0.025, 0, 0.04, 0)
	gridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	gridLayout.Parent = self.prisonGrid

	local arrows = { "â†–", "â†‘", "â†—", "â†", "ğŸšª", "â†’", "â†™", "â†“", "â†˜" }
	self.prisonArrowBtns = {}
	for i, arrow in ipairs(arrows) do
		local btn = Instance.new("TextButton")
		btn.BackgroundColor3 = C.Gray600
		btn.Font = F.Title
		btn.TextSize = 36
		btn.TextColor3 = C.White
		btn.Text = arrow
		btn.AutoButtonColor = false
		btn.LayoutOrder = i
		btn.ZIndex = 203
		btn.Parent = self.prisonGrid
		corner(btn, 16)
		self.prisonArrowBtns[i] = btn
	end
end

function Minigames:startPrisonEscape(callback)
	self.callback = callback
	self.prisonOverlay.Visible = true
	self.activeGame = "prison_escape"

	self.prisonProgress = 0
	self.guardAlert = 0
	self.prisonSequence = {}
	self.currentPrisonStep = 1

	self.prisonProgressFill.Size = UDim2.new(0, 0, 1, 0)
	self.guardAlertFill.Size = UDim2.new(0, 0, 1, 0)

	-- Generate escape sequence (avoid center door at index 5)
	local validArrows = {1, 2, 3, 4, 6, 7, 8, 9}
	for _ = 1, 8 do
		table.insert(self.prisonSequence, validArrows[math.random(1, #validArrows)])
	end

	disconnectAll(self._prisonArrowConnections)
	self._prisonArrowConnections = {}

	for i, btn in ipairs(self.prisonArrowBtns) do
		self._prisonArrowConnections[i] = btn.MouseButton1Click:Connect(function()
			self:handlePrisonInput(i)
		end)
	end

	self:highlightPrisonTarget()
	self:startGuardPatrol()
end

function Minigames:highlightPrisonTarget()
	if self.currentPrisonStep > #self.prisonSequence then return end

	for _, btn in ipairs(self.prisonArrowBtns) do
		btn.BackgroundColor3 = C.Gray600
	end

	local targetIndex = self.prisonSequence[self.currentPrisonStep]
	self.prisonArrowBtns[targetIndex].BackgroundColor3 = C.Amber
end

function Minigames:handlePrisonInput(btnIndex)
	if self.activeGame ~= "prison_escape" then return end
	if self.currentPrisonStep > #self.prisonSequence then return end

	local targetIndex = self.prisonSequence[self.currentPrisonStep]

	if btnIndex == targetIndex then
		self.prisonArrowBtns[btnIndex].BackgroundColor3 = C.Green
		self.currentPrisonStep += 1
		self.prisonProgress = self.prisonProgress + (1 / #self.prisonSequence)

		tween(self.prisonProgressFill, TweenInfo.new(0.2), {
			Size = UDim2.new(math.min(1, self.prisonProgress), 0, 1, 0),
		})

		if self.prisonProgress >= 1 then
			self:endPrisonEscape(true)
			return
		end

		task.delay(0.2, function()
			if self.activeGame == "prison_escape" then
				self:highlightPrisonTarget()
			end
		end)
	else
		self.prisonArrowBtns[btnIndex].BackgroundColor3 = C.Red
		self.guardAlert = self.guardAlert + 0.2

		tween(self.guardAlertFill, TweenInfo.new(0.2), {
			Size = UDim2.new(math.min(1, self.guardAlert), 0, 1, 0),
		})

		if self.guardAlert >= 1 then
			self:endPrisonEscape(false)
		end
	end
end

function Minigames:startGuardPatrol()
	if self._prisonGuardThread then
		pcall(function() task.cancel(self._prisonGuardThread) end)
	end

	self._prisonGuardThread = task.spawn(function()
		while self.activeGame == "prison_escape" do
			task.wait(3)
			if self.activeGame ~= "prison_escape" then break end

			self.guardAlert = self.guardAlert + 0.08
			tween(self.guardAlertFill, TweenInfo.new(0.3), {
				Size = UDim2.new(math.min(1, self.guardAlert), 0, 1, 0),
			})

			if self.guardAlert >= 1 then
				self:endPrisonEscape(false)
				break
			end
		end
	end)
end

function Minigames:endPrisonEscape(escaped)
	self.activeGame = nil
	self.prisonOverlay.Visible = false

	disconnectAll(self._prisonArrowConnections)
	self._prisonArrowConnections = {}

	if self._prisonGuardThread then
		pcall(function() task.cancel(self._prisonGuardThread) end)
		self._prisonGuardThread = nil
	end

	if self.callback then
		self.callback(escaped, { progress = self.prisonProgress })
		self.callback = nil
	end
end

----------------------------------------------------------------
-- MASH MINIGAME (Button Mashing)
----------------------------------------------------------------

function Minigames:createMashGame()
	self.mashOverlay = Instance.new("Frame")
	self.mashOverlay.Size = UDim2.fromScale(1, 1)
	self.mashOverlay.BackgroundColor3 = C.Black
	self.mashOverlay.BackgroundTransparency = 0.3
	self.mashOverlay.Visible = false
	self.mashOverlay.ZIndex = 200
	self.mashOverlay.Parent = self.screenGui

	self.mashCard = Instance.new("Frame")
	-- CRITICAL FIX: Responsive height for mobile
	self.mashCard.Size = UDim2.new(0.9, 0, 0.75, 0)
	self.mashCard.ClipsDescendants = true
	self.mashCard.AnchorPoint = Vector2.new(0.5, 0.5)
	self.mashCard.Position = UDim2.fromScale(0.5, 0.5)
	self.mashCard.BackgroundColor3 = C.Gray800
	self.mashCard.ZIndex = 201
	self.mashCard.Parent = self.mashOverlay
	corner(self.mashCard, 24)

	self.mashTitle = Instance.new("TextLabel")
	self.mashTitle.Size = UDim2.new(1, 0, 0, 60)
	self.mashTitle.BackgroundTransparency = 1
	self.mashTitle.Font = F.Title
	self.mashTitle.TextSize = 24
	self.mashTitle.TextColor3 = C.White
	self.mashTitle.Text = "ğŸ‘† TAP FAST!"
	self.mashTitle.ZIndex = 202
	self.mashTitle.Parent = self.mashCard

	self.mashInstructions = Instance.new("TextLabel")
	self.mashInstructions.Size = UDim2.new(0.9, 0, 0, 30)
	self.mashInstructions.AnchorPoint = Vector2.new(0.5, 0)
	self.mashInstructions.Position = UDim2.new(0.5, 0, 0, 55)
	self.mashInstructions.BackgroundTransparency = 1
	self.mashInstructions.Font = F.Body
	self.mashInstructions.TextSize = 14
	self.mashInstructions.TextColor3 = C.Gray400
	self.mashInstructions.Text = "Tap the button as fast as you can!"
	self.mashInstructions.ZIndex = 202
	self.mashInstructions.Parent = self.mashCard

	-- Progress bar
	self.mashProgressBg = Instance.new("Frame")
	self.mashProgressBg.Size = UDim2.new(0.85, 0, 0, 24)
	self.mashProgressBg.AnchorPoint = Vector2.new(0.5, 0)
	self.mashProgressBg.Position = UDim2.new(0.5, 0, 0, 95)
	self.mashProgressBg.BackgroundColor3 = C.Gray700
	self.mashProgressBg.ZIndex = 202
	self.mashProgressBg.Parent = self.mashCard
	pill(self.mashProgressBg)

	self.mashProgressFill = Instance.new("Frame")
	self.mashProgressFill.Size = UDim2.new(0, 0, 1, 0)
	self.mashProgressFill.BackgroundColor3 = C.Green
	self.mashProgressFill.ZIndex = 203
	self.mashProgressFill.Parent = self.mashProgressBg
	pill(self.mashProgressFill)

	-- Timer display
	self.mashTimer = Instance.new("TextLabel")
	self.mashTimer.Size = UDim2.new(0.9, 0, 0, 40)
	self.mashTimer.AnchorPoint = Vector2.new(0.5, 0)
	self.mashTimer.Position = UDim2.new(0.5, 0, 0, 130)
	self.mashTimer.BackgroundTransparency = 1
	self.mashTimer.Font = F.Title
	self.mashTimer.TextSize = 32
	self.mashTimer.TextColor3 = C.Amber
	self.mashTimer.Text = "5.0s"
	self.mashTimer.ZIndex = 202
	self.mashTimer.Parent = self.mashCard

	-- Tap count
	self.mashCount = Instance.new("TextLabel")
	self.mashCount.Size = UDim2.new(0.9, 0, 0, 30)
	self.mashCount.AnchorPoint = Vector2.new(0.5, 0)
	self.mashCount.Position = UDim2.new(0.5, 0, 0, 170)
	self.mashCount.BackgroundTransparency = 1
	self.mashCount.Font = F.Medium
	self.mashCount.TextSize = 16
	self.mashCount.TextColor3 = C.Gray400
	self.mashCount.Text = "Taps: 0"
	self.mashCount.ZIndex = 202
	self.mashCount.Parent = self.mashCard

	-- Big tap button - CRITICAL MOBILE FIX: Made MUCH larger for easy tapping!
	self.mashButton = Instance.new("TextButton")
	-- MOBILE OPTIMIZATION: Button is now 70% of card width for bigger tap target
	self.mashButton.Size = UDim2.new(0.7, 0, 0, 140)
	self.mashButton.AnchorPoint = Vector2.new(0.5, 0)
	self.mashButton.Position = UDim2.new(0.5, 0, 0, 200)
	self.mashButton.BackgroundColor3 = C.Blue
	self.mashButton.Font = F.Title
	self.mashButton.TextSize = 42
	self.mashButton.TextColor3 = C.White
	self.mashButton.Text = "ğŸ‘† TAP!"
	self.mashButton.AutoButtonColor = false
	self.mashButton.ZIndex = 203
	self.mashButton.Parent = self.mashCard
	corner(self.mashButton, 24)  -- MOBILE FIX: Rounded rectangle instead of circle for bigger tap zone
	
	-- MOBILE OPTIMIZATION: Add visual feedback on tap
	self.mashButton.MouseButton1Down:Connect(function()
		self.mashButton.BackgroundColor3 = C.Green
	end)
	self.mashButton.MouseButton1Up:Connect(function()
		self.mashButton.BackgroundColor3 = C.Blue
	end)
end

function Minigames:startMash(callback, options)
	options = options or {}
	self.callback = callback
	self.mashOverlay.Visible = true
	self.activeGame = "mash"

	self.mashTaps = 0
	self.mashTimeLeft = options.duration or 5
	self.mashTarget = options.target or 30
	self.mashProgress = 0

	self.mashProgressFill.Size = UDim2.new(0, 0, 1, 0)
	self.mashTimer.Text = string.format("%.1fs", self.mashTimeLeft)
	self.mashCount.Text = "Taps: 0 / " .. self.mashTarget

	disconnect(self._mashConnection)
	self._mashConnection = self.mashButton.MouseButton1Click:Connect(function()
		self:handleMashTap()
	end)

	self:startMashTimer()
end

function Minigames:handleMashTap()
	if self.activeGame ~= "mash" then return end

	self.mashTaps += 1
	self.mashProgress = math.min(1, self.mashTaps / self.mashTarget)

	self.mashCount.Text = "Taps: " .. self.mashTaps .. " / " .. self.mashTarget

	tween(self.mashProgressFill, TweenInfo.new(0.1), {
		Size = UDim2.new(self.mashProgress, 0, 1, 0),
	})

	-- Button pulse effect
	tween(self.mashButton, TweenInfo.new(0.05), {
		Size = UDim2.new(0, 170, 0, 170),
	})
	task.delay(0.05, function()
		if self.mashButton then
			tween(self.mashButton, TweenInfo.new(0.05), {
				Size = UDim2.new(0, 180, 0, 180),
			})
		end
	end)

	if self.mashTaps >= self.mashTarget then
		self:endMash(true)
	end
end

function Minigames:startMashTimer()
	-- CRITICAL FIX: Wrap task.cancel in pcall to prevent "cannot cancel thread" error
	-- This error occurs when trying to cancel an already-completed thread
	if self._mashTimerThread then
		pcall(function() task.cancel(self._mashTimerThread) end)
		self._mashTimerThread = nil
	end

	self._mashTimerThread = task.spawn(function()
		while self.activeGame == "mash" and self.mashTimeLeft > 0 do
			task.wait(0.1)
			if self.activeGame ~= "mash" then break end

			self.mashTimeLeft = self.mashTimeLeft - 0.1
			self.mashTimer.Text = string.format("%.1fs", math.max(0, self.mashTimeLeft))

			if self.mashTimeLeft <= 2 then
				self.mashTimer.TextColor3 = C.Red
			end
		end

		if self.activeGame == "mash" and self.mashTimeLeft <= 0 then
			self:endMash(self.mashTaps >= self.mashTarget)
		end
	end)
end

function Minigames:endMash(success)
	self.activeGame = nil
	self.mashOverlay.Visible = false
	self.mashTimer.TextColor3 = C.Amber

	disconnect(self._mashConnection)
	self._mashConnection = nil

	-- CRITICAL FIX: Wrap task.cancel in pcall to prevent "cannot cancel thread" error
	if self._mashTimerThread then
		pcall(function() task.cancel(self._mashTimerThread) end)
		self._mashTimerThread = nil
	end

	if self.callback then
		self.callback(success, { taps = self.mashTaps, target = self.mashTarget })
		self.callback = nil
	end
end

----------------------------------------------------------------
-- HACKING MINIGAME
----------------------------------------------------------------

function Minigames:createHackingGame()
	self.hackOverlay = Instance.new("Frame")
	self.hackOverlay.Size = UDim2.fromScale(1, 1)
	self.hackOverlay.BackgroundColor3 = C.Black
	self.hackOverlay.BackgroundTransparency = 0.2
	self.hackOverlay.Visible = false
	self.hackOverlay.ZIndex = 200
	self.hackOverlay.Parent = self.screenGui

	self.hackCard = Instance.new("Frame")
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Mobile-responsive System Breach UI
	-- User complaint: "bunched up" and doesn't work on mobile
	-- Solution: Use percentage-based positioning for all elements
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	self.hackCard.Size = UDim2.new(0.95, 0, 0.88, 0)  -- Slightly taller for better fit
	self.hackCard.ClipsDescendants = true
	self.hackCard.AnchorPoint = Vector2.new(0.5, 0.5)
	self.hackCard.Position = UDim2.fromScale(0.5, 0.5)
	self.hackCard.BackgroundColor3 = Color3.fromRGB(10, 20, 15)
	self.hackCard.ZIndex = 201
	self.hackCard.Parent = self.hackOverlay
	corner(self.hackCard, 16)
	
	-- Matrix-style border glow
	local hackStroke = Instance.new("UIStroke")
	hackStroke.Color = Color3.fromRGB(0, 255, 100)
	hackStroke.Thickness = 2
	hackStroke.Transparency = 0.6
	hackStroke.Parent = self.hackCard

	-- Title - 10% of card height
	local hackTitle = Instance.new("TextLabel")
	hackTitle.Size = UDim2.new(1, 0, 0.10, 0)
	hackTitle.BackgroundColor3 = Color3.fromRGB(0, 70, 50)
	hackTitle.Font = F.Title
	hackTitle.TextSize = 22
	hackTitle.TextColor3 = Color3.fromRGB(0, 255, 100)
	hackTitle.Text = "ğŸ’» SYSTEM BREACH"
	hackTitle.ZIndex = 202
	hackTitle.Parent = self.hackCard
	corner(hackTitle, 16)

	-- Instructions - 7% of card height
	self.hackInstructions = Instance.new("TextLabel")
	self.hackInstructions.Size = UDim2.new(0.92, 0, 0.07, 0)
	self.hackInstructions.AnchorPoint = Vector2.new(0.5, 0)
	self.hackInstructions.Position = UDim2.new(0.5, 0, 0.11, 0)
	self.hackInstructions.BackgroundTransparency = 1
	self.hackInstructions.Font = F.Body
	self.hackInstructions.TextSize = 13
	self.hackInstructions.TextColor3 = Color3.fromRGB(150, 255, 180)
	self.hackInstructions.TextWrapped = true
	self.hackInstructions.Text = "Match the security codes to breach the system!"
	self.hackInstructions.ZIndex = 202
	self.hackInstructions.Parent = self.hackCard

	-- Timer bar - 3% of card height
	self.hackTimerBg = Instance.new("Frame")
	self.hackTimerBg.Size = UDim2.new(0.9, 0, 0.025, 0)
	self.hackTimerBg.AnchorPoint = Vector2.new(0.5, 0)
	self.hackTimerBg.Position = UDim2.new(0.5, 0, 0.19, 0)
	self.hackTimerBg.BackgroundColor3 = C.Gray700
	self.hackTimerBg.ZIndex = 202
	self.hackTimerBg.Parent = self.hackCard
	pill(self.hackTimerBg)

	self.hackTimerFill = Instance.new("Frame")
	self.hackTimerFill.Size = UDim2.new(1, 0, 1, 0)
	self.hackTimerFill.BackgroundColor3 = Color3.fromRGB(0, 255, 100)
	self.hackTimerFill.ZIndex = 203
	self.hackTimerFill.Parent = self.hackTimerBg
	pill(self.hackTimerFill)

	-- Code display (what to type) - 9% of card height
	self.hackCodeDisplay = Instance.new("TextLabel")
	self.hackCodeDisplay.Size = UDim2.new(0.85, 0, 0.09, 0)
	self.hackCodeDisplay.AnchorPoint = Vector2.new(0.5, 0)
	self.hackCodeDisplay.Position = UDim2.new(0.5, 0, 0.23, 0)
	self.hackCodeDisplay.BackgroundColor3 = Color3.fromRGB(0, 35, 25)
	self.hackCodeDisplay.Font = Enum.Font.Code
	self.hackCodeDisplay.TextSize = 26
	self.hackCodeDisplay.TextColor3 = Color3.fromRGB(0, 255, 100)
	self.hackCodeDisplay.Text = "####"
	self.hackCodeDisplay.ZIndex = 202
	self.hackCodeDisplay.Parent = self.hackCard
	corner(self.hackCodeDisplay, 10)

	-- User input display - 9% of card height
	self.hackInputDisplay = Instance.new("TextLabel")
	self.hackInputDisplay.Size = UDim2.new(0.85, 0, 0.09, 0)
	self.hackInputDisplay.AnchorPoint = Vector2.new(0.5, 0)
	self.hackInputDisplay.Position = UDim2.new(0.5, 0, 0.335, 0)
	self.hackInputDisplay.BackgroundColor3 = Color3.fromRGB(25, 30, 35)
	self.hackInputDisplay.Font = Enum.Font.Code
	self.hackInputDisplay.TextSize = 26
	self.hackInputDisplay.TextColor3 = C.Amber
	self.hackInputDisplay.Text = "____"
	self.hackInputDisplay.ZIndex = 202
	self.hackInputDisplay.Parent = self.hackCard
	corner(self.hackInputDisplay, 10)

	-- Progress - 5% of card height
	self.hackProgressLabel = Instance.new("TextLabel")
	self.hackProgressLabel.Size = UDim2.new(0.9, 0, 0.05, 0)
	self.hackProgressLabel.AnchorPoint = Vector2.new(0.5, 0)
	self.hackProgressLabel.Position = UDim2.new(0.5, 0, 0.44, 0)
	self.hackProgressLabel.BackgroundTransparency = 1
	self.hackProgressLabel.Font = F.Medium
	self.hackProgressLabel.TextSize = 13
	self.hackProgressLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
	self.hackProgressLabel.Text = "Codes: 0/5"
	self.hackProgressLabel.ZIndex = 202
	self.hackProgressLabel.Parent = self.hackCard

	-- Keypad - 45% of card height (large for easy mobile tapping)
	self.hackKeypad = Instance.new("Frame")
	self.hackKeypad.Size = UDim2.new(0.9, 0, 0.45, 0)
	self.hackKeypad.AnchorPoint = Vector2.new(0.5, 0)
	self.hackKeypad.Position = UDim2.new(0.5, 0, 0.50, 0)
	self.hackKeypad.BackgroundTransparency = 1
	self.hackKeypad.ZIndex = 202
	self.hackKeypad.Parent = self.hackCard

	local keypadLayout = Instance.new("UIGridLayout")
	keypadLayout.CellSize = UDim2.new(0.30, -4, 0.22, -4)  -- Responsive cells with slight padding
	keypadLayout.CellPadding = UDim2.new(0.025, 0, 0.03, 0)
	keypadLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	keypadLayout.Parent = self.hackKeypad

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Mobile-optimized keypad buttons
	-- Larger text, better contrast, responsive sizing
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local keyOrder = { "1", "2", "3", "4", "5", "6", "7", "8", "9", "âŒ«", "0", "âœ“" }
	self.hackKeyBtns = {}
	for i, key in ipairs(keyOrder) do
		local btn = Instance.new("TextButton")
		-- More vibrant colors for visibility
		if key == "âœ“" then
			btn.BackgroundColor3 = Color3.fromRGB(40, 180, 80)  -- Bright green
		elseif key == "âŒ«" then
			btn.BackgroundColor3 = Color3.fromRGB(200, 60, 60)  -- Bright red
		else
			btn.BackgroundColor3 = Color3.fromRGB(0, 80, 60)  -- Matrix green
		end
		btn.Font = F.Title
		btn.TextSize = 28  -- Larger text for mobile
		btn.TextColor3 = C.White
		btn.Text = key
		btn.AutoButtonColor = false
		btn.LayoutOrder = i
		btn.ZIndex = 203
		btn.Parent = self.hackKeypad
		corner(btn, 10)
		
		-- Add subtle border for better visibility
		local btnStroke = Instance.new("UIStroke")
		btnStroke.Color = Color3.fromRGB(0, 200, 120)
		btnStroke.Thickness = 1
		btnStroke.Transparency = 0.7
		btnStroke.Parent = btn

		self.hackKeyBtns[key] = btn
	end
end

function Minigames:startHacking(callback, options)
	options = options or {}
	self.callback = callback
	self.hackOverlay.Visible = true
	self.activeGame = "hacking"

	self.hackCodesCompleted = 0
	self.hackCodesRequired = options.codes or 5
	self.hackCurrentCode = ""
	self.hackTargetCode = ""
	self.hackTimeLimit = options.time or 30
	self.hackInput = ""

	self:generateHackCode()
	self.hackProgressLabel.Text = "Codes: 0/" .. self.hackCodesRequired

	disconnectAll(self._hackKeyConnections)
	self._hackKeyConnections = {}

	for key, btn in pairs(self.hackKeyBtns) do
		self._hackKeyConnections[key] = btn.MouseButton1Click:Connect(function()
			self:handleHackInput(key)
		end)
	end

	self:startHackTimer()
end

function Minigames:generateHackCode()
	self.hackTargetCode = ""
	for _ = 1, 4 do
		self.hackTargetCode ..= tostring(math.random(0, 9))
	end
	self.hackInput = ""
	self.hackCodeDisplay.Text = self.hackTargetCode
	self.hackInputDisplay.Text = "____"
	self.hackInputDisplay.TextColor3 = C.Amber
end

function Minigames:handleHackInput(key)
	if self.activeGame ~= "hacking" then return end

	if key == "âŒ«" then
		if #self.hackInput > 0 then
			self.hackInput = string.sub(self.hackInput, 1, -2)
		end
	elseif key == "âœ“" then
		if #self.hackInput == 4 then
			self:submitHackCode()
		end
	else
		if #self.hackInput < 4 then
			self.hackInput ..= key
		end
	end

	-- Update display
	local display = ""
	for i = 1, 4 do
		local char = string.sub(self.hackInput, i, i)
		display ..= (char ~= "" and char or "_")
	end
	self.hackInputDisplay.Text = display
end

function Minigames:submitHackCode()
	if self.hackInput == self.hackTargetCode then
		self.hackCodesCompleted += 1
		self.hackProgressLabel.Text = "Codes: " .. self.hackCodesCompleted .. "/" .. self.hackCodesRequired
		self.hackInputDisplay.TextColor3 = C.Green

		if self.hackCodesCompleted >= self.hackCodesRequired then
			self:endHacking(true)
			return
		end

		task.delay(0.3, function()
			if self.activeGame == "hacking" then
				self:generateHackCode()
			end
		end)
	else
		self.hackInputDisplay.TextColor3 = C.Red
		task.delay(0.3, function()
			if self.activeGame == "hacking" then
				self.hackInput = ""
				self.hackInputDisplay.Text = "____"
				self.hackInputDisplay.TextColor3 = C.Amber
			end
		end)
	end
end

function Minigames:startHackTimer()
	self.hackTimerFill.Size = UDim2.new(1, 0, 1, 0)

	tween(self.hackTimerFill, TweenInfo.new(self.hackTimeLimit, Enum.EasingStyle.Linear), {
		Size = UDim2.new(0, 0, 1, 0),
	})

	if self._hackTimerConnection then
		pcall(function() task.cancel(self._hackTimerConnection) end)
	end

	self._hackTimerConnection = task.delay(self.hackTimeLimit, function()
		if self.activeGame == "hacking" then
			self:endHacking(false)
		end
	end)
end

function Minigames:endHacking(success)
	self.activeGame = nil
	self.hackOverlay.Visible = false

	disconnectAll(self._hackKeyConnections)
	self._hackKeyConnections = {}

	if self._hackTimerConnection then
		pcall(function() task.cancel(self._hackTimerConnection) end)
		self._hackTimerConnection = nil
	end

	if self.callback then
		self.callback(success, { codesCompleted = self.hackCodesCompleted, codesRequired = self.hackCodesRequired })
		self.callback = nil
	end
end

----------------------------------------------------------------
-- PURGE MINIGAME (Rare Survival Event)
----------------------------------------------------------------

function Minigames:createPurgeGame()
	-- Overlay
	self.purgeOverlay = Instance.new("Frame")
	self.purgeOverlay.Size = UDim2.fromScale(1, 1)
	self.purgeOverlay.BackgroundColor3 = C.Black
	self.purgeOverlay.BackgroundTransparency = 0.15
	self.purgeOverlay.Visible = false
	self.purgeOverlay.ZIndex = 210
	self.purgeOverlay.Parent = self.screenGui

	-- INTRO CARD
	self.purgeIntroCard = Instance.new("Frame")
	self.purgeIntroCard.Size = UDim2.new(0.94, 0, 0.8, 0)
	self.purgeIntroCard.AnchorPoint = Vector2.new(0.5, 0.5)
	self.purgeIntroCard.Position = UDim2.fromScale(0.5, 0.5)
	self.purgeIntroCard.BackgroundColor3 = Color3.fromRGB(10, 10, 12)
	self.purgeIntroCard.ZIndex = 211
	self.purgeIntroCard.Parent = self.purgeOverlay
	corner(self.purgeIntroCard, 22)
	stroke(self.purgeIntroCard, 2, 0, C.Red)

	local introHeader = Instance.new("TextLabel")
	introHeader.Size = UDim2.new(1, 0, 0, 60)
	introHeader.BackgroundTransparency = 1
	introHeader.Font = F.Title
	introHeader.TextSize = 28
	introHeader.TextColor3 = C.Red
	introHeader.Text = "ğŸ˜ˆ The Purge"
	introHeader.ZIndex = 212
	introHeader.TextXAlignment = Enum.TextXAlignment.Center
	introHeader.Parent = self.purgeIntroCard

	-- Body text (typewriter)
	self.purgeIntroBody = Instance.new("TextLabel")
	self.purgeIntroBody.Size = UDim2.new(0.9, 0, 0.5, 0)
	self.purgeIntroBody.AnchorPoint = Vector2.new(0.5, 0)
	self.purgeIntroBody.Position = UDim2.new(0.5, 0, 0, 90)
	self.purgeIntroBody.BackgroundTransparency = 1
	self.purgeIntroBody.Font = F.Medium
	self.purgeIntroBody.TextSize = 18
	self.purgeIntroBody.TextColor3 = C.Red
	self.purgeIntroBody.TextWrapped = true
	self.purgeIntroBody.Text = ""
	self.purgeIntroBody.ZIndex = 212
	self.purgeIntroBody.Parent = self.purgeIntroCard

	-- Begin button
	self.purgeBeginBtn = Instance.new("TextButton")
	self.purgeBeginBtn.Size = UDim2.new(0.9, 0, 0, 64)
	self.purgeBeginBtn.AnchorPoint = Vector2.new(0.5, 0)
	self.purgeBeginBtn.Position = UDim2.new(0.5, 0, 0.75, 0)
	self.purgeBeginBtn.BackgroundColor3 = C.Red
	self.purgeBeginBtn.Font = F.Button
	self.purgeBeginBtn.TextSize = 22
	self.purgeBeginBtn.TextColor3 = C.White
	self.purgeBeginBtn.Text = "ğŸš¨ BEGIN APOCALYPSE ğŸš¨"
	self.purgeBeginBtn.AutoButtonColor = false
	self.purgeBeginBtn.ZIndex = 212
	self.purgeBeginBtn.Parent = self.purgeIntroCard
	corner(self.purgeBeginBtn, 16)

	-- GAME CARD
	self.purgeGameCard = Instance.new("Frame")
	self.purgeGameCard.Size = UDim2.new(0.94, 0, 0.85, 0)
	self.purgeGameCard.AnchorPoint = Vector2.new(0.5, 0.5)
	self.purgeGameCard.Position = UDim2.fromScale(0.5, 0.5)
	self.purgeGameCard.BackgroundColor3 = Color3.fromRGB(12, 12, 16)
	self.purgeGameCard.Visible = false
	self.purgeGameCard.ZIndex = 211
	self.purgeGameCard.Parent = self.purgeOverlay
	corner(self.purgeGameCard, 22)
	stroke(self.purgeGameCard, 2, 0, C.Red)

	-- Title row
	local gameTitle = Instance.new("TextLabel")
	gameTitle.Size = UDim2.new(1, 0, 0, 50)
	gameTitle.BackgroundTransparency = 1
	gameTitle.Font = F.Title
	gameTitle.TextSize = 24
	gameTitle.TextColor3 = C.Red
	gameTitle.Text = "ğŸ˜ˆ The Purge"
	gameTitle.ZIndex = 212
	gameTitle.TextXAlignment = Enum.TextXAlignment.Center
	gameTitle.Parent = self.purgeGameCard

	-- HP label
	self.purgeHpLabel = Instance.new("TextLabel")
	self.purgeHpLabel.Size = UDim2.new(0.9, 0, 0, 22)
	self.purgeHpLabel.AnchorPoint = Vector2.new(0.5, 0)
	self.purgeHpLabel.Position = UDim2.new(0.5, 0, 0, 58)
	self.purgeHpLabel.BackgroundTransparency = 1
	self.purgeHpLabel.Font = F.Button
	self.purgeHpLabel.TextSize = 16
	self.purgeHpLabel.TextColor3 = C.White
	self.purgeHpLabel.TextXAlignment = Enum.TextXAlignment.Left
	self.purgeHpLabel.Text = "â¤ï¸ HP: 100 / 100"
	self.purgeHpLabel.ZIndex = 212
	self.purgeHpLabel.Parent = self.purgeGameCard

	-- HP bar bg
	self.purgeHpBg = Instance.new("Frame")
	self.purgeHpBg.Size = UDim2.new(0.9, 0, 0, 18)
	self.purgeHpBg.AnchorPoint = Vector2.new(0.5, 0)
	self.purgeHpBg.Position = UDim2.new(0.5, 0, 0, 84)
	self.purgeHpBg.BackgroundColor3 = C.Gray800
	self.purgeHpBg.ZIndex = 212
	self.purgeHpBg.Parent = self.purgeGameCard
	pill(self.purgeHpBg)

	-- HP fill
	self.purgeHpFill = Instance.new("Frame")
	self.purgeHpFill.Size = UDim2.new(1, 0, 1, 0)
	self.purgeHpFill.BackgroundColor3 = C.Green
	self.purgeHpFill.ZIndex = 213
	self.purgeHpFill.Parent = self.purgeHpBg
	pill(self.purgeHpFill)

	-- Progress label
	self.purgeProgressLabel = Instance.new("TextLabel")
	self.purgeProgressLabel.Size = UDim2.new(0.9, 0, 0, 22)
	self.purgeProgressLabel.AnchorPoint = Vector2.new(0.5, 0)
	self.purgeProgressLabel.Position = UDim2.new(0.5, 0, 0, 110)
	self.purgeProgressLabel.BackgroundTransparency = 1
	self.purgeProgressLabel.Font = F.Medium
	self.purgeProgressLabel.TextSize = 14
	self.purgeProgressLabel.TextColor3 = C.Gray300
	self.purgeProgressLabel.TextXAlignment = Enum.TextXAlignment.Left
	self.purgeProgressLabel.Text = "ğŸ“Š Progress: 0 / 15 Scenarios Completed"
	self.purgeProgressLabel.ZIndex = 212
	self.purgeProgressLabel.Parent = self.purgeGameCard

	-- Scenario box
	self.purgeScenarioBox = Instance.new("TextLabel")
	self.purgeScenarioBox.Size = UDim2.new(0.9, 0, 0, 150)
	self.purgeScenarioBox.AnchorPoint = Vector2.new(0.5, 0)
	self.purgeScenarioBox.Position = UDim2.new(0.5, 0, 0, 140)
	self.purgeScenarioBox.BackgroundColor3 = C.Gray900
	self.purgeScenarioBox.Font = F.Medium
	self.purgeScenarioBox.TextSize = 16
	self.purgeScenarioBox.TextColor3 = C.White
	self.purgeScenarioBox.TextWrapped = true
	self.purgeScenarioBox.TextXAlignment = Enum.TextXAlignment.Left
	self.purgeScenarioBox.TextYAlignment = Enum.TextYAlignment.Top
	self.purgeScenarioBox.Text = ""
	self.purgeScenarioBox.ZIndex = 212
	self.purgeScenarioBox.Parent = self.purgeGameCard
	corner(self.purgeScenarioBox, 14)
	pad(self.purgeScenarioBox, 14, 14, 12, 12)

	-- Choices container
	self.purgeChoicesFrame = Instance.new("Frame")
	self.purgeChoicesFrame.Size = UDim2.new(0.9, 0, 0, 210)
	self.purgeChoicesFrame.AnchorPoint = Vector2.new(0.5, 0)
	self.purgeChoicesFrame.Position = UDim2.new(0.5, 0, 0, 305)
	self.purgeChoicesFrame.BackgroundTransparency = 1
	self.purgeChoicesFrame.ZIndex = 212
	self.purgeChoicesFrame.Parent = self.purgeGameCard

	local choiceLayout = Instance.new("UIListLayout")
	choiceLayout.Padding = UDim.new(0, 10)
	choiceLayout.Parent = self.purgeChoicesFrame

	self.purgeChoiceBtns = {}
	for i = 1, 3 do
		local btn = Instance.new("TextButton")
		btn.Size = UDim2.new(1, 0, 0, 56)
		btn.BackgroundColor3 = Color3.fromRGB(80, 15, 25)
		btn.Font = F.Button
		btn.TextSize = 16
		btn.TextColor3 = C.White
		btn.TextWrapped = true
		btn.Text = "Choice " .. i
		btn.AutoButtonColor = false
		btn.ZIndex = 213
		btn.Parent = self.purgeChoicesFrame
		corner(btn, 14)
		self.purgeChoiceBtns[i] = btn
	end

	local warn = Instance.new("TextLabel")
	warn.Size = UDim2.new(1, 0, 0, 22)
	warn.BackgroundTransparency = 1
	warn.Font = F.Button
	warn.TextSize = 14
	warn.TextColor3 = C.Amber
	warn.Text = "âš ï¸ Choose Wisely - Wrong choices will cost you HP!"
	warn.ZIndex = 212
	warn.Parent = self.purgeChoicesFrame

	-- DEATH CARD
	self.purgeDeathCard = Instance.new("Frame")
	self.purgeDeathCard.Size = UDim2.new(0.94, 0, 0.7, 0)
	self.purgeDeathCard.AnchorPoint = Vector2.new(0.5, 0.5)
	self.purgeDeathCard.Position = UDim2.fromScale(0.5, 0.5)
	self.purgeDeathCard.BackgroundColor3 = Color3.fromRGB(10, 10, 12)
	self.purgeDeathCard.Visible = false
	self.purgeDeathCard.ZIndex = 211
	self.purgeDeathCard.Parent = self.purgeOverlay
	corner(self.purgeDeathCard, 22)
	stroke(self.purgeDeathCard, 2, 0, C.Red)

	local diedTitle = Instance.new("TextLabel")
	diedTitle.Size = UDim2.new(1, 0, 0, 60)
	diedTitle.BackgroundTransparency = 1
	diedTitle.Font = F.Title
	diedTitle.TextSize = 30
	diedTitle.TextColor3 = C.Red
	diedTitle.Text = "ğŸ’€ YOU DIED"
	diedTitle.ZIndex = 212
	diedTitle.Parent = self.purgeDeathCard

	self.purgeDeathBody = Instance.new("TextLabel")
	self.purgeDeathBody.Size = UDim2.new(0.9, 0, 0, 80)
	self.purgeDeathBody.AnchorPoint = Vector2.new(0.5, 0)
	self.purgeDeathBody.Position = UDim2.new(0.5, 0, 0, 80)
	self.purgeDeathBody.BackgroundTransparency = 1
	self.purgeDeathBody.Font = F.Medium
	self.purgeDeathBody.TextSize = 18
	self.purgeDeathBody.TextColor3 = C.Red
	self.purgeDeathBody.TextWrapped = true
	self.purgeDeathBody.Text = "You have perished in The Purge!\nCause of Death: Became a victim of the purge"
	self.purgeDeathBody.ZIndex = 212
	self.purgeDeathBody.Parent = self.purgeDeathCard

	self.purgeContinueBtn = Instance.new("TextButton")
	self.purgeContinueBtn.Size = UDim2.new(0.9, 0, 0, 56)
	self.purgeContinueBtn.AnchorPoint = Vector2.new(0.5, 0)
	self.purgeContinueBtn.Position = UDim2.new(0.5, 0, 0.75, 0)
	self.purgeContinueBtn.BackgroundColor3 = C.Red
	self.purgeContinueBtn.Font = F.Button
	self.purgeContinueBtn.TextSize = 20
	self.purgeContinueBtn.TextColor3 = C.White
	self.purgeContinueBtn.Text = "Continue"
	self.purgeContinueBtn.AutoButtonColor = false
	self.purgeContinueBtn.ZIndex = 212
	self.purgeContinueBtn.Parent = self.purgeDeathCard
	corner(self.purgeContinueBtn, 14)

	-- Scenario data
	self.purgeScenarios = {
		{
			text = "You see a family being chased by an armed gang. They're heading toward your location. Helping them means revealing your position.",
			choices = {
				{ text = "Let them in and help defend", hpDelta = -10, good = true },
				{ text = "Stay hidden - don't reveal yourself", hpDelta = 0, good = true },
				{ text = "Create a distraction to help them escape", hpDelta = -5, good = true },
			}
		},
		{
			text = "A purge gang offers a deal: join them and you'll be protected. Refusing might make you their next target.",
			choices = {
				{ text = "Join them for protection", hpDelta = -25, good = false },
				{ text = "Refuse and prepare to defend", hpDelta = -10, good = true },
				{ text = "Pretend to join but plan to escape", hpDelta = -20, good = false },
			}
		},
		{
			text = "Your barricade is holding, but you hear footsteps on the roof. Something's not right.",
			choices = {
				{ text = "Move to a secondary safe room", hpDelta = 0, good = true },
				{ text = "Power off everything and go silent", hpDelta = -5, good = true },
				{ text = "Check the cameras and reposition", hpDelta = -10, good = true },
			}
		},
		{
			text = "A neighbor is pounding at your door begging for help. Loud noise attracts attention.",
			choices = {
				{ text = "Ignore them completely", hpDelta = 0, good = true },
				{ text = "Let them in immediately", hpDelta = -20, good = false },
				{ text = "Signal them to hide elsewhere", hpDelta = -5, good = true },
			}
		},
		{
			text = "You spot a supply cache in a store across the street. The area is exposed.",
			choices = {
				{ text = "Go now - speed over stealth", hpDelta = -20, good = false },
				{ text = "Wait and watch, then move", hpDelta = -5, good = true },
				{ text = "Skip it - too risky", hpDelta = 0, good = true },
			}
		},
		{
			text = "Someone is trying to pick your back door lock. You have seconds to act.",
			choices = {
				{ text = "Ambush them immediately", hpDelta = -15, good = false },
				{ text = "Retreat and reinforce inner doors", hpDelta = -5, good = true },
				{ text = "Make noise to scare them off", hpDelta = -10, good = true },
			}
		},
		{
			text = "A fire starts in a nearby building. Smoke may drift into your ventilation soon.",
			choices = {
				{ text = "Seal vents and relocate rooms", hpDelta = -5, good = true },
				{ text = "Investigate outside", hpDelta = -25, good = false },
				{ text = "Use a wet cloth mask and stay put", hpDelta = -10, good = true },
			}
		},
		{
			text = "You find a lone injured stranger who dropped a backpack of supplies.",
			choices = {
				{ text = "Take supplies and move on", hpDelta = -5, good = true },
				{ text = "Help them fully and escort them", hpDelta = -20, good = false },
				{ text = "Leave a small supply and point them away", hpDelta = -10, good = true },
			}
		},
		{
			text = "Your phone lights up: 'Safe house two streets over.' Could be a trap.",
			choices = {
				{ text = "Go straight there", hpDelta = -20, good = false },
				{ text = "Ignore it", hpDelta = 0, good = true },
				{ text = "Observe from distance first", hpDelta = -5, good = true },
			}
		},
		{
			text = "A drone-like buzzing passes above your street. You're unsure who controls it.",
			choices = {
				{ text = "Turn off lights and reduce movement", hpDelta = 0, good = true },
				{ text = "Go outside to look", hpDelta = -25, good = false },
				{ text = "Signal with a flashlight", hpDelta = -20, good = false },
			}
		},
		{
			text = "Final stretch. Sirens in the distance signal the last hour. Stay focused.",
			choices = {
				{ text = "Maintain strict silence and wait", hpDelta = 0, good = true },
				{ text = "Celebrate early and relax security", hpDelta = -25, good = false },
				{ text = "Re-check all locks and routes", hpDelta = -5, good = true },
			}
		},
	}
end

local function _purgeDisconnectAll(self)
	disconnectAll(self._purgeChoiceConnections)
	self._purgeChoiceConnections = {}
	disconnect(self._purgeBeginConnection)
	self._purgeBeginConnection = nil
	disconnect(self._purgeContinueConnection)
	self._purgeContinueConnection = nil
end

function Minigames:startPurge(callback, options)
	options = options or {}
	self.callback = callback
	self.activeGame = "purge"
	self.purgeOverlay.Visible = true

	-- Reset state
	self.purgeHp = 100
	self.purgeMaxHp = 100
	self.purgeIndex = 0
	self.purgeTotal = options.totalScenarios or 10

	-- Shuffle scenarios
	local pool = {}
	for _, s in ipairs(self.purgeScenarios) do
		table.insert(pool, s)
	end
	for i = #pool, 2, -1 do
		local j = math.random(i)
		pool[i], pool[j] = pool[j], pool[i]
	end
	self.purgeRun = {}
	for i = 1, math.min(self.purgeTotal, #pool) do
		table.insert(self.purgeRun, pool[i])
	end

	-- Show intro first
	self.purgeIntroCard.Visible = true
	self.purgeGameCard.Visible = false
	self.purgeDeathCard.Visible = false

	_purgeDisconnectAll(self)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Intro text was getting cut off
	-- User feedback: "LAST COUPLE WORDS GOT CUT OFF LIKE IT SAID WELCOME TO THE"
	-- Solution: Shorter intro text and slower typewriter for dramatic effect
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local introText =
		"ğŸ˜ˆ THE PURGE HAS BEGUN ğŸ˜ˆ\n\n" ..
		"For 24 hours, all crime is legal.\n\n" ..
		"No police. No rules. No mercy.\n\n" ..
		"Trust no one. Survive."
	typeText(self.purgeIntroBody, introText, options.introCps or 32, self._purgeTypingToken)

	self._purgeBeginConnection = self.purgeBeginBtn.MouseButton1Click:Connect(function()
		if self.activeGame ~= "purge" then return end
		self.purgeIntroCard.Visible = false
		self.purgeGameCard.Visible = true
		self:purgeUpdateHud()
		self:purgeNextScenario()
	end)
end

function Minigames:purgeUpdateHud()
	local hp = math.max(0, self.purgeHp)
	self.purgeHpLabel.Text = "â¤ï¸ HP: " .. hp .. " / " .. self.purgeMaxHp

	local ratio = hp / self.purgeMaxHp
	local color = (ratio <= 0.25 and C.Red) or (ratio <= 0.55 and C.Amber) or C.Green
	self.purgeHpFill.BackgroundColor3 = color

	tween(self.purgeHpFill, TweenInfo.new(0.15), {
		Size = UDim2.new(math.clamp(ratio, 0, 1), 0, 1, 0),
	})
end

function Minigames:purgeNextScenario()
	self.purgeIndex = self.purgeIndex + 1

	if self.purgeIndex > #self.purgeRun then
		self:endPurge(true)
		return
	end

	local s = self.purgeRun[self.purgeIndex]
	self.purgeProgressLabel.Text =
		"ğŸ“Š Progress: " .. (self.purgeIndex - 1) .. " / " .. #self.purgeRun .. " Scenarios Completed"

	-- Reset button colors
	for _, btn in ipairs(self.purgeChoiceBtns) do
		btn.BackgroundColor3 = Color3.fromRGB(80, 15, 25)
	end

	-- Typewriter scenario
	typeText(self.purgeScenarioBox, s.text, 48, self._purgeTypingToken)

	-- Rebind choices
	disconnectAll(self._purgeChoiceConnections)
	self._purgeChoiceConnections = {}

	for i = 1, 3 do
		local cData = s.choices[i]
		local btn = self.purgeChoiceBtns[i]
		if cData then
			btn.Visible = true
			btn.Text = cData.text

			self._purgeChoiceConnections[i] = btn.MouseButton1Click:Connect(function()
				self:purgeHandleChoice(i)
			end)
		else
			btn.Visible = false
		end
	end
end

function Minigames:purgeHandleChoice(i)
	if self.activeGame ~= "purge" then return end
	local s = self.purgeRun[self.purgeIndex]
	if not s then return end
	local cData = s.choices[i]
	if not cData then return end

	-- Visual feedback
	for idx, btn in ipairs(self.purgeChoiceBtns) do
		if btn.Visible then
			if idx == i then
				btn.BackgroundColor3 = cData.good and C.Green or C.Red
			else
				btn.BackgroundColor3 = Color3.fromRGB(60, 10, 18)
			end
		end
	end

	-- Apply HP change
	self.purgeHp = math.clamp(self.purgeHp + (cData.hpDelta or 0), 0, self.purgeMaxHp)
	self:purgeUpdateHud()

	-- Death check
	if self.purgeHp <= 0 then
		task.delay(0.35, function()
			if self.activeGame == "purge" then
				self:purgeShowDeath()
			end
		end)
		return
	end

	-- Next scenario
	task.delay(0.45, function()
		if self.activeGame == "purge" then
			self:purgeNextScenario()
		end
	end)
end

function Minigames:purgeShowDeath()
	self.purgeIntroCard.Visible = false
	self.purgeGameCard.Visible = false
	self.purgeDeathCard.Visible = true

	_purgeDisconnectAll(self)
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Show detailed death outcome with typewriter effect
	-- User feedback: "HAVE IT ACTUALLY KILL YOU AND HAVE IT SAY OUTCOMES LIKE WHAT 
	-- HAPPENED THEN CONTINUE TO NEXT ONE AND HAVE IT TYPE WRITER IT NICELY"
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	-- Random death causes for variety
	local deathCauses = {
		"You were caught by a purge gang. They showed no mercy.",
		"A roaming death squad found your hiding spot.",
		"You made a wrong turn and walked into an ambush.",
		"Your barricade was breached. You didn't stand a chance.",
		"Someone you trusted turned on you.",
		"The purgers tracked your every move. There was no escape.",
		"You fought bravely but were overwhelmed by numbers.",
		"A trap was set. You walked right into it.",
		"Your injuries from earlier choices proved fatal.",
		"In the chaos, you became another victim of The Purge.",
	}
	
	local causeOfDeath = deathCauses[math.random(1, #deathCauses)]
	local deathMessage = "ğŸ’€ YOU HAVE PERISHED ğŸ’€\n\n" .. causeOfDeath .. "\n\n" ..
		"Scenarios Survived: " .. math.max(0, (self.purgeIndex or 1) - 1) .. " / " .. (#self.purgeRun or 10)
	
	-- Typewriter the death outcome
	typeText(self.purgeDeathBody, deathMessage, 35, self._purgeTypingToken)

	self._purgeContinueConnection = self.purgeContinueBtn.MouseButton1Click:Connect(function()
		self:endPurge(false)
	end)
end

function Minigames:endPurge(won)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Show survival outcome before closing
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	if won then
		-- Show victory card with typewriter effect before closing
		self.purgeIntroCard.Visible = false
		self.purgeGameCard.Visible = false
		self.purgeDeathCard.Visible = false
		
		-- Reuse intro card for survival message
		self.purgeIntroCard.Visible = true
		
		local survivalMessages = {
			"You made it through the night. The sun rises on your survival.",
			"Against all odds, you survived The Purge. You're one of the lucky ones.",
			"The sirens signal the end. You lived to see another day.",
			"Your choices kept you alive. You survived The Purge.",
			"Dawn breaks. The nightmare is over. You made it.",
		}
		
		local survivalMsg = "ğŸ‰ YOU SURVIVED! ğŸ‰\n\n" .. 
			survivalMessages[math.random(1, #survivalMessages)] .. "\n\n" ..
			"HP Remaining: " .. (self.purgeHp or 0) .. " / 100\n" ..
			"Scenarios Completed: " .. (#self.purgeRun or 10) .. " / " .. (#self.purgeRun or 10)
		
		-- Typewriter the survival outcome
		typeText(self.purgeIntroBody, survivalMsg, 35, self._purgeTypingToken)
		
		-- Change begin button to continue
		self.purgeBeginBtn.Text = "ğŸŒ… Continue"
		self.purgeBeginBtn.BackgroundColor3 = C.Green
		
		_purgeDisconnectAll(self)
		
		self._purgeBeginConnection = self.purgeBeginBtn.MouseButton1Click:Connect(function()
			-- Now actually close and call callback
			self.activeGame = nil
			self.purgeOverlay.Visible = false
			self.purgeIntroCard.Visible = false
			
			-- Reset button for next time
			self.purgeBeginBtn.Text = "ğŸš¨ BEGIN APOCALYPSE ğŸš¨"
			self.purgeBeginBtn.BackgroundColor3 = C.Red
			
			if self.callback then
				self.callback(true, {
					hp = self.purgeHp or 0,
					completed = self.purgeRun and #self.purgeRun or 0,
					total = self.purgeRun and #self.purgeRun or 0,
					survived = true,
				})
				self.callback = nil
			end
		end)
	else
		-- Death path - close immediately (death screen already shown)
		self.activeGame = nil
		if self.purgeOverlay then
			self.purgeOverlay.Visible = false
		end
		self.purgeIntroCard.Visible = false
		self.purgeGameCard.Visible = false
		self.purgeDeathCard.Visible = false

		_purgeDisconnectAll(self)

		if self.callback then
			self.callback(false, {
				hp = 0,
				completed = math.max(0, (self.purgeIndex or 1) - 1),
				total = self.purgeRun and #self.purgeRun or 0,
				died = true,  -- Mark that player died
				causeOfDeath = "The Purge",
			})
			self.callback = nil
		end
	end
end

----------------------------------------------------------------
-- PUBLIC API
----------------------------------------------------------------

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FIGHT MINIGAME - Quick Time Events with a fighting theme
-- Used for confrontational choices in events
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function Minigames:startFight(callback, options)
	options = options or {}
	print("[Minigames] ğŸ‘Š Starting FIGHT minigame!")
	
	-- Use enhanced QTE for fights with fight-specific options
	self:startQTE(function(won, stats)
		-- Add fight-specific result processing
		local fightResult = {
			won = won,
			knockouts = stats and stats.hits or 0,
			damage_taken = won and math.random(5, 15) or math.random(20, 40),
			technique = won and "Victorious!" or "Got beat up...",
		}
		if callback then
			callback(won, fightResult)
		end
	end, options.difficulty or "medium")
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CONFRONTATION MINIGAME - Dialog-based confrontation with timed responses
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function Minigames:startConfrontation(callback, options)
	options = options or {}
	print("[Minigames] ğŸ˜¤ Starting CONFRONTATION minigame!")
	
	-- Use debate system for verbal confrontations - CRITICAL FIX: Pass context!
	self:startDebate(function(won, stats)
		local confrontResult = {
			won = won,
			intimidation = won and "They backed down!" or "They didn't budge.",
			respect_change = won and math.random(5, 15) or math.random(-10, -5),
		}
		if callback then
			callback(won, confrontResult)
		end
	end, { context = options.context or "argument", title = options.title })
end

function Minigames:play(gameType, callback, options)
	options = options or {}

	print("[Minigames] ğŸ® Starting minigame:", gameType)

	local success, err = pcall(function()
		if gameType == "debate" then
			-- CRITICAL FIX: Pass options to debate for context-aware title!
			self:startDebate(callback, options)
		elseif gameType == "heist" then
			-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			-- CRITICAL FIX: 4-digit guesser (heist) is ONLY for extremely hard missions!
			-- User feedback: "THE ONLY HARD ASF MINIGAME U NEED REMOVE IS THAT 4 DIDGET GUESSER"
			-- Solution: Only use heist for extremely hard missions (bank_robbery, etc.)
			-- For normal difficulty, convert to easier QTE minigame
			-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			local difficulty = options.difficulty or "normal"
			local isExtremelyHard = (difficulty == "hard" or difficulty == "extreme" or difficulty == "legendary")
			
			-- Also check if this is explicitly a high-risk crime (risk >= 70)
			local isHighRiskCrime = options.risk and options.risk >= 70
			
			if isExtremelyHard or isHighRiskCrime then
				print("[Minigames] ğŸ”“ Starting heist (4-digit guesser) for hard mission")
				self:startHeist(callback)
			else
				-- Convert to easier QTE for normal missions
				print("[Minigames] ğŸ¯ Converting heist to QTE for normal difficulty")
				self:startQTE(callback, "medium")
			end
		elseif gameType == "getaway" then
			self:startGetaway(callback)
		elseif gameType == "qte" then
			self:startQTE(callback, options.difficulty)
		elseif gameType == "prison_escape" then
			self:startPrisonEscape(callback)
		elseif gameType == "mash" then
			self:startMash(callback, options)
		elseif gameType == "hacking" then
			self:startHacking(callback, options)
		elseif gameType == "typing" then
			-- Typing minigame - use mash as fallback
			self:startMash(callback, options)
		elseif gameType == "fight" then
			-- UPGRADED: Now uses full combat minigame instead of QTE
			self:startCombat(callback, options)
		elseif gameType == "combat" then
			-- FULL COMBAT: BitLife-style interactive fighting
			self:startCombat(callback, options)
		elseif gameType == "confrontation" then
			-- CRITICAL FIX: Confrontation minigame for verbal conflicts
			self:startConfrontation(callback, options)
		elseif gameType == "purge" then
			-- THE PURGE: Rare survival event minigame
			self:startPurge(callback, options)
		else
			warn("[Minigames] âš ï¸ Unknown minigame type:", gameType, "- auto-failing")
			if callback then
				-- IMPORTANT: Return FALSE for unknown types, not true!
				callback(false, { error = "Unknown minigame type: " .. tostring(gameType) })
			end
		end
	end)

	if not success then
		warn("[Minigames] âŒ Error starting minigame:", err)
		if callback then
			-- If minigame crashes, return false (fail)
			callback(false, { error = "Minigame error: " .. tostring(err) })
		end
	end
end

function Minigames:isActive()
	return self.activeGame ~= nil
end

function Minigames:cancel()
	self.activeGame = nil

	if self.debateOverlay then self.debateOverlay.Visible = false end
	if self.heistOverlay then self.heistOverlay.Visible = false end
	if self.getawayOverlay then self.getawayOverlay.Visible = false end
	if self.qteOverlay then self.qteOverlay.Visible = false end
	if self.prisonOverlay then self.prisonOverlay.Visible = false end
	if self.mashOverlay then self.mashOverlay.Visible = false end
	if self.hackOverlay then self.hackOverlay.Visible = false end

	disconnectAll(self._debateButtonConnections)
	-- CRITICAL FIX: Wrap all task.cancel calls in pcall to prevent "cannot cancel thread" errors
	if self._debateTimerConnection then
		pcall(function() task.cancel(self._debateTimerConnection) end)
		self._debateTimerConnection = nil
	end

	disconnectAll(self._heistNumConnections)
	disconnectAll(self._getawayButtonConnections)
	if self._getawayCopChaseThread then
		pcall(function() task.cancel(self._getawayCopChaseThread) end)
		self._getawayCopChaseThread = nil
	end

	disconnect(self._qteTapConnection)
	self._qteTapConnection = nil

	disconnectAll(self._prisonArrowConnections)
	if self._prisonGuardThread then
		pcall(function() task.cancel(self._prisonGuardThread) end)
		self._prisonGuardThread = nil
	end

	disconnect(self._mashConnection)
	self._mashConnection = nil
	if self._mashTimerThread then
		pcall(function() task.cancel(self._mashTimerThread) end)
		self._mashTimerThread = nil
	end

	disconnectAll(self._hackKeyConnections)
	if self._hackTimerConnection then
		pcall(function() task.cancel(self._hackTimerConnection) end)
		self._hackTimerConnection = nil
	end

	-- Purge cleanup
	if self.purgeOverlay then self.purgeOverlay.Visible = false end
	if self.purgeIntroCard then self.purgeIntroCard.Visible = false end
	if self.purgeGameCard then self.purgeGameCard.Visible = false end
	if self.purgeDeathCard then self.purgeDeathCard.Visible = false end

	disconnectAll(self._purgeChoiceConnections)
	self._purgeChoiceConnections = {}
	disconnect(self._purgeBeginConnection)
	self._purgeBeginConnection = nil
	disconnect(self._purgeContinueConnection)
	self._purgeContinueConnection = nil

	if self._purgeAutoThread then
		pcall(function() task.cancel(self._purgeAutoThread) end)
		self._purgeAutoThread = nil
	end

	-- Combat cleanup
	if self.combatOverlay then self.combatOverlay.Visible = false end
	if self.combatEndFrame then self.combatEndFrame.Visible = false end
	disconnectAll(self._combatConnections)
	self._combatConnections = {}

	self.callback = nil
end

function Minigames:getAvailableGames()
	return {
		{ id = "debate", name = "Debate", emoji = "ğŸ¤", description = "Answer questions correctly" },
		{ id = "heist", name = "Heist", emoji = "ğŸ”“", description = "Crack the safe code" },
		{ id = "getaway", name = "Getaway", emoji = "ğŸš—", description = "Escape from the cops" },
		{ id = "qte", name = "Quick Time", emoji = "âš¡", description = "Tap at the right moment" },
		{ id = "prison_escape", name = "Prison Escape", emoji = "ğŸ”", description = "Navigate the maze" },
		{ id = "mash", name = "Mash", emoji = "ğŸ‘†", description = "Tap as fast as you can" },
		{ id = "hacking", name = "Hacking", emoji = "ğŸ’»", description = "Type codes to breach systems" },
		{ id = "combat", name = "Combat", emoji = "ğŸ‘Š", description = "Full interactive fighting" },
		{ id = "fight", name = "Fight", emoji = "ğŸ¥Š", description = "Physical fight (same as combat)" },
		{ id = "confrontation", name = "Confrontation", emoji = "ğŸ˜¤", description = "Verbal showdown" },
		{ id = "purge", name = "The Purge", emoji = "ğŸ˜ˆ", description = "Rare survival decision run" },
	}
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- RARE AUTO PURGE TRIGGER
-- Ultra-rare random event (0.5% chance) that triggers The Purge survival game
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function Minigames:enableRareAutoPurge(config)
	config = config or {}
	local chance = config.chance or 0.005 -- 0.5% default
	local interval = config.interval or 120 -- Check every 2 minutes
	local totalScenarios = config.totalScenarios or 10
	local introCps = config.introCps or 38
	local onComplete = config.onComplete
	
	-- Stop existing auto thread if running
	if self._purgeAutoThread then
		pcall(function() task.cancel(self._purgeAutoThread) end)
		self._purgeAutoThread = nil
	end

	print("[Minigames] ğŸ˜ˆ Enabling rare auto Purge trigger (", chance * 100, "% chance every", interval, "seconds)")
	
	self._purgeAutoThread = task.spawn(function()
		while true do
			task.wait(interval)
			
			-- Don't interrupt other active games
			if self.activeGame == nil then
				local roll = math.random()
				if roll <= chance then
					print("[Minigames] ğŸ˜ˆğŸ”¥ RARE PURGE EVENT TRIGGERED! Roll:", roll, "Threshold:", chance)
					
					self:startPurge(function(won, stats)
						print("[Minigames] ğŸ˜ˆ Purge completed. Won:", won)
						if onComplete then
							onComplete(won, stats)
						end
					end, {
						totalScenarios = totalScenarios,
						introCps = introCps,
					})
				end
			end
		end
	end)
end

function Minigames:disableRareAutoPurge()
	if self._purgeAutoThread then
		pcall(function() task.cancel(self._purgeAutoThread) end)
		self._purgeAutoThread = nil
		print("[Minigames] ğŸ˜ˆ Disabled rare auto Purge trigger")
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- COMBAT MINIGAME - Full BitLife-style interactive fighting
-- Choose where to hit, how to attack, with health bars and round-by-round action
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Combat hit locations
local CombatHitLocations = {
	{ id = "head", name = "Head", emoji = "ğŸ§ ", damage = {15, 35}, accuracy = 55, koChance = 15 },
	{ id = "face", name = "Face", emoji = "ğŸ˜µ", damage = {12, 28}, accuracy = 60, koChance = 12 },
	{ id = "jaw", name = "Jaw", emoji = "ğŸ˜¬", damage = {18, 40}, accuracy = 50, koChance = 20 },
	{ id = "chin", name = "Chin", emoji = "ğŸ«¢", damage = {16, 35}, accuracy = 55, koChance = 18 },
	{ id = "body", name = "Body", emoji = "ğŸ’ª", damage = {10, 22}, accuracy = 75, koChance = 3 },
	{ id = "ribs", name = "Ribs", emoji = "ğŸ¦´", damage = {12, 25}, accuracy = 70, koChance = 5 },
	{ id = "stomach", name = "Stomach", emoji = "ğŸ˜«", damage = {8, 20}, accuracy = 80, koChance = 2 },
	{ id = "legs", name = "Legs", emoji = "ğŸ¦µ", damage = {6, 15}, accuracy = 85, koChance = 0 },
	{ id = "groin", name = "Groin", emoji = "ğŸ˜±", damage = {20, 45}, accuracy = 45, koChance = 10, dirty = true },
}

-- Combat attack types
local CombatAttackTypes = {
	{ id = "jab", name = "Jab", emoji = "ğŸ¥Š", damageMod = 0.7, accMod = 1.3 },
	{ id = "punch", name = "Punch", emoji = "ğŸ‘Š", damageMod = 1.0, accMod = 1.0 },
	{ id = "hook", name = "Hook", emoji = "ğŸª", damageMod = 1.3, accMod = 0.85 },
	{ id = "uppercut", name = "Uppercut", emoji = "â¬†ï¸", damageMod = 1.5, accMod = 0.7, koBonus = 15 },
	{ id = "kick", name = "Kick", emoji = "ğŸ¦¶", damageMod = 1.2, accMod = 0.9 },
	{ id = "knee", name = "Knee Strike", emoji = "ğŸ¦µ", damageMod = 1.4, accMod = 0.75 },
	{ id = "elbow", name = "Elbow", emoji = "ğŸ’ª", damageMod = 1.35, accMod = 0.8 },
	{ id = "headbutt", name = "Headbutt", emoji = "ğŸ¤•", damageMod = 1.6, accMod = 0.6, dirty = true, selfDmg = 10 },
	{ id = "bite", name = "Bite", emoji = "ğŸ¦·", damageMod = 0.8, accMod = 0.5, dirty = true },
	{ id = "push", name = "Push", emoji = "ğŸ¤²", damageMod = 0.3, accMod = 1.4 },
	{ id = "dropkick", name = "Dropkick", emoji = "ğŸ¦˜", damageMod = 2.0, accMod = 0.4, selfFall = 60 },
	{ id = "haymaker", name = "Haymaker", emoji = "ğŸ’¥", damageMod = 2.0, accMod = 0.5, koBonus = 25 },
	{ id = "slap", name = "Slap", emoji = "ğŸ–ï¸", damageMod = 0.4, accMod = 1.5 },
}

-- Combat contexts - CRITICAL FIX: Added mafia-specific contexts!
-- User complaint: "Random Attack" showing instead of actual mafia context
local CombatContexts = {
	{ id = "street", title = "Street Fight", emoji = "ğŸŒ†", desc = "A stranger wants to fight you!" },
	{ id = "school", title = "School Fight", emoji = "ğŸ«", desc = "The bully is looking for trouble." },
	{ id = "bar", title = "Bar Brawl", emoji = "ğŸº", desc = "Things got heated at the bar." },
	{ id = "defense", title = "Self Defense", emoji = "âš ï¸", desc = "Someone attacked you!" },
	{ id = "revenge", title = "Payback Time", emoji = "ğŸ˜¤", desc = "Time to settle an old score." },
	{ id = "prison", title = "Prison Yard", emoji = "â›“ï¸", desc = "Another inmate is testing you." },
	{ id = "random", title = "Street Confrontation", emoji = "â—", desc = "Someone's looking for trouble!" },
	-- MAFIA-SPECIFIC CONTEXTS
	{ id = "collection", title = "Debt Collection", emoji = "ğŸ’°", desc = "Time to collect what's owed to the family." },
	{ id = "mafia_hit", title = "Family Business", emoji = "ğŸ”«", desc = "The boss gave you a job to do." },
	{ id = "enforcer", title = "Enforcer Duty", emoji = "ğŸ‘Š", desc = "Someone needs to be taught a lesson." },
	{ id = "rival_gang", title = "Rival Gang", emoji = "âš”ï¸", desc = "A rival crew is moving on our territory." },
	{ id = "protection", title = "Protection Run", emoji = "ğŸ’µ", desc = "The shopkeeper is refusing to pay up." },
	{ id = "interrogation", title = "Interrogation", emoji = "ğŸ¤", desc = "Someone knows something they shouldn't." },
	{ id = "ambush", title = "Ambush!", emoji = "ğŸš¨", desc = "You walked into a trap!" },
	{ id = "territory", title = "Territory War", emoji = "ğŸ—ºï¸", desc = "Defending our turf from invaders." },
	-- ASSAULT/MUGGING CONTEXTS
	{ id = "mugging", title = "Robbery", emoji = "ğŸ’¸", desc = "Target acquired. Time to move." },
	{ id = "assault", title = "Assault", emoji = "ğŸ‘Š", desc = "Time to send a message." },
}

-- Opponent types
local CombatOpponents = {
	{ id = "weak", name = "Weak", healthMod = 0.6, dmgMod = 0.5, desc = "a scrawny person" },
	{ id = "average", name = "Average", healthMod = 1.0, dmgMod = 1.0, desc = "someone your size" },
	{ id = "strong", name = "Strong", healthMod = 1.3, dmgMod = 1.4, desc = "a muscular person" },
	{ id = "trained", name = "Trained", healthMod = 1.5, dmgMod = 1.6, desc = "a trained fighter" },
	{ id = "drunk", name = "Drunk", healthMod = 0.8, dmgMod = 0.8, desc = "an intoxicated person" },
}

function Minigames:createCombatGame()
	-- Connection tracking
	self._combatConnections = {}
	self._combatPhase = nil -- "location", "attack", "result"
	
	-- Main overlay
	self.combatOverlay = Instance.new("Frame")
	self.combatOverlay.Size = UDim2.fromScale(1, 1)
	self.combatOverlay.BackgroundColor3 = C.Black
	self.combatOverlay.BackgroundTransparency = 0.2
	self.combatOverlay.Visible = false
	self.combatOverlay.ZIndex = 200
	self.combatOverlay.Parent = self.screenGui

	-- Main card - CRITICAL FIX: Responsive and clips content
	self.combatCard = Instance.new("Frame")
	self.combatCard.Size = UDim2.new(0.95, 0, 0.88, 0)  -- Slightly reduced for mobile
	self.combatCard.AnchorPoint = Vector2.new(0.5, 0.5)
	self.combatCard.Position = UDim2.fromScale(0.5, 0.5)
	self.combatCard.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
	self.combatCard.ClipsDescendants = true  -- CRITICAL: Prevent content overflow on mobile
	self.combatCard.ZIndex = 201
	self.combatCard.Parent = self.combatOverlay
	corner(self.combatCard, px(16))

	-- Header
	local header = Instance.new("Frame")
	header.Size = UDim2.new(1, 0, 0, px(60))
	header.BackgroundColor3 = C.Red
	header.ZIndex = 202
	header.Parent = self.combatCard
	corner(header, px(16))

	local headerFix = Instance.new("Frame")
	headerFix.Size = UDim2.new(1, 0, 0, px(30))
	headerFix.Position = UDim2.new(0, 0, 1, -px(30))
	headerFix.BackgroundColor3 = C.Red
	headerFix.ZIndex = 202
	headerFix.BorderSizePixel = 0
	headerFix.Parent = header

	self.combatTitle = Instance.new("TextLabel")
	self.combatTitle.Size = UDim2.new(1, 0, 1, 0)
	self.combatTitle.BackgroundTransparency = 1
	self.combatTitle.Font = F.Title
	self.combatTitle.TextSize = textSize(22)
	self.combatTitle.TextColor3 = C.White
	self.combatTitle.Text = "ğŸ‘Š FIGHT!"
	self.combatTitle.ZIndex = 203
	self.combatTitle.Parent = header

	-- Health bars container
	local healthContainer = Instance.new("Frame")
	healthContainer.Size = UDim2.new(0.95, 0, 0, px(70))
	healthContainer.AnchorPoint = Vector2.new(0.5, 0)
	healthContainer.Position = UDim2.new(0.5, 0, 0, px(70))
	healthContainer.BackgroundTransparency = 1
	healthContainer.ZIndex = 202
	healthContainer.Parent = self.combatCard

	-- Player health
	local playerHealthFrame = Instance.new("Frame")
	playerHealthFrame.Size = UDim2.new(0.48, 0, 1, 0)
	playerHealthFrame.BackgroundColor3 = Color3.fromRGB(30, 40, 50)
	playerHealthFrame.ZIndex = 203
	playerHealthFrame.Parent = healthContainer
	corner(playerHealthFrame, px(8))

	local playerHealthLabel = Instance.new("TextLabel")
	playerHealthLabel.Size = UDim2.new(1, 0, 0, px(20))
	playerHealthLabel.BackgroundTransparency = 1
	playerHealthLabel.Font = F.Medium
	playerHealthLabel.TextSize = textSize(12)
	playerHealthLabel.TextColor3 = C.White
	playerHealthLabel.Text = "ğŸ‘¤ YOU"
	playerHealthLabel.ZIndex = 204
	playerHealthLabel.Parent = playerHealthFrame
	pad(playerHealthLabel, px(8), 0, px(4), 0)

	local playerBarBg = Instance.new("Frame")
	playerBarBg.Size = UDim2.new(0.9, 0, 0, px(20))
	playerBarBg.AnchorPoint = Vector2.new(0.5, 0)
	playerBarBg.Position = UDim2.new(0.5, 0, 0, px(24))
	playerBarBg.BackgroundColor3 = C.Gray700
	playerBarBg.ZIndex = 204
	playerBarBg.Parent = playerHealthFrame
	pill(playerBarBg)

	self.playerHealthBar = Instance.new("Frame")
	self.playerHealthBar.Size = UDim2.new(1, 0, 1, 0)
	self.playerHealthBar.BackgroundColor3 = C.Green
	self.playerHealthBar.ZIndex = 205
	self.playerHealthBar.Parent = playerBarBg
	pill(self.playerHealthBar)

	self.playerHealthText = Instance.new("TextLabel")
	self.playerHealthText.Size = UDim2.new(1, 0, 0, px(16))
	self.playerHealthText.AnchorPoint = Vector2.new(0.5, 0)
	self.playerHealthText.Position = UDim2.new(0.5, 0, 0, px(48))
	self.playerHealthText.BackgroundTransparency = 1
	self.playerHealthText.Font = F.Title
	self.playerHealthText.TextSize = textSize(14)
	self.playerHealthText.TextColor3 = C.Green
	self.playerHealthText.Text = "100 HP"
	self.playerHealthText.ZIndex = 204
	self.playerHealthText.Parent = playerHealthFrame

	-- Opponent health
	local oppHealthFrame = Instance.new("Frame")
	oppHealthFrame.Size = UDim2.new(0.48, 0, 1, 0)
	oppHealthFrame.Position = UDim2.new(0.52, 0, 0, 0)
	oppHealthFrame.BackgroundColor3 = Color3.fromRGB(50, 30, 30)
	oppHealthFrame.ZIndex = 203
	oppHealthFrame.Parent = healthContainer
	corner(oppHealthFrame, px(8))

	self.oppNameLabel = Instance.new("TextLabel")
	self.oppNameLabel.Size = UDim2.new(1, 0, 0, px(20))
	self.oppNameLabel.BackgroundTransparency = 1
	self.oppNameLabel.Font = F.Medium
	self.oppNameLabel.TextSize = textSize(12)
	self.oppNameLabel.TextColor3 = C.White
	self.oppNameLabel.Text = "ğŸ˜¤ OPPONENT"
	self.oppNameLabel.ZIndex = 204
	self.oppNameLabel.Parent = oppHealthFrame
	pad(self.oppNameLabel, px(8), 0, px(4), 0)

	local oppBarBg = Instance.new("Frame")
	oppBarBg.Size = UDim2.new(0.9, 0, 0, px(20))
	oppBarBg.AnchorPoint = Vector2.new(0.5, 0)
	oppBarBg.Position = UDim2.new(0.5, 0, 0, px(24))
	oppBarBg.BackgroundColor3 = C.Gray700
	oppBarBg.ZIndex = 204
	oppBarBg.Parent = oppHealthFrame
	pill(oppBarBg)

	self.oppHealthBar = Instance.new("Frame")
	self.oppHealthBar.Size = UDim2.new(1, 0, 1, 0)
	self.oppHealthBar.BackgroundColor3 = C.Red
	self.oppHealthBar.ZIndex = 205
	self.oppHealthBar.Parent = oppBarBg
	pill(self.oppHealthBar)

	self.oppHealthText = Instance.new("TextLabel")
	self.oppHealthText.Size = UDim2.new(1, 0, 0, px(16))
	self.oppHealthText.AnchorPoint = Vector2.new(0.5, 0)
	self.oppHealthText.Position = UDim2.new(0.5, 0, 0, px(48))
	self.oppHealthText.BackgroundTransparency = 1
	self.oppHealthText.Font = F.Title
	self.oppHealthText.TextSize = textSize(14)
	self.oppHealthText.TextColor3 = C.Red
	self.oppHealthText.Text = "100 HP"
	self.oppHealthText.ZIndex = 204
	self.oppHealthText.Parent = oppHealthFrame

	-- Round indicator
	self.combatRound = Instance.new("TextLabel")
	self.combatRound.Size = UDim2.new(0.9, 0, 0, px(24))
	self.combatRound.AnchorPoint = Vector2.new(0.5, 0)
	self.combatRound.Position = UDim2.new(0.5, 0, 0, px(145))
	self.combatRound.BackgroundTransparency = 1
	self.combatRound.Font = F.Medium
	self.combatRound.TextSize = textSize(14)
	self.combatRound.TextColor3 = C.Amber
	self.combatRound.Text = "âš”ï¸ ROUND 1"
	self.combatRound.ZIndex = 202
	self.combatRound.Parent = self.combatCard

	-- Narrative text area
	self.combatNarrative = Instance.new("TextLabel")
	self.combatNarrative.Size = UDim2.new(0.9, 0, 0, px(60))
	self.combatNarrative.AnchorPoint = Vector2.new(0.5, 0)
	self.combatNarrative.Position = UDim2.new(0.5, 0, 0, px(170))
	self.combatNarrative.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
	self.combatNarrative.Font = F.Body
	self.combatNarrative.TextSize = textSize(14)
	self.combatNarrative.TextColor3 = C.White
	self.combatNarrative.TextWrapped = true
	self.combatNarrative.Text = "The fight is about to begin..."
	self.combatNarrative.ZIndex = 202
	self.combatNarrative.Parent = self.combatCard
	corner(self.combatNarrative, px(8))
	pad(self.combatNarrative, px(12), px(12), px(8), px(8))

	-- Phase prompt
	self.combatPrompt = Instance.new("TextLabel")
	self.combatPrompt.Size = UDim2.new(0.9, 0, 0, px(28))
	self.combatPrompt.AnchorPoint = Vector2.new(0.5, 0)
	self.combatPrompt.Position = UDim2.new(0.5, 0, 0, px(235))
	self.combatPrompt.BackgroundTransparency = 1
	self.combatPrompt.Font = F.Title
	self.combatPrompt.TextSize = textSize(16)
	self.combatPrompt.TextColor3 = C.Amber
	self.combatPrompt.Text = "ğŸ¯ WHERE DO YOU ATTACK?"
	self.combatPrompt.ZIndex = 202
	self.combatPrompt.Parent = self.combatCard

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: BIGGER BUTTONS that fill the combat area properly
	-- User feedback: "THE FIGHTING MINIGAME SCREEN BUTTONS ARE REALLY SMALL FOR ME 
	-- NOT FILLING THE THINGY AT BOTTOM"
	-- Solution: Use larger buttons (48px height), bigger text (14px), fill the space
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	-- Calculate available space - card is 90% of screen, buttons should fill bottom
	local COMBAT_BTN_HEIGHT = px(48)  -- BIGGER buttons for mobile
	local COMBAT_BTN_TEXT = textSize(14)  -- BIGGER text for readability
	local COMBAT_BTN_SPACING = px(6)  -- Good spacing between buttons
	
	-- Location buttons container (phase 1) - fills remaining card space
	self.combatLocationFrame = Instance.new("Frame")
	self.combatLocationFrame.Size = UDim2.new(0.95, 0, 0, px(320))  -- TALLER frame
	self.combatLocationFrame.AnchorPoint = Vector2.new(0.5, 0)
	self.combatLocationFrame.Position = UDim2.new(0.5, 0, 0, px(265))
	self.combatLocationFrame.BackgroundTransparency = 1
	self.combatLocationFrame.ZIndex = 202
	self.combatLocationFrame.Parent = self.combatCard

	-- 3-column grid with BIGGER buttons
	local locGrid = Instance.new("UIGridLayout")
	locGrid.CellSize = UDim2.new(0.32, 0, 0, COMBAT_BTN_HEIGHT)  -- BIGGER buttons
	locGrid.CellPadding = UDim2.new(0.01, 0, 0, COMBAT_BTN_SPACING)
	locGrid.HorizontalAlignment = Enum.HorizontalAlignment.Center
	locGrid.Parent = self.combatLocationFrame

	self.combatLocationBtns = {}
	for i, loc in ipairs(CombatHitLocations) do
		local btn = Instance.new("TextButton")
		btn.BackgroundColor3 = C.Blue
		btn.Font = F.Button
		btn.TextSize = COMBAT_BTN_TEXT  -- BIGGER text
		btn.TextColor3 = C.White
		-- CRITICAL FIX: Nil guards to prevent concatenation errors
		btn.Text = (loc.emoji or "âš”ï¸") .. " " .. (loc.name or "Target")
		btn.AutoButtonColor = false
		btn.ZIndex = 203
		btn.Parent = self.combatLocationFrame
		corner(btn, px(8))

		self.combatLocationBtns[i] = { btn = btn, data = loc }
	end

	-- Defense buttons - BIGGER and more visible
	local defendBtn = Instance.new("TextButton")
	defendBtn.BackgroundColor3 = C.Purple
	defendBtn.Font = F.Button
	defendBtn.TextSize = COMBAT_BTN_TEXT  -- BIGGER text
	defendBtn.TextColor3 = C.White
	defendBtn.Text = "ğŸ›¡ï¸ Block"
	defendBtn.AutoButtonColor = false
	defendBtn.ZIndex = 203
	defendBtn.Parent = self.combatLocationFrame
	corner(defendBtn, px(8))
	self.combatDefendBtn = defendBtn

	local runBtn = Instance.new("TextButton")
	runBtn.BackgroundColor3 = C.Gray600
	runBtn.Font = F.Button
	runBtn.TextSize = COMBAT_BTN_TEXT  -- BIGGER text
	runBtn.TextColor3 = C.White
	runBtn.Text = "ğŸƒ Run Away"
	runBtn.AutoButtonColor = false
	runBtn.ZIndex = 203
	runBtn.Parent = self.combatLocationFrame
	corner(runBtn, px(8))
	self.combatRunBtn = runBtn

	-- Attack type buttons container (phase 2) - same sizing
	self.combatAttackFrame = Instance.new("Frame")
	self.combatAttackFrame.Size = UDim2.new(0.95, 0, 0, px(320))  -- TALLER frame
	self.combatAttackFrame.AnchorPoint = Vector2.new(0.5, 0)
	self.combatAttackFrame.Position = UDim2.new(0.5, 0, 0, px(265))
	self.combatAttackFrame.BackgroundTransparency = 1
	self.combatAttackFrame.Visible = false
	self.combatAttackFrame.ZIndex = 202
	self.combatAttackFrame.Parent = self.combatCard

	-- 3-column grid for attack types with BIGGER buttons
	local atkGrid = Instance.new("UIGridLayout")
	atkGrid.CellSize = UDim2.new(0.32, 0, 0, COMBAT_BTN_HEIGHT)  -- BIGGER buttons
	atkGrid.CellPadding = UDim2.new(0.01, 0, 0, COMBAT_BTN_SPACING)
	atkGrid.HorizontalAlignment = Enum.HorizontalAlignment.Center
	atkGrid.Parent = self.combatAttackFrame

	self.combatAttackBtns = {}
	for i, atk in ipairs(CombatAttackTypes) do
		local btn = Instance.new("TextButton")
		btn.BackgroundColor3 = C.Red
		btn.Font = F.Button
		btn.TextSize = COMBAT_BTN_TEXT  -- BIGGER text
		btn.TextColor3 = C.White
		-- CRITICAL FIX: Nil guards to prevent concatenation errors
		btn.Text = (atk.emoji or "ğŸ‘Š") .. " " .. (atk.name or "Attack")
		btn.AutoButtonColor = false
		btn.ZIndex = 203
		btn.Parent = self.combatAttackFrame
		corner(btn, px(8))

		self.combatAttackBtns[i] = { btn = btn, data = atk }
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Result panel - MOBILE RESPONSIVE with percentage-based sizing
	-- Shows round-by-round combat results
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	self.combatResultFrame = Instance.new("Frame")
	-- Use percentage height and position relative to card
	self.combatResultFrame.Size = UDim2.new(0.95, 0, 0.45, 0)  -- 45% of card height
	self.combatResultFrame.AnchorPoint = Vector2.new(0.5, 1)
	self.combatResultFrame.Position = UDim2.new(0.5, 0, 1, -px(10))  -- Anchored to bottom
	self.combatResultFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 45)
	self.combatResultFrame.Visible = false
	self.combatResultFrame.ZIndex = 202
	self.combatResultFrame.ClipsDescendants = true
	self.combatResultFrame.Parent = self.combatCard
	corner(self.combatResultFrame, px(12))

	-- Scrollable text area for round results
	local resultScroll = Instance.new("ScrollingFrame")
	resultScroll.Size = UDim2.new(1, 0, 1, -(isTinyPhone() and 50 or px(60)))
	resultScroll.Position = UDim2.new(0, 0, 0, 0)
	resultScroll.BackgroundTransparency = 1
	resultScroll.BorderSizePixel = 0
	resultScroll.ScrollBarThickness = 3
	resultScroll.ScrollBarImageColor3 = C.Gray500
	resultScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
	resultScroll.CanvasSize = UDim2.new(1, 0, 0, 0)
	resultScroll.ScrollingDirection = Enum.ScrollingDirection.Y
	resultScroll.ZIndex = 203
	resultScroll.Parent = self.combatResultFrame

	local resultPad = Instance.new("UIPadding")
	resultPad.PaddingTop = UDim.new(0, 8)
	resultPad.PaddingBottom = UDim.new(0, 8)
	resultPad.PaddingLeft = UDim.new(0, 10)
	resultPad.PaddingRight = UDim.new(0, 10)
	resultPad.Parent = resultScroll

	self.combatResultText = Instance.new("TextLabel")
	self.combatResultText.Size = UDim2.new(1, 0, 0, 0)
	self.combatResultText.AutomaticSize = Enum.AutomaticSize.Y
	self.combatResultText.BackgroundTransparency = 1
	self.combatResultText.Font = F.Body
	self.combatResultText.TextSize = isTinyPhone() and 12 or (isSmallScreen() and 13 or textSize(14))
	self.combatResultText.TextColor3 = C.White
	self.combatResultText.TextWrapped = true
	self.combatResultText.Text = ""
	self.combatResultText.ZIndex = 204
	self.combatResultText.Parent = resultScroll

	self.combatContinueBtn = Instance.new("TextButton")
	self.combatContinueBtn.Size = UDim2.new(0.85, 0, 0, isTinyPhone() and 38 or px(44))
	self.combatContinueBtn.AnchorPoint = Vector2.new(0.5, 1)
	self.combatContinueBtn.Position = UDim2.new(0.5, 0, 1, -px(8))
	self.combatContinueBtn.BackgroundColor3 = C.Green
	self.combatContinueBtn.Font = F.Button
	self.combatContinueBtn.TextSize = isTinyPhone() and 13 or textSize(16)
	self.combatContinueBtn.TextColor3 = C.White
	self.combatContinueBtn.Text = "Continue Fighting"
	self.combatContinueBtn.AutoButtonColor = false
	self.combatContinueBtn.ZIndex = 205
	self.combatContinueBtn.Parent = self.combatResultFrame
	corner(self.combatContinueBtn, px(8))

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Final outcome panel - MOBILE RESPONSIVE with scrollable content
	-- User feedback: "fighting results UI is half cut off screen on mobile"
	-- Solution: Use full card height, scrollable content, proper layout
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	self.combatEndFrame = Instance.new("Frame")
	self.combatEndFrame.Size = UDim2.new(0.98, 0, 0.95, 0)  -- Almost full card size
	self.combatEndFrame.AnchorPoint = Vector2.new(0.5, 0.5)
	self.combatEndFrame.Position = UDim2.fromScale(0.5, 0.5)
	self.combatEndFrame.BackgroundColor3 = Color3.fromRGB(25, 30, 40)
	self.combatEndFrame.Visible = false
	self.combatEndFrame.ZIndex = 210
	self.combatEndFrame.ClipsDescendants = true
	self.combatEndFrame.Parent = self.combatCard
	corner(self.combatEndFrame, px(16))

	-- Scrollable content container for the results
	local combatEndScroll = Instance.new("ScrollingFrame")
	combatEndScroll.Size = UDim2.new(1, 0, 1, -px(70))  -- Leave room for button at bottom
	combatEndScroll.Position = UDim2.new(0, 0, 0, 0)
	combatEndScroll.BackgroundTransparency = 1
	combatEndScroll.BorderSizePixel = 0
	combatEndScroll.ScrollBarThickness = 4
	combatEndScroll.ScrollBarImageColor3 = C.Gray500
	combatEndScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
	combatEndScroll.CanvasSize = UDim2.new(1, 0, 0, 0)
	combatEndScroll.ScrollingDirection = Enum.ScrollingDirection.Y
	combatEndScroll.ZIndex = 211
	combatEndScroll.Parent = self.combatEndFrame

	-- Use UIListLayout for proper stacking
	local endLayout = Instance.new("UIListLayout")
	endLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	endLayout.Padding = UDim.new(0, isTinyPhone() and 4 or 8)
	endLayout.Parent = combatEndScroll

	local endPadding = Instance.new("UIPadding")
	endPadding.PaddingTop = UDim.new(0, isTinyPhone() and 8 or 12)
	endPadding.PaddingBottom = UDim.new(0, isTinyPhone() and 8 or 12)
	endPadding.PaddingLeft = UDim.new(0, 10)
	endPadding.PaddingRight = UDim.new(0, 10)
	endPadding.Parent = combatEndScroll

	-- Smaller emoji on mobile
	local emojiSize = isTinyPhone() and 50 or (isSmallScreen() and 60 or 80)
	self.combatEndEmoji = Instance.new("TextLabel")
	self.combatEndEmoji.Size = UDim2.new(1, 0, 0, emojiSize)
	self.combatEndEmoji.BackgroundTransparency = 1
	self.combatEndEmoji.Font = F.Title
	self.combatEndEmoji.TextSize = isTinyPhone() and 40 or (isSmallScreen() and 50 or 60)
	self.combatEndEmoji.Text = "ğŸ†"
	self.combatEndEmoji.LayoutOrder = 1
	self.combatEndEmoji.ZIndex = 212
	self.combatEndEmoji.Parent = combatEndScroll

	self.combatEndTitle = Instance.new("TextLabel")
	self.combatEndTitle.Size = UDim2.new(1, 0, 0, 0)
	self.combatEndTitle.AutomaticSize = Enum.AutomaticSize.Y
	self.combatEndTitle.BackgroundTransparency = 1
	self.combatEndTitle.Font = F.Title
	self.combatEndTitle.TextSize = isTinyPhone() and 18 or (isSmallScreen() and 20 or 24)
	self.combatEndTitle.TextColor3 = C.White
	self.combatEndTitle.Text = "VICTORY!"
	self.combatEndTitle.TextWrapped = true
	self.combatEndTitle.LayoutOrder = 2
	self.combatEndTitle.ZIndex = 212
	self.combatEndTitle.Parent = combatEndScroll

	self.combatEndText = Instance.new("TextLabel")
	self.combatEndText.Size = UDim2.new(1, 0, 0, 0)
	self.combatEndText.AutomaticSize = Enum.AutomaticSize.Y
	self.combatEndText.BackgroundTransparency = 1
	self.combatEndText.Font = F.Body
	self.combatEndText.TextSize = isTinyPhone() and 12 or (isSmallScreen() and 13 or 14)
	self.combatEndText.TextColor3 = C.Gray300
	self.combatEndText.TextWrapped = true
	self.combatEndText.Text = ""
	self.combatEndText.LayoutOrder = 3
	self.combatEndText.ZIndex = 212
	self.combatEndText.Parent = combatEndScroll

	self.combatEndStats = Instance.new("TextLabel")
	self.combatEndStats.Size = UDim2.new(1, 0, 0, 0)
	self.combatEndStats.AutomaticSize = Enum.AutomaticSize.Y
	self.combatEndStats.BackgroundTransparency = 1
	self.combatEndStats.Font = F.Medium
	self.combatEndStats.TextSize = isTinyPhone() and 10 or (isSmallScreen() and 11 or 12)
	self.combatEndStats.TextColor3 = C.Amber
	self.combatEndStats.TextWrapped = true
	self.combatEndStats.Text = ""
	self.combatEndStats.LayoutOrder = 4
	self.combatEndStats.ZIndex = 212
	self.combatEndStats.Parent = combatEndScroll

	-- Continue button at BOTTOM of frame (not in scroll)
	self.combatEndBtn = Instance.new("TextButton")
	self.combatEndBtn.Size = UDim2.new(0.8, 0, 0, isTinyPhone() and 40 or px(50))
	self.combatEndBtn.AnchorPoint = Vector2.new(0.5, 1)
	self.combatEndBtn.Position = UDim2.new(0.5, 0, 1, isTinyPhone() and -8 or -px(12))
	self.combatEndBtn.BackgroundColor3 = C.Blue
	self.combatEndBtn.Font = F.Button
	self.combatEndBtn.TextSize = isTinyPhone() and 14 or textSize(18)
	self.combatEndBtn.TextColor3 = C.White
	self.combatEndBtn.Text = "Continue"
	self.combatEndBtn.AutoButtonColor = false
	self.combatEndBtn.ZIndex = 213
	self.combatEndBtn.Parent = self.combatEndFrame
	corner(self.combatEndBtn, px(10))
end

function Minigames:combatUpdateHealthBars()
	local playerPct = math.clamp(self.combatState.playerHealth / 100, 0, 1)
	local oppPct = math.clamp(self.combatState.oppHealth / self.combatState.oppMaxHealth, 0, 1)

	tween(self.playerHealthBar, TweenInfo.new(0.3), { Size = UDim2.new(playerPct, 0, 1, 0) })
	tween(self.oppHealthBar, TweenInfo.new(0.3), { Size = UDim2.new(oppPct, 0, 1, 0) })

	self.playerHealthText.Text = math.floor(self.combatState.playerHealth) .. " HP"
	self.oppHealthText.Text = math.floor(self.combatState.oppHealth) .. " HP"

	-- Color based on health
	if playerPct > 0.5 then
		self.playerHealthBar.BackgroundColor3 = C.Green
		self.playerHealthText.TextColor3 = C.Green
	elseif playerPct > 0.25 then
		self.playerHealthBar.BackgroundColor3 = C.Amber
		self.playerHealthText.TextColor3 = C.Amber
	else
		self.playerHealthBar.BackgroundColor3 = C.Red
		self.playerHealthText.TextColor3 = C.Red
	end
end

function Minigames:combatShowPhase(phase)
	self._combatPhase = phase
	self.combatLocationFrame.Visible = (phase == "location")
	self.combatAttackFrame.Visible = (phase == "attack")
	self.combatResultFrame.Visible = (phase == "result")
	self.combatEndFrame.Visible = (phase == "end")

	if phase == "location" then
		self.combatPrompt.Text = "ğŸ¯ WHERE DO YOU ATTACK?"
	elseif phase == "attack" then
		local locName = self.combatState.selectedLocation and self.combatState.selectedLocation.name or "target"
		self.combatPrompt.Text = "âš”ï¸ HOW DO YOU ATTACK THE " .. string.upper(locName) .. "?"
	elseif phase == "result" then
		self.combatPrompt.Text = "ğŸ“Š ROUND " .. self.combatState.round .. " RESULT"
	elseif phase == "end" then
		self.combatPrompt.Text = ""
	end
end

function Minigames:combatCalculateAttack(attack, location, isPlayer)
	-- CRITICAL FIX: Nil guards to prevent errors when attack/location are nil
	if not attack or not location then
		return { hit = false, damage = 0, crit = false, ko = false }
	end
	
	-- Default values if damage/accuracy tables are nil
	local locDamage = location.damage or {10, 20}
	local baseDmg = math.random(locDamage[1] or 10, locDamage[2] or 20)
	local dmg = baseDmg * (attack.damageMod or 1.0)
	local acc = (location.accuracy or 70) * (attack.accMod or 1.0)

	-- Apply opponent modifiers if it's opponent attacking
	if not isPlayer and self.combatState.opponent then
		dmg = dmg * self.combatState.opponent.dmgMod
	end

	-- Roll for hit
	local hit = math.random(100) <= acc
	if not hit then
		return { hit = false, damage = 0, crit = false, ko = false }
	end

	-- Critical hit
	local critChance = 15 + (attack.koBonus or 0)
	local crit = math.random(100) <= critChance
	if crit then dmg = dmg * 1.5 end

	-- Knockout check
	local koChance = location.koChance + (attack.koBonus or 0)
	if crit then koChance = koChance * 1.5 end
	local ko = math.random(100) <= koChance

	-- Self damage for dirty moves
	local selfDmg = attack.selfDmg or 0
	
	-- Self fall for dropkick
	if attack.selfFall and math.random(100) <= attack.selfFall then
		selfDmg = selfDmg + 15
	end

	return {
		hit = true,
		damage = math.floor(dmg),
		crit = crit,
		ko = ko,
		selfDamage = selfDmg,
		dirty = attack.dirty or location.dirty,
	}
end

function Minigames:combatProcessRound()
	local state = self.combatState
	local location = state.selectedLocation
	local attack = state.selectedAttack
	
	local narrative = ""
	
	-- Player attacks
	local playerResult = self:combatCalculateAttack(attack, location, true)
	state.stats.attacksThrown = state.stats.attacksThrown + 1
	
	if playerResult.hit then
		state.stats.attacksLanded = state.stats.attacksLanded + 1
		state.oppHealth = state.oppHealth - playerResult.damage
		state.stats.damageDealt = state.stats.damageDealt + playerResult.damage
		
		-- CRITICAL FIX: Nil guards to prevent "attempt to concatenate string with nil" errors
		local attackName = (attack and attack.name) and attack.name:lower() or "attack"
		local locationName = (location and location.name) and location.name:lower() or "body"
		
		if playerResult.crit then
			narrative = "ğŸ’¥ CRITICAL HIT! Your " .. attackName .. " to their " .. locationName .. " deals " .. tostring(playerResult.damage or 0) .. " damage!"
			state.stats.criticalHits = state.stats.criticalHits + 1
		else
			narrative = "Your " .. attackName .. " connects with their " .. locationName .. " for " .. tostring(playerResult.damage or 0) .. " damage."
		end
		
		if playerResult.dirty then
			narrative = narrative .. " ğŸ˜ˆ Dirty move!"
		end
		
		-- Self damage
		if playerResult.selfDamage > 0 then
			state.playerHealth = state.playerHealth - playerResult.selfDamage
			narrative = narrative .. " You take " .. playerResult.selfDamage .. " self-damage!"
		end
		
		-- Check for knockout
		if playerResult.ko or state.oppHealth <= 0 then
			state.combatEnded = true
			state.won = true
			state.knockout = true
			state.stats.knockouts = state.stats.knockouts + 1
			narrative = narrative .. "\n\nğŸ† KNOCKOUT! They're down and not getting up!"
			self.combatResultText.Text = narrative
			self:combatShowPhase("result")
			return
		end
	else
		-- CRITICAL FIX: Nil guard
		local attackName = (attack and attack.name) and attack.name:lower() or "attack"
		narrative = "You swing with a " .. attackName .. " but miss!"
	end
	
	narrative = narrative .. "\n\n"
	
	-- Opponent attacks back
	local oppAttack = CombatAttackTypes[math.random(#CombatAttackTypes)]
	local oppLocation = CombatHitLocations[math.random(#CombatHitLocations)]
	
	local oppResult = self:combatCalculateAttack(oppAttack, oppLocation, false)
	
	-- Apply defense if player was blocking
	if state.wasBlocking then
		if oppResult.hit then
			oppResult.damage = math.floor(oppResult.damage * 0.4)
		end
		narrative = narrative .. "ğŸ›¡ï¸ You blocked! "
	end
	
	-- CRITICAL FIX: Nil guards for opponent attack/location names
	local oppAttackName = (oppAttack and oppAttack.name) and oppAttack.name:lower() or "attack"
	local oppLocationName = (oppLocation and oppLocation.name) and oppLocation.name:lower() or "body"
	
	if oppResult.hit then
		state.playerHealth = state.playerHealth - oppResult.damage
		state.stats.damageTaken = state.stats.damageTaken + oppResult.damage
		
		if oppResult.crit then
			narrative = narrative .. "ğŸ’¥ They land a devastating " .. oppAttackName .. " to your " .. oppLocationName .. " for " .. tostring(oppResult.damage or 0) .. " damage!"
		else
			narrative = narrative .. "They hit you with a " .. oppAttackName .. " to your " .. oppLocationName .. " for " .. tostring(oppResult.damage or 0) .. " damage."
		end
		
		-- Check for player knockout
		if oppResult.ko or state.playerHealth <= 0 then
			state.combatEnded = true
			state.won = false
			state.knockout = true
			narrative = narrative .. "\n\nğŸ’« You got KNOCKED OUT!"
			self.combatResultText.Text = narrative
			self:combatShowPhase("result")
			return
		end
	else
		narrative = narrative .. "They swing but miss!"
	end
	
	-- Health status
	narrative = narrative .. "\n\n"
	if state.playerHealth > 70 then
		narrative = narrative .. "You're feeling strong."
	elseif state.playerHealth > 40 then
		narrative = narrative .. "You're hurt but still fighting."
	else
		narrative = narrative .. "You're badly injured!"
	end
	
	if state.oppHealth > state.oppMaxHealth * 0.7 then
		narrative = narrative .. " They look unfazed."
	elseif state.oppHealth > state.oppMaxHealth * 0.4 then
		narrative = narrative .. " They're showing damage."
	else
		narrative = narrative .. " They're on their last legs!"
	end
	
	state.round = state.round + 1
	self.combatResultText.Text = narrative
	self:combatShowPhase("result")
end

function Minigames:combatSelectLocation(locationData)
	if self._combatPhase ~= "location" then return end
	
	self.combatState.selectedLocation = locationData
	self.combatState.wasBlocking = false
	
	-- Highlight selected button
	for _, item in ipairs(self.combatLocationBtns) do
		if item.data.id == locationData.id then
			item.btn.BackgroundColor3 = C.Green
		else
			item.btn.BackgroundColor3 = C.Blue
		end
	end
	
	-- Show attack type selection
	task.delay(0.2, function()
		if self.activeGame == "combat" then
			self:combatShowPhase("attack")
		end
	end)
end

function Minigames:combatSelectAttack(attackData)
	if self._combatPhase ~= "attack" then return end
	
	self.combatState.selectedAttack = attackData
	
	-- Highlight selected button
	for _, item in ipairs(self.combatAttackBtns) do
		if item.data.id == attackData.id then
			item.btn.BackgroundColor3 = C.Green
		else
			item.btn.BackgroundColor3 = C.Red
		end
	end
	
	-- Process the round
	task.delay(0.3, function()
		if self.activeGame == "combat" then
			self:combatProcessRound()
			self:combatUpdateHealthBars()
		end
	end)
end

function Minigames:combatDefend()
	if self._combatPhase ~= "location" then return end
	
	self.combatState.wasBlocking = true
	self.combatState.selectedLocation = CombatHitLocations[5] -- body
	self.combatState.selectedAttack = CombatAttackTypes[1] -- jab (weak)
	
	self.combatDefendBtn.BackgroundColor3 = C.Green
	
	task.delay(0.3, function()
		if self.activeGame == "combat" then
			self:combatProcessRound()
			self:combatUpdateHealthBars()
		end
	end)
end

function Minigames:combatRun()
	if self._combatPhase ~= "location" then return end
	
	local escapeChance = 60
	if self.combatState.opponent then
		escapeChance = escapeChance - (self.combatState.round * 5) -- Harder to run as fight goes on
	end
	
	if math.random(100) <= escapeChance then
		self.combatState.combatEnded = true
		self.combatState.escaped = true
		self.combatResultText.Text = "ğŸƒ You managed to escape the fight!\n\nYou ran away before things got worse. Smart? Maybe. Cowardly? Definitely."
		self:combatShowPhase("result")
	else
		self.combatResultText.Text = "ğŸƒâŒ You tried to run but they caught you!\n\nNow they're even angrier..."
		self.combatState.playerHealth = self.combatState.playerHealth - 10 -- Penalty for failed escape
		self:combatUpdateHealthBars()
		self:combatShowPhase("result")
	end
end

function Minigames:combatContinue()
	if self.combatState.combatEnded then
		self:combatShowEnd()
	else
		-- Reset for next round
		self.combatState.selectedLocation = nil
		self.combatState.selectedAttack = nil
		self.combatState.wasBlocking = false
		
		-- Reset button colors
		for _, item in ipairs(self.combatLocationBtns) do
			item.btn.BackgroundColor3 = C.Blue
		end
		for _, item in ipairs(self.combatAttackBtns) do
			item.btn.BackgroundColor3 = C.Red
		end
		self.combatDefendBtn.BackgroundColor3 = C.Purple
		self.combatRunBtn.BackgroundColor3 = C.Gray600
		
		self.combatRound.Text = "âš”ï¸ ROUND " .. self.combatState.round
		self:combatShowPhase("location")
	end
end

function Minigames:combatShowEnd()
	local state = self.combatState
	
	if state.won then
		if state.knockout then
			self.combatEndEmoji.Text = "ğŸ†"
			self.combatEndTitle.Text = "KNOCKOUT VICTORY!"
			self.combatEndTitle.TextColor3 = C.Green
			self.combatEndText.Text = "You knocked them out cold! They hit the ground hard and aren't getting back up."
		else
			self.combatEndEmoji.Text = "âœŠ"
			self.combatEndTitle.Text = "YOU WON!"
			self.combatEndTitle.TextColor3 = C.Green
			self.combatEndText.Text = "After a tough battle, you emerged victorious. They couldn't take any more."
		end
	elseif state.escaped then
		self.combatEndEmoji.Text = "ğŸƒ"
		self.combatEndTitle.Text = "ESCAPED!"
		self.combatEndTitle.TextColor3 = C.Amber
		self.combatEndText.Text = "You managed to get away before things got worse. Living to fight another day."
	else
		if state.knockout then
			self.combatEndEmoji.Text = "ğŸ’«"
			self.combatEndTitle.Text = "KNOCKED OUT!"
			self.combatEndTitle.TextColor3 = C.Red
			self.combatEndText.Text = "Everything went black. You wake up on the ground, battered and bruised."
		else
			self.combatEndEmoji.Text = "ğŸ˜µ"
			self.combatEndTitle.Text = "YOU LOST"
			self.combatEndTitle.TextColor3 = C.Red
			self.combatEndText.Text = "They beat you badly. You couldn't take any more and had to give up."
		end
	end
	
	-- Stats
	local accuracy = state.stats.attacksThrown > 0 and math.floor((state.stats.attacksLanded / state.stats.attacksThrown) * 100) or 0
	self.combatEndStats.Text = string.format(
		"ğŸ“Š FIGHT STATS\nRounds: %d | Attacks: %d/%d (%d%% acc)\nDamage Dealt: %d | Damage Taken: %d | Critical Hits: %d",
		state.round,
		state.stats.attacksLanded,
		state.stats.attacksThrown,
		accuracy,
		state.stats.damageDealt,
		state.stats.damageTaken,
		state.stats.criticalHits
	)
	
	self:combatShowPhase("end")
end

function Minigames:combatEnd()
	local state = self.combatState
	self.activeGame = nil
	self.combatOverlay.Visible = false
	
	-- Disconnect all
	for _, conn in pairs(self._combatConnections) do
		if typeof(conn) == "RBXScriptConnection" then
			conn:Disconnect()
		end
	end
	self._combatConnections = {}
	
	if self.callback then
		self.callback(state.won or state.escaped, {
			won = state.won,
			escaped = state.escaped,
			knockout = state.knockout,
			rounds = state.round,
			damageDealt = state.stats.damageDealt,
			damageTaken = state.stats.damageTaken,
			finalHealth = state.playerHealth,
			opponentFinalHealth = state.oppHealth,
			stats = state.stats,
		})
		self.callback = nil
	end
end

function Minigames:startCombat(callback, options)
	options = options or {}
	print("[Minigames] ğŸ‘Š Starting COMBAT minigame!")
	
	self.callback = callback
	self.combatOverlay.Visible = true
	self.activeGame = "combat"
	
	-- Pick context and opponent
	local context = options.context
	if not context then
		context = CombatContexts[math.random(#CombatContexts)]
	elseif type(context) == "string" then
		for _, c in ipairs(CombatContexts) do
			if c.id == context then context = c break end
		end
	end
	
	local opponent = options.opponent
	if not opponent then
		local difficulty = options.difficulty or "average"
		for _, o in ipairs(CombatOpponents) do
			if o.id == difficulty then opponent = o break end
		end
		if not opponent then
			opponent = CombatOpponents[2] -- average
		end
	end
	
	-- Initialize combat state
	self.combatState = {
		context = context,
		opponent = opponent,
		round = 1,
		playerHealth = 100,
		oppHealth = math.floor(100 * opponent.healthMod),
		oppMaxHealth = math.floor(100 * opponent.healthMod),
		selectedLocation = nil,
		selectedAttack = nil,
		wasBlocking = false,
		combatEnded = false,
		won = false,
		escaped = false,
		knockout = false,
		stats = {
			attacksThrown = 0,
			attacksLanded = 0,
			damageDealt = 0,
			damageTaken = 0,
			criticalHits = 0,
			knockouts = 0,
		}
	}
	
	-- Set up UI (CRITICAL FIX: Guard against nil values)
	self.combatTitle.Text = (context.emoji or "âš”ï¸") .. " " .. (context.title or "Fight")
	self.combatNarrative.Text = (context.desc or "A fight breaks out!") .. "\n\nYou're facing " .. (opponent.desc or "an opponent") .. "."
	self.oppNameLabel.Text = "ğŸ˜¤ " .. string.upper(opponent.name or "OPPONENT")
	self.combatRound.Text = "âš”ï¸ ROUND 1"
	
	-- Reset health bars
	self.playerHealthBar.Size = UDim2.new(1, 0, 1, 0)
	self.oppHealthBar.Size = UDim2.new(1, 0, 1, 0)
	self.playerHealthText.Text = "100 HP"
	self.oppHealthText.Text = self.combatState.oppMaxHealth .. " HP"
	self.playerHealthBar.BackgroundColor3 = C.Green
	self.playerHealthText.TextColor3 = C.Green
	
	-- Reset button colors
	for _, item in ipairs(self.combatLocationBtns) do
		item.btn.BackgroundColor3 = C.Blue
	end
	for _, item in ipairs(self.combatAttackBtns) do
		item.btn.BackgroundColor3 = C.Red
	end
	self.combatDefendBtn.BackgroundColor3 = C.Purple
	self.combatRunBtn.BackgroundColor3 = C.Gray600
	
	-- Hide end panel
	self.combatEndFrame.Visible = false
	
	-- Show location selection
	self:combatShowPhase("location")
	
	-- Wire up buttons
	for _, item in ipairs(self.combatLocationBtns) do
		local conn = item.btn.MouseButton1Click:Connect(function()
			self:combatSelectLocation(item.data)
		end)
		table.insert(self._combatConnections, conn)
	end
	
	for _, item in ipairs(self.combatAttackBtns) do
		local conn = item.btn.MouseButton1Click:Connect(function()
			self:combatSelectAttack(item.data)
		end)
		table.insert(self._combatConnections, conn)
	end
	
	table.insert(self._combatConnections, self.combatDefendBtn.MouseButton1Click:Connect(function()
		self:combatDefend()
	end))
	
	table.insert(self._combatConnections, self.combatRunBtn.MouseButton1Click:Connect(function()
		self:combatRun()
	end))
	
	table.insert(self._combatConnections, self.combatContinueBtn.MouseButton1Click:Connect(function()
		self:combatContinue()
	end))
	
	table.insert(self._combatConnections, self.combatEndBtn.MouseButton1Click:Connect(function()
		self:combatEnd()
	end))
end

return Minigames
