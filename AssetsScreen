-- AssetsScreen.lua
-- Premium BitLife-style Assets & Shop screen
-- Triple AAA polished UI for managing assets and purchases

local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local UI = require(ReplicatedStorage:WaitForChild("UIComponents"))
local C = UI.Colors or {}
local F = UI.Fonts or {}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FONT SAFETY - CRITICAL FIX #953 (REVISED)
-- Ensure ALL fonts exist so Font property never gets nil!
-- Error was: "Unable to assign property Font. EnumItem, number, or string expected, got nil"
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local DEFAULT_FONT = Enum.Font.SourceSans

-- CRITICAL FIX: Force-initialize F table - completely rebuild it
F = {}

-- CRITICAL FIX: Use pcall to safely try each font with multiple fallbacks
local function tryFont(...)
	local fonts = {...}
	for _, fontName in ipairs(fonts) do
		local success, font = pcall(function()
			return Enum.Font[fontName]
		end)
		if success and font then
			return font
		end
	end
	return DEFAULT_FONT
end

-- Set all fonts with safe fallback chain
F.Title  = tryFont("GothamBold", "GothamBlack", "SourceSansBold", "SourceSans")
F.Body   = tryFont("Gotham", "GothamMedium", "SourceSans")
F.Medium = tryFont("GothamMedium", "Gotham", "SourceSans")
F.Button = tryFont("GothamBold", "GothamSemibold", "SourceSansBold", "SourceSans")
F.Bold   = tryFont("GothamBold", "GothamBlack", "SourceSansBold", "SourceSans")

-- CRITICAL FIX: Triple-check all fonts are valid
for key, value in pairs(F) do
	if not value or type(value) ~= "userdata" then
		F[key] = DEFAULT_FONT
	end
end

-- CRITICAL FIX: Final fallback - directly assign if still nil
F.Bold = F.Bold or DEFAULT_FONT
F.Medium = F.Medium or DEFAULT_FONT
F.Body = F.Body or DEFAULT_FONT
F.Title = F.Title or DEFAULT_FONT
F.Button = F.Button or DEFAULT_FONT

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- COLOR SAFETY
-- Ensure ALL colors exist so TextColor3/BackgroundColor3 never get nil.
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Base colors
C.Green      = C.Green      or Color3.fromRGB(34, 197, 94)
C.Red        = C.Red        or Color3.fromRGB(239, 68, 68)
C.Purple     = C.Purple     or Color3.fromRGB(139, 92, 246)
C.Blue       = C.Blue       or Color3.fromRGB(59, 130, 246)
C.Teal       = C.Teal       or Color3.fromRGB(20, 184, 166)
C.Amber      = C.Amber      or Color3.fromRGB(245, 158, 11)
C.Gold       = C.Gold       or Color3.fromRGB(251, 191, 36)
C.White      = C.White      or Color3.fromRGB(255, 255, 255)
C.Black      = C.Black      or Color3.fromRGB(0, 0, 0)

-- Dark variants
C.GreenDark  = C.GreenDark  or Color3.fromRGB(22, 163, 74)
C.RedDark    = C.RedDark    or Color3.fromRGB(185, 28, 28)
C.PurpleDark = C.PurpleDark or Color3.fromRGB(109, 40, 217)
C.BlueDark   = C.BlueDark   or Color3.fromRGB(29, 78, 216)
C.TealDark   = C.TealDark   or Color3.fromRGB(13, 148, 136)
C.AmberDark  = C.AmberDark  or Color3.fromRGB(217, 119, 6)
C.GoldDark   = C.GoldDark   or Color3.fromRGB(217, 119, 6)

-- Pale variants
C.GreenPale  = C.GreenPale  or Color3.fromRGB(220, 252, 231)
C.RedPale    = C.RedPale    or Color3.fromRGB(254, 226, 226)
C.BluePale   = C.BluePale   or Color3.fromRGB(219, 234, 254)
C.PurplePale = C.PurplePale or Color3.fromRGB(237, 233, 254)
C.TealPale   = C.TealPale   or Color3.fromRGB(204, 251, 241)
C.AmberPale  = C.AmberPale  or Color3.fromRGB(254, 243, 199)

-- Grays
C.Gray50     = C.Gray50     or Color3.fromRGB(249, 250, 251)
C.Gray100    = C.Gray100    or Color3.fromRGB(243, 244, 246)
C.Gray200    = C.Gray200    or Color3.fromRGB(229, 231, 235)
C.Gray300    = C.Gray300    or Color3.fromRGB(209, 213, 219)
C.Gray400    = C.Gray400    or Color3.fromRGB(156, 163, 175)
C.Gray500    = C.Gray500    or Color3.fromRGB(107, 114, 128)
C.Gray600    = C.Gray600    or Color3.fromRGB(75, 85, 99)
C.Gray700    = C.Gray700    or Color3.fromRGB(55, 65, 81)
C.Gray800    = C.Gray800    or Color3.fromRGB(31, 41, 55)
C.Gray900    = C.Gray900    or Color3.fromRGB(17, 24, 39)

-- Extra safety colors
C.Bg         = C.Bg         or Color3.fromRGB(246, 248, 252)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- MOBILE RESPONSIVE SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera

-- CRITICAL FIX: Added IS_TINY_PHONE for ultra-small phones like iPhone SE
local IS_MOBILE = UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
local IS_TABLET = IS_MOBILE and (Camera.ViewportSize.X >= 768 or Camera.ViewportSize.Y >= 768)
local IS_SMALL_PHONE = IS_MOBILE and not IS_TABLET and (Camera.ViewportSize.X < 400 or Camera.ViewportSize.Y < 700)
local IS_TINY_PHONE = IS_MOBILE and not IS_TABLET and (Camera.ViewportSize.X <= 380 or Camera.ViewportSize.Y <= 680)
local ViewportSize = Camera.ViewportSize

-- CRITICAL UI FIX: More aggressive scaling for small phones
local function getScale()
	local minDim = math.min(ViewportSize.X, ViewportSize.Y)
	if minDim < 350 then return 0.55 end  -- SUPER TINY phones
	if minDim < 380 then return 0.65 end  -- TINY phones like iPhone SE
	if minDim < 400 then return 0.72 end  -- Small phones
	if minDim < 500 then return 0.85 end
	if minDim < 768 then return 0.95 end
	return 1.0
end

local function px(baseValue) return math.floor(baseValue * getScale()) end

-- CRITICAL FIX: Better text sizing for tiny phones - more readable
local function textSize(baseSize) 
	local minSize = IS_TINY_PHONE and 10 or (IS_SMALL_PHONE and 11 or 12)
	return math.max(minSize, math.floor(baseSize * getScale())) 
end

-- CRITICAL FIX: More padding/spacing on small screens to reduce bunching
local function padSize(base) 
	if IS_TINY_PHONE then return math.max(4, math.floor(base * 0.6)) end
	if IS_SMALL_PHONE then return math.max(5, math.floor(base * 0.75)) end
	return math.floor(base * getScale())
end

-- CRITICAL FIX: Card heights that scale properly
local function cardHeight(baseHeight)
	if IS_TINY_PHONE then return math.max(70, math.floor(baseHeight * 0.7)) end
	if IS_SMALL_PHONE then return math.max(80, math.floor(baseHeight * 0.85)) end
	return baseHeight
end

-- CRITICAL FIX: Proper minimum touch target for tiny phones
local function btnHeight(baseHeight)
	local scaled = math.floor(baseHeight * getScale())
	local minTarget = IS_TINY_PHONE and 36 or (IS_SMALL_PHONE and 40 or 44)
	return IS_MOBILE and math.max(minTarget, scaled) or scaled
end

local function cardWidth()
	if IS_TINY_PHONE then return ViewportSize.X - 8 end
	if IS_SMALL_PHONE then return ViewportSize.X - 12 end
	if IS_MOBILE then return math.min(ViewportSize.X - 20, 350) end
	return 350
end

-- CRITICAL FIX: Icon sizes that scale for small phones
local function iconSize(base)
	if IS_TINY_PHONE then return math.max(36, math.floor(base * 0.62)) end
	if IS_SMALL_PHONE then return math.max(42, math.floor(base * 0.75)) end
	return base
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- PREMIUM EMPTY STATE CARD HELPER
-- Creates a polished empty state card with icon, message, and optional action
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local function createPremiumEmptyCard(parent, options)
	options = options or {}
	local emoji = options.emoji or "ðŸ“­"
	local title = options.title or "Nothing Here"
	local message = options.message or "No items to display."
	local accentColor = options.accentColor or C.Gray400
	local layoutOrder = options.layoutOrder or 1
	local actionText = options.actionText
	local actionCallback = options.actionCallback
	
	-- Container
	local container = Instance.new("Frame")
	container.Name = "EmptyStateCard"
	container.Size = UDim2.new(1, 0, 0, actionText and 170 or 140)
	container.BackgroundTransparency = 1
	container.LayoutOrder = layoutOrder
	container.ZIndex = 82
	container.Parent = parent
	
	-- Shadow
	local shadow = Instance.new("Frame")
	shadow.Size = UDim2.new(1, 4, 1, 4)
	shadow.Position = UDim2.new(0, 2, 0, 2)
	shadow.BackgroundColor3 = C.Black
	shadow.BackgroundTransparency = 0.94
	shadow.ZIndex = 82
	shadow.Parent = container
	UI.corner(shadow, 20)
	
	-- Shell (subtle accent)
	local shell = Instance.new("Frame")
	shell.Size = UDim2.fromScale(1, 1)
	shell.BackgroundColor3 = accentColor:Lerp(C.White, 0.6)
	shell.ZIndex = 83
	shell.Parent = container
	UI.corner(shell, 18)
	
	-- Inner card
	local card = Instance.new("Frame")
	card.Size = UDim2.new(1, -4, 1, -4)
	card.Position = UDim2.new(0, 2, 0, 2)
	card.BackgroundColor3 = C.White
	card.ZIndex = 84
	card.Parent = shell
	UI.corner(card, 16)
	
	-- Emoji icon with circle background
	local iconCircle = Instance.new("Frame")
	iconCircle.Size = UDim2.new(0, 56, 0, 56)
	iconCircle.AnchorPoint = Vector2.new(0.5, 0)
	iconCircle.Position = UDim2.new(0.5, 0, 0, 14)
	iconCircle.BackgroundColor3 = accentColor:Lerp(C.White, 0.85)
	iconCircle.ZIndex = 85
	iconCircle.Parent = card
	UI.corner(iconCircle, 28)
	
	local iconLabel = Instance.new("TextLabel")
	iconLabel.Size = UDim2.fromScale(1, 1)
	iconLabel.BackgroundTransparency = 1
	iconLabel.Font = F.Body
	iconLabel.TextSize = 26
	iconLabel.Text = emoji
	iconLabel.ZIndex = 86
	iconLabel.Parent = iconCircle
	
	-- Title
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Size = UDim2.new(1, -32, 0, 22)
	titleLabel.AnchorPoint = Vector2.new(0.5, 0)
	titleLabel.Position = UDim2.new(0.5, 0, 0, 74)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Font = F.Title
	titleLabel.TextSize = 15
	titleLabel.TextColor3 = C.Gray700
	titleLabel.Text = title
	titleLabel.ZIndex = 85
	titleLabel.Parent = card
	
	-- Message
	local messageLabel = Instance.new("TextLabel")
	messageLabel.Size = UDim2.new(1, -32, 0, 28)
	messageLabel.AnchorPoint = Vector2.new(0.5, 0)
	messageLabel.Position = UDim2.new(0.5, 0, 0, 96)
	messageLabel.BackgroundTransparency = 1
	messageLabel.Font = F.Body
	messageLabel.TextSize = 12
	messageLabel.TextColor3 = C.Gray500
	messageLabel.TextWrapped = true
	messageLabel.Text = message
	messageLabel.ZIndex = 85
	messageLabel.Parent = card
	
	-- Optional action button
	if actionText and actionCallback then
		local actionBtn = Instance.new("TextButton")
		actionBtn.Size = UDim2.new(0.6, 0, 0, 32)
		actionBtn.AnchorPoint = Vector2.new(0.5, 0)
		actionBtn.Position = UDim2.new(0.5, 0, 0, 128)
		actionBtn.BackgroundColor3 = accentColor
		actionBtn.Font = F.Button
		actionBtn.TextSize = 12
		actionBtn.TextColor3 = C.White
		actionBtn.Text = actionText
		actionBtn.AutoButtonColor = false
		actionBtn.ZIndex = 86
		actionBtn.Parent = card
		UI.corner(actionBtn, 8)
		
		actionBtn.MouseEnter:Connect(function()
			UI.tween(actionBtn, TweenInfo.new(0.12), {
				BackgroundColor3 = accentColor:Lerp(C.Black, 0.15)
			})
		end)
		actionBtn.MouseLeave:Connect(function()
			UI.tween(actionBtn, TweenInfo.new(0.12), { BackgroundColor3 = accentColor })
		end)
		actionBtn.MouseButton1Click:Connect(actionCallback)
	end
	
	return container
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

local AssetsScreen = {}
AssetsScreen.__index = AssetsScreen

-- CRITICAL DEBUG: Track module initialization
print("[AssetsScreen] âœ“ Module table created")

-- Debug logging
local DEBUG = false
local function log(...)
	if DEBUG then print("[AssetsScreen]", ...) end
end
local function logWarn(...)
	warn("[AssetsScreen]", ...)
end

-- Deep debug for asset tracing
local function debugAssets(assets, label)
	if not DEBUG then return end
	label = label or "Assets"
	print("[AssetsScreen] === " .. label .. " DEBUG ===")
	if not assets then
		print("[AssetsScreen]   Assets table is NIL")
		return
	end
	if type(assets) ~= "table" then
		print("[AssetsScreen]   Assets is not a table, type:", type(assets))
		return
	end
	
	local categories = {"Properties", "Vehicles", "Items", "Crypto", "Investments", "Businesses"}
	for _, cat in ipairs(categories) do
		local bucket = assets[cat]
		if bucket then
			print("[AssetsScreen]   " .. cat .. ": " .. #bucket .. " items")
			for i, item in ipairs(bucket) do
				print("[AssetsScreen]     [" .. i .. "] id=" .. tostring(item.id) .. " name=" .. tostring(item.name))
			end
		else
			print("[AssetsScreen]   " .. cat .. ": (nil)")
		end
	end
	print("[AssetsScreen] === END DEBUG ===")
end

-- Remotes (optimized - fast lookup)
local remotesFolder = ReplicatedStorage:FindFirstChild("LifeRemotes") or ReplicatedStorage:WaitForChild("LifeRemotes", 3)
local function getRemote(name)
	return remotesFolder and (remotesFolder:FindFirstChild(name) or remotesFolder:WaitForChild(name, 1))
end
local BuyProperty = getRemote("BuyProperty")
local BuyVehicle = getRemote("BuyVehicle")
local BuyItem = getRemote("BuyItem")
local SellAsset = getRemote("SellAsset")
local Gamble = getRemote("Gamble")

-- Asset Data - MUST match server IDs in LifeRemoteHandlers!
-- CRITICAL FIX #USER-6: Enhanced with happiness bonuses, maintenance, and effects!
local Properties = {
	{ id = "studio", name = "Studio Apartment", emoji = "ðŸ¢", price = 85000, income = 500, happiness = 2, maintenance = 1200, desc = "Cozy studio - +2 Happiness/yr", minAge = 18 },
	{ id = "1br_condo", name = "1BR Condo", emoji = "ðŸ¬", price = 175000, income = 1000, happiness = 4, maintenance = 2000, desc = "Modern condo - +4 Happiness/yr", minAge = 18 },
	{ id = "family_house", name = "Family House", emoji = "ðŸ ", price = 350000, income = 2000, happiness = 6, maintenance = 4000, desc = "3 bed, 2 bath - +6 Happiness/yr", minAge = 18 },
	{ id = "beach_house", name = "Beach House", emoji = "ðŸ–ï¸", price = 1200000, income = 5000, happiness = 10, maintenance = 8000, desc = "Ocean views - +10 Happiness/yr, +5 Fame", minAge = 21 },
	{ id = "penthouse", name = "Luxury Penthouse", emoji = "ðŸŒ†", price = 2500000, income = 10000, happiness = 15, maintenance = 15000, desc = "Top floor luxury - +15 Happiness/yr, +10 Fame", minAge = 21 },
	{ id = "mansion", name = "Mansion", emoji = "ðŸ°", price = 8500000, income = 25000, happiness = 25, maintenance = 35000, desc = "Dream home - +25 Happiness/yr, +20 Fame, +Status", minAge = 21 },
}

-- CRITICAL FIX #USER-6: All vehicles now show their ACTUAL gameplay effects!
local Vehicles = {
	{ id = "used_civic", name = "Used Honda Civic", emoji = "ðŸš—", price = 8000, happiness = 1, maintenance = 800, desc = "+1 Happiness/yr, $800 upkeep", minAge = 16 },
	{ id = "camry", name = "Toyota Camry", emoji = "ðŸš™", price = 28000, happiness = 2, maintenance = 1500, desc = "+2 Happiness/yr, $1.5K upkeep", minAge = 16 },
	{ id = "bmw", name = "BMW 3 Series", emoji = "ðŸš˜", price = 55000, happiness = 4, maintenance = 3000, desc = "+4 Happiness/yr, +2 Status", minAge = 18 },
	{ id = "tesla", name = "Tesla Model S", emoji = "âš¡", price = 95000, happiness = 5, maintenance = 2000, desc = "+5 Happiness/yr, +3 Status, No gas!", minAge = 18 },
	{ id = "porsche", name = "Porsche 911", emoji = "ðŸŽï¸", price = 180000, happiness = 8, maintenance = 8000, desc = "+8 Happiness/yr, +5 Fame, +8 Status", minAge = 21 },
	{ id = "lambo", name = "Lamborghini", emoji = "ðŸ¦", price = 300000, happiness = 12, maintenance = 15000, desc = "+12 Happiness/yr, +10 Fame, SUPERCAR!", minAge = 21 },
	{ id = "ferrari", name = "Ferrari F8", emoji = "ðŸŽ", price = 350000, happiness = 15, maintenance = 18000, desc = "+15 Happiness/yr, +12 Fame, ELITE!", minAge = 21 },
	{ id = "yacht", name = "Yacht", emoji = "ðŸ›¥ï¸", price = 2000000, happiness = 20, maintenance = 50000, desc = "+20 Happiness/yr, +20 Fame, LUXURY LIFE!", minAge = 25 },
	{ id = "jet", name = "Private Jet", emoji = "âœˆï¸", price = 15000000, happiness = 35, maintenance = 200000, desc = "+35 Happiness/yr, +50 Fame, BILLIONAIRE!", minAge = 25 },
}

-- CRITICAL FIX #USER-6: Shop items now show their effects!
local Shop = {
	{ id = "sneakers", name = "Sneakers", emoji = "ðŸ‘Ÿ", price = 350, happiness = 1, desc = "+1 Happiness, +1 Looks", minAge = 10 },
	{ id = "iphone", name = "iPhone", emoji = "ðŸ“±", price = 1200, happiness = 2, desc = "+2 Happiness, Stay connected!", minAge = 10 },
	{ id = "bag", name = "Designer Bag", emoji = "ðŸ‘œ", price = 2500, happiness = 2, desc = "+2 Happiness, +3 Looks, +1 Fame", minAge = 14 },
	{ id = "gaming_pc", name = "Gaming PC", emoji = "ðŸ–¥ï¸", price = 3000, happiness = 3, desc = "+3 Happiness, +2 Smarts (research!)", minAge = 10 },
	{ id = "necklace", name = "Gold Necklace", emoji = "ðŸ“¿", price = 3500, happiness = 2, desc = "+2 Happiness, +2 Looks, +1 Fame", minAge = 16 },
	{ id = "watch", name = "Designer Watch", emoji = "âŒš", price = 5000, happiness = 3, desc = "+3 Happiness, +3 Looks, +2 Fame", minAge = 16 },
	{ id = "ring", name = "Diamond Ring", emoji = "ðŸ’", price = 15000, happiness = 5, desc = "+5 Happiness, +5 Looks, +3 Fame", minAge = 18 },
	{ id = "piano", name = "Grand Piano", emoji = "ðŸŽ¹", price = 50000, happiness = 8, desc = "+8 Happiness, +5 Smarts, Music skill!", minAge = 18 },
}

-- CRITICAL DEBUG: Track .new function definition
print("[AssetsScreen] âœ“ About to define .new function")

function AssetsScreen.new(screenGui, blurOverlay, showBlurFunc, hideBlurFunc, playerState)
	print("[AssetsScreen] âœ“ .new function called")
	log("=== CREATING AssetsScreen ===")
	local self = setmetatable({}, AssetsScreen)
	self.screenGui = screenGui
	self.playerState = playerState or {}
	self.showBlur = showBlurFunc
	self.hideBlur = hideBlurFunc
	self.isVisible = false
	self.currentTab = "property"
	log("Initial state - Age:", self:getAge(), "Money:", self:getMoney())
	self:createUI()
	log("âœ… AssetsScreen created successfully")
	return self
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- UI STATE HEALER FOR ASSETS
-- Validates asset display state is consistent before rendering
-- Prevents ghost properties, duplicate assets, and invalid housing states
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function AssetsScreen:healUIState(state)
	if not state then return end
	
	local flags = state.Flags or {}
	local healed = 0
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- HOUSING DISPLAY VALIDATION
	-- Palace should only display for actual royalty
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local isRoyal = flags.is_royalty or flags.royal_birth or
		(state.RoyalState and state.RoyalState.isRoyal)
	
	if state.HousingState then
		if state.HousingState.status == "royal_palace" and not isRoyal then
			log("[UIStateHealer] Ghost palace in HousingState - player not royal")
			-- Let backend RVS fix this, just note it
			healed = healed + 1
		end
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- DUPLICATE PROPERTY DETECTION
	-- Remove duplicate entries from the display
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	if state.Assets and state.Assets.Properties then
		local seen = {}
		local uniqueCount = 0
		for _, prop in ipairs(state.Assets.Properties) do
			local key = prop.id or prop.name or "unknown"
			if not seen[key] then
				seen[key] = true
				uniqueCount = uniqueCount + 1
			end
		end
		if uniqueCount < #state.Assets.Properties then
			log("[UIStateHealer] Duplicate properties detected - will be cleaned by RVS")
			healed = healed + 1
		end
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- OWNS_PROPERTY FLAG SYNC
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local hasRealProperty = state.Assets and state.Assets.Properties and #state.Assets.Properties > 0
	if flags.owns_property and not hasRealProperty then
		log("[UIStateHealer] Ghost owns_property flag - no actual properties")
		healed = healed + 1
	end
	
	if healed > 0 then
		log(string.format("[UIStateHealer] Detected %d asset state issues", healed))
	end
	
	return healed
end

function AssetsScreen:updateState(newState)
	log("=== UPDATE STATE CALLED ===")
	if newState then 
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX #26: Detect new life and reset assets view
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		local wasAge = self.playerState and self.playerState.Age or 0
		local newAge = newState.Age or 0
		local isNewLife = (wasAge > 5 and newAge <= 1)
		
		self.playerState = newState
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- RUN UI STATE HEALER before rendering
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		self:healUIState(newState)
		log("State updated - Age:", self:getAge(), "Money:", self:getMoney())
		
		-- CRITICAL DEBUG: Trace the Assets field
		if newState.Assets then
			debugAssets(newState.Assets, "Incoming State Assets")
		else
			log("WARNING: newState.Assets is NIL or missing!")
			log("newState keys:", table.concat((function()
				local keys = {}
				for k, _ in pairs(newState) do
					table.insert(keys, tostring(k))
				end
				return keys
			end)(), ", "))
		end
		
		-- Force refresh on new life to clear old assets display
		if isNewLife then
			log("ðŸ”„ NEW LIFE DETECTED! Forcing assets UI refresh")
			self.currentTab = "shop" -- Reset to shop tab for new life (baby has no assets)
		end
		
		-- Auto-refresh the current tab if screen is visible
		-- This ensures assets added by events appear immediately
		if self.isVisible then
			self:updateBalanceBar()
			if self.currentTab == "property" then
				self:populateProperty()
			elseif self.currentTab == "vehicles" then
				self:populateVehicles()
			else
				self:populateShop()
			end
		end
	else
		log("WARNING: updateState called with nil newState!")
	end
end

function AssetsScreen:getAge()
	local state = self.playerState
	if not state then return 0 end
	return state.Age or (state.Stats and state.Stats.Age) or 0
end

function AssetsScreen:getMoney()
	local state = self.playerState
	if not state then return 0 end
	return state.Money or (state.Stats and state.Stats.Money) or 0
end

-- CRITICAL FIX: Added formatMoney method for displaying money values
function AssetsScreen:formatMoney(amount)
	if not amount or amount == 0 then return "0" end
	local negative = amount < 0
	amount = math.abs(amount)
	
	-- Format with commas
	local formatted = tostring(math.floor(amount))
	local k
	while true do
		formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", "%1,%2")
		if k == 0 then break end
	end
	
	return negative and "-" .. formatted or formatted
end

function AssetsScreen:getAssets()
	local state = self.playerState
	if not state then return {} end

	-- Assets is now structured: { Properties = [...], Vehicles = [...], Items = [...] }
	-- Flatten into a lookup table by id for easy checking
	local assets = state.Assets or {}
	local flatAssets = {}

	-- Flatten Properties
	if assets.Properties then
		for _, prop in ipairs(assets.Properties) do
			flatAssets[prop.id] = prop
			log("Found owned property:", prop.id, prop.name or "")
		end
	end

	-- Flatten Vehicles
	if assets.Vehicles then
		for _, veh in ipairs(assets.Vehicles) do
			flatAssets[veh.id] = veh
			log("Found owned vehicle:", veh.id, veh.name or "")
		end
	end

	-- Flatten Items
	if assets.Items then
		for _, itm in ipairs(assets.Items) do
			flatAssets[itm.id] = itm
			log("Found owned item:", itm.id, itm.name or "")
		end
	end

	-- Flatten Crypto
	if assets.Crypto then
		for _, crypto in ipairs(assets.Crypto) do
			flatAssets[crypto.id] = crypto
		end
	end

	-- CRITICAL FIX: Count table entries properly (# only works for arrays, not hash tables)
	local count = 0
	for _ in pairs(flatAssets) do
		count = count + 1
	end
	log("Total owned assets:", count)
	return flatAssets
end

function AssetsScreen:getOwnedList(assetType)
	local state = self.playerState
	if not state or not state.Assets then return {} end

	local assets = state.Assets
	if assetType == "property" then
		return assets.Properties or {}
	elseif assetType == "vehicle" then
		return assets.Vehicles or {}
	elseif assetType == "item" then
		return assets.Items or {}
	elseif assetType == "crypto" then
		return assets.Crypto or {}
	end
	return {}
end

function AssetsScreen:createUI()
	-- Main overlay
	self.overlay = Instance.new("Frame")
	self.overlay.Name = "AssetsOverlay"
	self.overlay.Size = UDim2.fromScale(1, 1)
	self.overlay.BackgroundColor3 = C.Bg
	self.overlay.Visible = false
	self.overlay.ZIndex = 80
	self.overlay.Parent = self.screenGui

	-- Premium header
	local headerData = UI.createScreenHeader(self.overlay, {
		title = "ðŸ  Assets & Shop",
		color = C.Teal,
		colorDark = C.TealDark,
		zIndex = 85
	})
	headerData.closeButton.MouseButton1Click:Connect(function() self:hide() end)
	headerData.closeButton.MouseEnter:Connect(function()
		UI.tween(headerData.closeButton, TweenInfo.new(0.12), { BackgroundTransparency = 0 })
	end)
	headerData.closeButton.MouseLeave:Connect(function()
		UI.tween(headerData.closeButton, TweenInfo.new(0.12), { BackgroundTransparency = 0.1 })
	end)

	-- CRITICAL FIX: Balance bar - clean card design that fits naturally below header
	-- Uses a white card with teal accent, positioned to look integrated
	-- CRITICAL FIX: IS_TINY_PHONE responsive sizing
	-- CRITICAL FIX #700: Increased Y positions to prevent overlap with header
	local balanceBarHeight = IS_TINY_PHONE and 42 or 54
	local balanceBarY = IS_TINY_PHONE and 110 or 145  -- INCREASED from 100/130 to prevent text cutoff
	local balanceBarMargin = IS_TINY_PHONE and 8 or 12
	
	self.balanceBar = Instance.new("Frame")
	self.balanceBar.Name = "BalanceBar"
	self.balanceBar.Size = UDim2.new(1, -balanceBarMargin * 2, 0, balanceBarHeight) -- Full width minus margins
	self.balanceBar.Position = UDim2.new(0, balanceBarMargin, 0, balanceBarY) -- Below header curve (header extends to ~120px)
	self.balanceBar.BackgroundColor3 = C.White
	self.balanceBar.BorderSizePixel = 0
	self.balanceBar.ZIndex = 84
	self.balanceBar.Parent = self.overlay
	UI.corner(self.balanceBar, 12)
	UI.stroke(self.balanceBar, 1, 0.85, C.TealPale)
	
	-- Teal accent bar on left edge
	local accentBar = Instance.new("Frame")
	accentBar.Name = "AccentBar"
	accentBar.Size = UDim2.new(0, 4, 1, -12)
	accentBar.Position = UDim2.new(0, 6, 0, 6)
	accentBar.BackgroundColor3 = C.Teal
	accentBar.ZIndex = 85
	accentBar.Parent = self.balanceBar
	UI.corner(accentBar, 2)
	
	-- Money icon in a circular badge
	local iconBadge = Instance.new("Frame")
	iconBadge.Name = "IconBadge"
	iconBadge.Size = UDim2.new(0, 36, 0, 36)
	iconBadge.Position = UDim2.new(0, 18, 0.5, -18)
	iconBadge.BackgroundColor3 = C.TealPale or Color3.fromRGB(209, 250, 229)
	iconBadge.ZIndex = 85
	iconBadge.Parent = self.balanceBar
	UI.corner(iconBadge, 18)
	
	local balanceIcon = Instance.new("TextLabel")
	balanceIcon.Name = "Icon"
	balanceIcon.Size = UDim2.fromScale(1, 1)
	balanceIcon.BackgroundTransparency = 1
	balanceIcon.Font = F.Body
	balanceIcon.TextSize = 20
	balanceIcon.Text = "ðŸ’°"
	balanceIcon.ZIndex = 86
	balanceIcon.Parent = iconBadge
	
	-- Balance label and value stacked
	local balanceLabel = Instance.new("TextLabel")
	balanceLabel.Name = "Label"
	balanceLabel.Size = UDim2.new(0.5, 0, 0, 14)
	balanceLabel.Position = UDim2.new(0, 62, 0, 10)
	balanceLabel.BackgroundTransparency = 1
	balanceLabel.Font = F.Medium
	balanceLabel.TextSize = 10
	balanceLabel.TextColor3 = C.Gray500 or Color3.fromRGB(107, 114, 128)
	balanceLabel.TextXAlignment = Enum.TextXAlignment.Left
	balanceLabel.Text = "YOUR BALANCE"
	balanceLabel.ZIndex = 86
	balanceLabel.Parent = self.balanceBar

	self.balanceValue = Instance.new("TextLabel")
	self.balanceValue.Name = "Value"
	self.balanceValue.Size = UDim2.new(0.6, 0, 0, 22)
	self.balanceValue.Position = UDim2.new(0, 62, 0, 24)
	self.balanceValue.BackgroundTransparency = 1
	self.balanceValue.Font = F.Title
	self.balanceValue.TextSize = 19
	self.balanceValue.TextColor3 = C.TealDark or Color3.fromRGB(17, 94, 89)
	self.balanceValue.TextXAlignment = Enum.TextXAlignment.Left
	self.balanceValue.Text = "$0"
	self.balanceValue.ZIndex = 86
	self.balanceValue.Parent = self.balanceBar

	-- REMOVED: Casino button (per user request)
	-- Casino/gambling feature removed from AssetsScreen

	-- Tab bar - CRITICAL FIX: Positioned below balance bar with proper spacing
	-- Balance bar is at Y=145 with height 54, ends at Y=199. Tab bar starts at 211.
	-- CRITICAL FIX: IS_TINY_PHONE responsive positioning
	-- CRITICAL FIX #700: Increased Y positions to prevent bunching on mobile
	local tabBarY = IS_TINY_PHONE and 165 or 211  -- INCREASED from 150/196
	self.tabBar = UI.createTabBar(self.overlay, { topOffset = tabBarY, zIndex = 84 })
	self.tabBtns = {}

	local tabs = {
		{ id = "property", text = "ðŸ  Property", color = C.Teal },
		{ id = "vehicles", text = "ðŸš— Vehicles", color = C.Blue },
		{ id = "shop", text = "ðŸ›’ Shop", color = C.Purple }
	}

	for i, tab in ipairs(tabs) do
		local btn = UI.createTabButton(self.tabBar, {
			id = tab.id, text = tab.text, color = tab.color,
			active = i == 1, order = i, width = 0.31, zIndex = 84
		})
		self.tabBtns[tab.id] = { btn = btn, color = tab.color }
		btn.MouseButton1Click:Connect(function() self:switchTab(tab.id) end)
	end

	-- Scroll area - CRITICAL FIX: Positioned below tab bar
	-- Tab bar is at Y=211 with ~50px height, so content starts at ~281
	-- CRITICAL FIX: IS_TINY_PHONE responsive positioning
	-- CRITICAL FIX #700: Increased Y positions so Living Situation card is visible
	local contentScrollY = IS_TINY_PHONE and 215 or 281  -- INCREASED from 200/266
	self.contentScroll = UI.createScrollArea(self.overlay, { topOffset = contentScrollY, zIndex = 81 })
	
	-- CRITICAL FIX #LIVING-1: Ensure UIListLayout exists in contentScroll for proper positioning
	-- This is ESSENTIAL for LayoutOrder to work and for Living Situation card to appear first
	local existingLayout = self.contentScroll:FindFirstChildOfClass("UIListLayout")
	if not existingLayout then
		local scrollLayout = Instance.new("UIListLayout")
		scrollLayout.Name = "ContentLayout"
		scrollLayout.Padding = UDim.new(0, IS_TINY_PHONE and 8 or 12)
		scrollLayout.SortOrder = Enum.SortOrder.LayoutOrder
		scrollLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		scrollLayout.Parent = self.contentScroll
		
		-- CRITICAL: Set AutomaticCanvasSize so content is scrollable
		self.contentScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
		self.contentScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
		log("âœ… Created UIListLayout for contentScroll")
	end
	
	-- CRITICAL FIX #LIVING-2: Add padding to contentScroll for better spacing on all sides
	local existingPadding = self.contentScroll:FindFirstChildOfClass("UIPadding")
	if not existingPadding then
		local scrollPadding = Instance.new("UIPadding")
		scrollPadding.PaddingLeft = UDim.new(0, IS_TINY_PHONE and 4 or 8)
		scrollPadding.PaddingRight = UDim.new(0, IS_TINY_PHONE and 4 or 8)
		scrollPadding.PaddingTop = UDim.new(0, IS_TINY_PHONE and 6 or 10)
		scrollPadding.PaddingBottom = UDim.new(0, 20)
		scrollPadding.Parent = self.contentScroll
		log("âœ… Created UIPadding for contentScroll")
	end

	-- Modals
	self:createResultModal()
	-- REMOVED: self:createGamblingModal() - Casino feature removed

	-- Initial populate
	self:populateProperty()
end

function AssetsScreen:createResultModal()
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL REVAMP: Premium Result Modal (matching Quit Job modal style)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	self.resultModal = {}
	
	-- Close/dim overlay
	local closeArea = Instance.new("TextButton")
	closeArea.Name = "ResultModalCloseArea"
	closeArea.Size = UDim2.fromScale(1, 1)
	closeArea.BackgroundColor3 = C.Black
	closeArea.BackgroundTransparency = 0.35
	closeArea.Text = ""
	closeArea.AutoButtonColor = false
	closeArea.ZIndex = 96
	closeArea.Visible = false
	closeArea.Parent = self.screenGui
	self.resultModal.closeArea = closeArea
	self.resultModal.overlay = closeArea
	
	-- Container (CRITICAL FIX: IS_TINY_PHONE responsive sizing)
	local modalWidth = IS_TINY_PHONE and 280 or 340
	local modalHeight = IS_TINY_PHONE and 260 or 320
	
	local container = Instance.new("Frame")
	container.Name = "ResultModalContainer"
	container.Size = UDim2.new(0, modalWidth, 0, modalHeight)
	container.AnchorPoint = Vector2.new(0.5, 0.5)
	container.Position = UDim2.fromScale(0.5, 0.5)
	container.BackgroundTransparency = 1
	container.ZIndex = 97
	container.Parent = closeArea
	self.resultModal.container = container
	
	-- Premium shadow (CRITICAL FIX: IS_TINY_PHONE responsive sizing)
	local shadowPad = IS_TINY_PHONE and 8 or 12
	local shadow = Instance.new("Frame")
	shadow.Size = UDim2.new(1, shadowPad, 1, shadowPad)
	shadow.Position = UDim2.new(0, shadowPad/2, 0, shadowPad/2)
	shadow.BackgroundColor3 = C.Black
	shadow.BackgroundTransparency = 0.7
	shadow.ZIndex = 97
	shadow.Parent = container
	UI.corner(shadow, IS_TINY_PHONE and 20 or 28)
	
	-- Colored shell
	local shell = Instance.new("Frame")
	shell.Name = "Shell"
	shell.Size = UDim2.fromScale(1, 1)
	shell.BackgroundColor3 = C.Green
	shell.ZIndex = 98
	shell.Parent = container
	UI.corner(shell, 26)
	self.resultModal.shell = shell
	
	-- Shell stroke
	local shellStroke = Instance.new("UIStroke")
	shellStroke.Color = C.GreenDark
	shellStroke.Thickness = 2
	shellStroke.Transparency = 0.5
	shellStroke.Parent = shell
	self.resultModal.shellStroke = shellStroke
	
	-- Inner white card
	local card = Instance.new("Frame")
	card.Size = UDim2.new(1, -10, 1, -10)
	card.Position = UDim2.new(0, 5, 0, 5)
	card.BackgroundColor3 = C.White
	card.ZIndex = 99
	card.Parent = shell
	UI.corner(card, 22)
	
	-- Emoji frame (CRITICAL FIX: IS_TINY_PHONE responsive sizing)
	local emojiSize = IS_TINY_PHONE and 56 or 80
	local emojiFrame = Instance.new("Frame")
	emojiFrame.Size = UDim2.new(0, emojiSize, 0, emojiSize)
	emojiFrame.AnchorPoint = Vector2.new(0.5, 0)
	emojiFrame.Position = UDim2.new(0.5, 0, 0, IS_TINY_PHONE and 12 or 20)
	emojiFrame.BackgroundColor3 = C.GreenPale
	emojiFrame.ZIndex = 100
	emojiFrame.Parent = card
	UI.corner(emojiFrame, emojiSize/2)
	self.resultModal.emojiFrame = emojiFrame
	
	-- Emoji label
	local emojiLabel = Instance.new("TextLabel")
	emojiLabel.Size = UDim2.fromScale(1, 1)
	emojiLabel.BackgroundTransparency = 1
	emojiLabel.Font = F.Body
	emojiLabel.TextSize = IS_TINY_PHONE and 32 or 44
	emojiLabel.Text = "ðŸ›’"
	emojiLabel.ZIndex = 101
	emojiLabel.Parent = emojiFrame
	self.resultModal.emojiLabel = emojiLabel
	
	-- Title (CRITICAL FIX: IS_TINY_PHONE responsive positioning)
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Size = UDim2.new(1, -32, 0, IS_TINY_PHONE and 24 or 32)
	titleLabel.AnchorPoint = Vector2.new(0.5, 0)
	titleLabel.Position = UDim2.new(0.5, 0, 0, IS_TINY_PHONE and 72 or 108)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Font = F.Title
	titleLabel.TextSize = IS_TINY_PHONE and 17 or 22
	titleLabel.TextColor3 = C.GreenDark
	titleLabel.Text = "Purchase Complete!"
	titleLabel.ZIndex = 100
	titleLabel.Parent = card
	self.resultModal.titleLabel = titleLabel
	
	-- Message
	local messageLabel = Instance.new("TextLabel")
	messageLabel.Size = UDim2.new(1, -32, 0, 70)
	messageLabel.AnchorPoint = Vector2.new(0.5, 0)
	messageLabel.Position = UDim2.new(0.5, 0, 0, 145)
	messageLabel.BackgroundTransparency = 1
	messageLabel.Font = F.Body
	messageLabel.TextSize = 15
	messageLabel.TextColor3 = C.Gray700
	messageLabel.TextWrapped = true
	messageLabel.Text = ""
	messageLabel.ZIndex = 100
	messageLabel.Parent = card
	self.resultModal.messageLabel = messageLabel
	
	-- OK Button
	-- Button shadow (CRITICAL FIX: Must be SIBLING of button, not child)
	local btnShadow = Instance.new("Frame")
	btnShadow.Name = "OkBtnShadow"
	btnShadow.Size = UDim2.new(0.7, 4, 0, 56)
	btnShadow.AnchorPoint = Vector2.new(0.5, 0)
	btnShadow.Position = UDim2.new(0.5, 2, 0, 232)
	btnShadow.BackgroundColor3 = C.GreenDark
	btnShadow.BackgroundTransparency = 0.5
	btnShadow.ZIndex = 100
	btnShadow.Parent = card
	UI.corner(btnShadow, 14)
	self.resultModal.okBtnShadow = btnShadow
	
	local okBtn = Instance.new("TextButton")
	okBtn.Name = "OkBtn"
	okBtn.Size = UDim2.new(0.7, 0, 0, 52)
	okBtn.AnchorPoint = Vector2.new(0.5, 0)
	okBtn.Position = UDim2.new(0.5, 0, 0, 230)
	okBtn.BackgroundColor3 = C.Green
	okBtn.Font = F.Button
	okBtn.TextSize = 17
	okBtn.TextColor3 = C.White
	okBtn.Text = "ðŸ‘ Nice!"
	okBtn.AutoButtonColor = false
	okBtn.ZIndex = 101
	okBtn.Parent = card
	UI.corner(okBtn, 14)
	self.resultModal.okButton = okBtn
	
	-- Button hover (CRITICAL FIX: Also animate shadow)
	okBtn.MouseEnter:Connect(function()
		UI.tween(okBtn, TweenInfo.new(0.12, Enum.EasingStyle.Quad), {
			Size = UDim2.new(0.72, 0, 0, 56),
			BackgroundColor3 = shell.BackgroundColor3:Lerp(C.Black, 0.15)
		})
		UI.tween(btnShadow, TweenInfo.new(0.12), {
			Size = UDim2.new(0.72, 4, 0, 60)
		})
	end)
	okBtn.MouseLeave:Connect(function()
		UI.tween(okBtn, TweenInfo.new(0.12), {
			Size = UDim2.new(0.7, 0, 0, 52),
			BackgroundColor3 = shell.BackgroundColor3
		})
		UI.tween(btnShadow, TweenInfo.new(0.12), {
			Size = UDim2.new(0.7, 4, 0, 56)
		})
	end)
	
	-- Custom show/hide
	self.resultModal.show = function()
		closeArea.Visible = true
		closeArea.BackgroundTransparency = 1
		container.Position = UDim2.new(0.5, 0, 0.5, 40)
		container.Size = UDim2.new(0, 320, 0, 300)
		
		UI.tween(closeArea, TweenInfo.new(0.2), { BackgroundTransparency = 0.35 })
		UI.tween(container, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
			Position = UDim2.fromScale(0.5, 0.5),
			Size = UDim2.new(0, 340, 0, 320)
		})
	end
	
	self.resultModal.hide = function(callback)
		UI.tween(closeArea, TweenInfo.new(0.15), { BackgroundTransparency = 1 })
		UI.tween(container, TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
			Position = UDim2.new(0.5, 0, 0.5, 25),
			Size = UDim2.new(0, 320, 0, 300)
		})
		task.delay(0.15, function()
			closeArea.Visible = false
			if callback then callback() end
		end)
	end
	
	local function onDismiss()
		self:switchTab(self.currentTab)
	end
	
	closeArea.MouseButton1Click:Connect(function()
		self.resultModal.hide(onDismiss)
	end)
	okBtn.MouseButton1Click:Connect(function()
		self.resultModal.hide(onDismiss)
	end)
end

function AssetsScreen:createGamblingModal()
	self.gamblingOverlay = Instance.new("Frame")
	self.gamblingOverlay.Size = UDim2.fromScale(1, 1)
	self.gamblingOverlay.BackgroundColor3 = C.Black
	self.gamblingOverlay.BackgroundTransparency = 0.3
	self.gamblingOverlay.Visible = false
	self.gamblingOverlay.ZIndex = 96
	self.gamblingOverlay.Parent = self.screenGui

	-- Casino card
	local card = Instance.new("Frame")
	card.Size = UDim2.new(0.92, 0, 0, 440)
	card.AnchorPoint = Vector2.new(0.5, 0.5)
	card.Position = UDim2.fromScale(0.5, 0.5)
	card.BackgroundColor3 = Color3.fromRGB(26, 32, 44)
	card.ZIndex = 97
	card.Parent = self.gamblingOverlay
	UI.corner(card, 24)
	UI.createShadow(card, 8, 24, C.Black, 0.8)
	self.gamblingCard = card

	-- Gold header
	local header = Instance.new("Frame")
	header.Size = UDim2.new(1, 0, 0, 65)
	header.BackgroundColor3 = C.Gold
	header.ZIndex = 98
	header.Parent = card
	UI.corner(header, 24)
	UI.gradient(header, C.Gold, C.GoldDark, 0)

	-- Fix header bottom
	local headerFix = Instance.new("Frame")
	headerFix.Size = UDim2.new(1, 0, 0, 30)
	headerFix.Position = UDim2.new(0, 0, 0, 40)
	headerFix.BackgroundColor3 = C.GoldDark
	headerFix.ZIndex = 98
	headerFix.Parent = header

	local title = Instance.new("TextLabel")
	title.Size = UDim2.new(1, 0, 1, 0)
	title.BackgroundTransparency = 1
	title.Font = F.Title
	title.TextSize = 24
	title.TextColor3 = C.White
	title.Text = "ðŸŽ° Lucky Slots"
	title.ZIndex = 99
	title.Parent = header

	-- Close button
	local closeBtn = Instance.new("TextButton")
	closeBtn.Size = UDim2.new(0, 40, 0, 40)
	closeBtn.AnchorPoint = Vector2.new(1, 0.5)
	closeBtn.Position = UDim2.new(1, -12, 0.5, 0)
	closeBtn.BackgroundColor3 = C.White
	closeBtn.BackgroundTransparency = 0.15
	closeBtn.Font = F.Title
	closeBtn.TextSize = 18
	closeBtn.TextColor3 = C.GoldDark
	closeBtn.Text = "X"
	closeBtn.AutoButtonColor = false
	closeBtn.ZIndex = 100
	closeBtn.Parent = header
	UI.corner(closeBtn, 20)

	closeBtn.MouseButton1Click:Connect(function() self:hideGambling() end)

	-- Slot display
	local slotContainer = Instance.new("Frame")
	slotContainer.Size = UDim2.new(0.9, 0, 0, 110)
	slotContainer.AnchorPoint = Vector2.new(0.5, 0)
	slotContainer.Position = UDim2.new(0.5, 0, 0, 85)
	slotContainer.BackgroundColor3 = Color3.fromRGB(45, 55, 72)
	slotContainer.ZIndex = 98
	slotContainer.Parent = card
	UI.corner(slotContainer, 18)

	local slotLayout = Instance.new("UIListLayout")
	slotLayout.FillDirection = Enum.FillDirection.Horizontal
	slotLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	slotLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	slotLayout.Padding = UDim.new(0, 18)
	slotLayout.Parent = slotContainer

	self.slotLabels = {}
	local slotSymbols = { "ðŸ’", "ðŸ‹", "ðŸŠ" }
	for i = 1, 3 do
		local slotFrame = Instance.new("Frame")
		slotFrame.Size = UDim2.new(0, 80, 0, 85)
		slotFrame.BackgroundColor3 = C.White
		slotFrame.LayoutOrder = i
		slotFrame.ZIndex = 99
		slotFrame.Parent = slotContainer
		UI.corner(slotFrame, 14)

		local slotLabel = Instance.new("TextLabel")
		slotLabel.Size = UDim2.fromScale(1, 1)
		slotLabel.BackgroundTransparency = 1
		slotLabel.Font = F.Body
		slotLabel.TextSize = 55
		slotLabel.Text = slotSymbols[i]
		slotLabel.ZIndex = 100
		slotLabel.Parent = slotFrame

		self.slotLabels[i] = slotLabel
	end

	-- Bet display
	local betDisplay = Instance.new("Frame")
	betDisplay.Size = UDim2.new(0.9, 0, 0, 55)
	betDisplay.AnchorPoint = Vector2.new(0.5, 0)
	betDisplay.Position = UDim2.new(0.5, 0, 0, 210)
	betDisplay.BackgroundColor3 = Color3.fromRGB(45, 55, 72)
	betDisplay.ZIndex = 98
	betDisplay.Parent = card
	UI.corner(betDisplay, 14)

	local betLabel = Instance.new("TextLabel")
	betLabel.Size = UDim2.new(0.4, 0, 1, 0)
	betLabel.BackgroundTransparency = 1
	betLabel.Font = F.Medium
	betLabel.TextSize = 15
	betLabel.TextColor3 = C.Gray400
	betLabel.Text = "Your Bet:"
	betLabel.ZIndex = 99
	betLabel.Parent = betDisplay

	self.betAmount = 100
	self.betAmountLabel = Instance.new("TextLabel")
	self.betAmountLabel.Size = UDim2.new(0.6, 0, 1, 0)
	self.betAmountLabel.Position = UDim2.new(0.4, 0, 0, 0)
	self.betAmountLabel.BackgroundTransparency = 1
	self.betAmountLabel.Font = F.Title
	self.betAmountLabel.TextSize = 26
	self.betAmountLabel.TextColor3 = C.Gold
	self.betAmountLabel.TextXAlignment = Enum.TextXAlignment.Left
	self.betAmountLabel.Text = "$100"
	self.betAmountLabel.ZIndex = 99
	self.betAmountLabel.Parent = betDisplay

	-- Bet controls
	local betControls = Instance.new("Frame")
	betControls.Size = UDim2.new(0.9, 0, 0, 50)
	betControls.AnchorPoint = Vector2.new(0.5, 0)
	betControls.Position = UDim2.new(0.5, 0, 0, 275)
	betControls.BackgroundTransparency = 1
	betControls.ZIndex = 98
	betControls.Parent = card

	local controlLayout = Instance.new("UIListLayout")
	controlLayout.FillDirection = Enum.FillDirection.Horizontal
	controlLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	controlLayout.VerticalAlignment = Enum.VerticalAlignment.Center
	controlLayout.Padding = UDim.new(0, 10)
	controlLayout.Parent = betControls

	local betAmounts = { 100, 500, 1000, 5000 }
	self.betBtns = {}
	for i, amt in ipairs(betAmounts) do
		local btn = Instance.new("TextButton")
		btn.Size = UDim2.new(0, 70, 0, 42)
		btn.BackgroundColor3 = self.betAmount == amt and C.Gold or Color3.fromRGB(45, 55, 72)
		btn.Font = F.Button
		btn.TextSize = 13
		btn.TextColor3 = C.White
		btn.Text = UI.formatMoney(amt)
		btn.AutoButtonColor = false
		btn.LayoutOrder = i
		btn.ZIndex = 99
		btn.Parent = betControls
		UI.corner(btn, 12)

		self.betBtns[amt] = btn

		btn.MouseButton1Click:Connect(function()
			self.betAmount = amt
			self.betAmountLabel.Text = UI.formatMoney(amt)
			for _, b in pairs(self.betBtns) do
				b.BackgroundColor3 = Color3.fromRGB(45, 55, 72)
			end
			btn.BackgroundColor3 = C.Gold
		end)
	end

	-- Spin button
	self.spinBtn = Instance.new("TextButton")
	self.spinBtn.Size = UDim2.new(0.8, 0, 0, 60)
	self.spinBtn.AnchorPoint = Vector2.new(0.5, 0)
	self.spinBtn.Position = UDim2.new(0.5, 0, 0, 340)
	self.spinBtn.BackgroundColor3 = C.Green
	self.spinBtn.Font = F.Title
	self.spinBtn.TextSize = 22
	self.spinBtn.TextColor3 = C.White
	self.spinBtn.Text = "ðŸŽ° SPIN!"
	self.spinBtn.AutoButtonColor = false
	self.spinBtn.ZIndex = 98
	self.spinBtn.Parent = card
	UI.corner(self.spinBtn, 16)
	UI.gradient(self.spinBtn, C.Green, C.GreenDark, 90)

	self.isSpinning = false
	self.spinBtn.MouseButton1Click:Connect(function() self:spin() end)

	-- Result text
	self.spinResult = Instance.new("TextLabel")
	self.spinResult.Size = UDim2.new(1, 0, 0, 30)
	self.spinResult.AnchorPoint = Vector2.new(0.5, 0)
	self.spinResult.Position = UDim2.new(0.5, 0, 0, 405)
	self.spinResult.BackgroundTransparency = 1
	self.spinResult.Font = F.Title
	self.spinResult.TextSize = 17
	self.spinResult.TextColor3 = C.White
	self.spinResult.Text = ""
	self.spinResult.ZIndex = 98
	self.spinResult.Parent = card
end

function AssetsScreen:updateBalanceBar()
	self.balanceValue.Text = UI.formatMoney(self:getMoney())
end

function AssetsScreen:switchTab(tabId)
	self.currentTab = tabId

	for id, data in pairs(self.tabBtns) do
		local isActive = id == tabId
		UI.tween(data.btn, TweenInfo.new(0.15), {
			BackgroundColor3 = isActive and data.color or C.White,
			TextColor3 = isActive and C.White or C.Gray600
		})
	end

	for _, child in ipairs(self.contentScroll:GetChildren()) do
		if child:IsA("Frame") then child:Destroy() end
	end

	if tabId == "property" then self:populateProperty()
	elseif tabId == "vehicles" then self:populateVehicles()
	else self:populateShop() end
end

function AssetsScreen:populateProperty()
	log("=== POPULATE PROPERTY CALLED ===")
	self:updateBalanceBar()
	
	-- CRITICAL FIX #700: Reset scroll to top so Living Situation card is visible
	if self.contentScroll then
		self.contentScroll.CanvasPosition = Vector2.new(0, 0)
	end

	-- Debug the raw state
	debugAssets(self.playerState and self.playerState.Assets, "Current playerState.Assets")

	local assets = self:getAssets()
	local ownedProperties = {}
	local catalogIds = {}
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- LIVING SITUATION CARD - Shows where player currently lives
	-- CRITICAL FIX: Players wanted to see their housing status!
	-- CRITICAL FIX #2: Also read HousingState.status for accurate info!
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local livingCard = Instance.new("Frame")
	livingCard.Name = "LivingSituationCard"
	livingCard.Size = UDim2.new(1, 0, 0, 120)
	livingCard.BackgroundColor3 = C.PurplePale or Color3.fromRGB(237, 233, 254)
	livingCard.LayoutOrder = -1 -- Before everything else
	livingCard.ZIndex = 82
	livingCard.Parent = self.contentScroll
	UI.corner(livingCard, 18)
	UI.stroke(livingCard, 2, 0.5, C.Purple or Color3.fromRGB(147, 51, 234))
	UI.pad(livingCard, 14, 14, 14, 16)
	
	-- Determine living situation
	local flags = self.playerState and self.playerState.Flags or {}
	local housingState = self.playerState and self.playerState.HousingState or {}
	local age = self.playerState and self.playerState.Age or 0
	local housingStatus = housingState.status -- "renter", "owner", "with_parents", "homeless", etc.

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Detect partner/spouse from Relationships table (not just flags)
	-- BUG: Partner was stored in Relationships but flags.has_partner wasn't set
	-- This caused Living Situation to show "With Parents" instead of "With Partner"
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local hasPartnerFromRelationships = false
	local partnerNameFromRelationships = nil
	local isSpouseFromRelationships = false
	local relationships = self.playerState and self.playerState.Relationships or {}
	for id, rel in pairs(relationships) do
		local relType = rel and (rel.type or "")
		local relRole = rel and (rel.role or "")
		local relAlive = rel and rel.alive
		if relAlive then
			relType = string.lower(tostring(relType))
			relRole = string.lower(tostring(relRole))
			if relType == "romance" or relType == "spouse" or relType == "partner" or
			   relRole:find("spouse") or relRole:find("partner") or
			   relRole:find("wife") or relRole:find("husband") or
			   relRole:find("boyfriend") or relRole:find("girlfriend") then
				hasPartnerFromRelationships = true
				partnerNameFromRelationships = rel.name
				-- Check if spouse specifically
				if relRole:find("spouse") or relRole:find("wife") or relRole:find("husband") or
				   relType == "spouse" or flags.married then
					isSpouseFromRelationships = true
				end
				break
			end
		end
	end

	local livingEmoji = "ðŸ "
	local livingTitle = "Living Situation"
	local livingStatus = "Unknown"
	local livingDetail = ""
	local statusColor = C.Purple

	-- CRITICAL FIX: Check HousingState.status FIRST for most accurate info
	-- Then fall back to flags for backwards compatibility
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: ORDER MATTERS! Homeownership should OVERRIDE transitional states!
	-- User complaint: "Housing doesn't update when I buy a house from transitional"
	-- The issue was transitional_housing check came BEFORE homeowner check
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local royalState = self.playerState and self.playerState.RoyalState
	
	-- PRIORITY 1: Royalty (palace)
	if flags.is_royalty or (royalState and royalState.isRoyal) then
		livingEmoji = "ðŸ°"
		livingStatus = "Royal Palace"
		local country = royalState and royalState.countryName or "European Kingdom"
		local title = royalState and royalState.title or "Royal"
		livingDetail = title .. " of " .. country
		statusColor = C.Gold or C.Amber
	-- PRIORITY 2: HOMEOWNER - Must come before ANY transitional/homeless states!
	-- If player owns property, they are NOT homeless/transitional anymore
	elseif flags.homeowner or flags.has_house or flags.has_property or housingStatus == "owner" then
		-- Check for inherited property
		if flags.inherited_property then
			livingEmoji = "ðŸšï¸"
			livingStatus = "Inherited Property"
			local propValue = housingState.value or 0
			if propValue > 0 then
				livingDetail = "Inherited home! Value: $" .. self:formatMoney(propValue)
			else
				livingDetail = "Inherited from family (mortgage-free!)"
			end
		else
			livingEmoji = "ðŸ¡"
			livingStatus = "Homeowner"
			local propValue = housingState.value or 0
			if propValue > 0 then
				livingDetail = "Property value: $" .. self:formatMoney(propValue)
			else
				livingDetail = "You own your home!"
			end
		end
		statusColor = C.Green
	-- PRIORITY 3: RENTING - Also overrides transitional states
	-- CRITICAL FIX: Only show renting if NOT homeless! Stale flags can cause contradictions
	-- BUG: User said "shows renting but I'm homeless" - homeless flag should override renting
	elseif (flags.has_apartment or flags.renting or housingStatus == "renter") 
		and not flags.homeless and housingStatus ~= "homeless" then
		livingEmoji = "ðŸ¢"
		if flags.has_roommates or housingState.type == "shared_apartment" then
			livingStatus = "Renting (Roommates)"
		else
			livingStatus = "Renting Apartment"
		end
		local rent = housingState.rent or 900 -- Default $900 if not set
		livingDetail = "Monthly rent: $" .. self:formatMoney(rent)
		statusColor = C.Blue
	-- PRIORITY 4: Actual homeless states (no property, no rental)
	-- CRITICAL FIX: Also check for stale renting flags that contradict homeless status
	elseif flags.homeless or housingStatus == "homeless" then
		livingEmoji = "ðŸ•ï¸"
		livingStatus = "Homeless"
		livingDetail = "Living on the streets"
		statusColor = C.Red
	elseif flags.living_in_car then
		livingEmoji = "ðŸš—"
		livingStatus = "Living in Car"
		livingDetail = "No permanent address"
		statusColor = C.Amber
	elseif flags.couch_surfing then
		livingEmoji = "ðŸ›‹ï¸"
		livingStatus = "Couch Surfing"
		livingDetail = "Staying with friends temporarily"
		statusColor = C.Amber
	elseif flags.using_shelter then
		livingEmoji = "ðŸ¨"
		livingStatus = "Homeless Shelter"
		livingDetail = "Temporary shelter housing"
		statusColor = C.Amber
	elseif flags.in_transitional_housing then
		livingEmoji = "ðŸ¢"
		livingStatus = "Transitional Housing"
		livingDetail = "Program housing - rebuilding"
		statusColor = C.Blue
	elseif flags.living_with_family then
		livingEmoji = "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§"
		livingStatus = "With Family"
		livingDetail = "Living with family members"
		statusColor = C.Green
	elseif flags.married or flags.has_spouse or isSpouseFromRelationships then
		-- CRITICAL FIX: Show married status in housing
		-- User complaint: "Doesn't show if I'm living with my girl/wife/husband"
		-- CRITICAL FIX #2: Also check Relationships table for spouse
		livingEmoji = "ðŸ’‘"
		livingStatus = "With Spouse"
		if partnerNameFromRelationships then
			livingDetail = "Living with " .. partnerNameFromRelationships
		elseif flags.homeowner or flags.has_house then
			livingDetail = "Living together in your own home"
		elseif flags.renting or flags.has_apartment then
			local rent = housingState.rent or 0
			livingDetail = rent > 0 and ("Renting together - $" .. self:formatMoney(rent) .. "/mo") or "Renting together"
		else
			livingDetail = "Living together"
		end
		if flags.homeowner or flags.has_house then
			statusColor = C.Green
		elseif flags.renting or flags.has_apartment then
			statusColor = C.Blue
		else
			statusColor = C.Pink or C.Purple
		end
	elseif flags.has_partner or flags.dating or flags.cohabiting or hasPartnerFromRelationships then
		-- Living with boyfriend/girlfriend
		-- CRITICAL FIX: Also check Relationships table for partner
		livingEmoji = "ðŸ’•"
		livingStatus = "With Partner"
		if partnerNameFromRelationships then
			livingDetail = "Living with " .. partnerNameFromRelationships
		else
			livingDetail = "Living with your significant other"
		end
		statusColor = C.Pink or C.Purple
	elseif flags.has_own_place or flags.moved_out then
		-- Has own place but not specifically apartment/house flagged
		livingEmoji = "ðŸ "
		livingStatus = "Independent"
		local rent = housingState.rent or 0
		if rent > 0 then
			livingDetail = "Your own place - $" .. self:formatMoney(rent) .. "/mo rent"
		else
			livingDetail = "Living on your own"
		end
		statusColor = C.Green
	elseif housingStatus == "with_parents" or flags.living_with_parents then
		-- Explicitly living with parents
		livingEmoji = "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§"
		livingStatus = "With Parents"
		livingDetail = "Living at home (no rent!)"
		statusColor = C.Green
	elseif age < 18 then
		livingEmoji = "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§"
		livingStatus = "With Parents"
		livingDetail = "Living at home with family"
		statusColor = C.Green
	elseif age >= 18 and age <= 25 and not flags.moved_out then
		-- Young adult still with parents (default assumption)
		livingEmoji = "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§"
		livingStatus = "With Parents"
		livingDetail = "Still living at home (no rent!)"
		statusColor = C.Green
	elseif age > 25 and not flags.moved_out then
		-- Older adult still at home
		livingEmoji = "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§"
		livingStatus = "With Parents"
		livingDetail = "Still living at the family home"
		statusColor = C.Amber
	else
		livingEmoji = "â“"
		livingStatus = "No Permanent Home"
		livingDetail = "Consider buying or renting property!"
		statusColor = C.Gray500
	end
	
	-- Living card icon
	local iconFrame = Instance.new("Frame")
	iconFrame.Size = UDim2.new(0, 70, 0, 70)
	iconFrame.Position = UDim2.new(0, 10, 0, 12)
	iconFrame.BackgroundColor3 = C.White
	iconFrame.ZIndex = 83
	iconFrame.Parent = livingCard
	UI.corner(iconFrame, 16)
	
	local iconLabel = Instance.new("TextLabel")
	iconLabel.Size = UDim2.fromScale(1, 1)
	iconLabel.BackgroundTransparency = 1
	iconLabel.Font = Enum.Font.GothamBold
	iconLabel.TextSize = 36
	iconLabel.Text = livingEmoji
	iconLabel.ZIndex = 84
	iconLabel.Parent = iconFrame
	
	-- Title
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Size = UDim2.new(1, -100, 0, 24)
	titleLabel.Position = UDim2.new(0, 90, 0, 10)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Font = F.Title
	titleLabel.TextSize = textSize(18)
	titleLabel.TextColor3 = C.Purple
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Text = livingTitle
	titleLabel.ZIndex = 83
	titleLabel.Parent = livingCard
	
	-- Status
	local statusLabel = Instance.new("TextLabel")
	statusLabel.Size = UDim2.new(1, -100, 0, 28)
	statusLabel.Position = UDim2.new(0, 90, 0, 34)
	statusLabel.BackgroundTransparency = 1
	statusLabel.Font = F.Button
	statusLabel.TextSize = textSize(20)
	statusLabel.TextColor3 = statusColor
	statusLabel.TextXAlignment = Enum.TextXAlignment.Left
	statusLabel.Text = livingStatus
	statusLabel.ZIndex = 83
	statusLabel.Parent = livingCard
	
	-- Detail
	local detailLabel = Instance.new("TextLabel")
	detailLabel.Size = UDim2.new(1, -100, 0, 20)
	detailLabel.Position = UDim2.new(0, 90, 0, 64)
	detailLabel.BackgroundTransparency = 1
	detailLabel.Font = F.Body
	detailLabel.TextSize = textSize(13)
	detailLabel.TextColor3 = C.Gray600
	detailLabel.TextXAlignment = Enum.TextXAlignment.Left
	detailLabel.Text = livingDetail
	detailLabel.ZIndex = 83
	detailLabel.Parent = livingCard

	log("Checking catalog for owned properties...")
	-- Find owned properties from shop catalog
	for _, prop in ipairs(Properties) do
		catalogIds[prop.id] = true
		if assets[prop.id] then
			log("  Found catalog property:", prop.id)
			table.insert(ownedProperties, prop)
		end
	end

	-- Also include event-acquired properties that aren't in the catalog
	log("Getting owned list for 'property'...")
	local ownedList = self:getOwnedList("property")
	log("  getOwnedList returned:", #ownedList, "items")
	
	for i, owned in ipairs(ownedList) do
		log("  Checking owned[" .. i .. "]: id=" .. tostring(owned.id) .. " name=" .. tostring(owned.name))
		if not catalogIds[owned.id] then
			-- Create a display entry for this event-acquired property
			log("    -> Adding as event-acquired property")
			table.insert(ownedProperties, {
				id = owned.id,
				name = owned.name or owned.id,
				emoji = owned.emoji or "ðŸ¡",
				price = owned.value or owned.price or 0,
				minAge = 0,
				isEventAcquired = true
			})
		else
			log("    -> Already in catalog, skipping")
		end
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #DUPLICATE-1: Prevent living situation duplication
	-- User complaint: "Living situation duplicated sometimes"
	-- The Living Situation card already shows rental/housing status
	-- Only add actual OWNED properties to the My Properties section - not rentals!
	-- Rentals are NOT manageable properties (can't sell them) so they shouldn't be listed
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local alreadyHasResidence = false
	for _, prop in ipairs(ownedProperties) do
		if prop.id and (prop.id:find("apartment") or prop.id:find("house") or prop.id:find("home") or prop.id:find("residence")) then
			alreadyHasResidence = true
			break
		end
	end
	
	-- CRITICAL FIX: Only add OWNED properties to the list, NOT rentals!
	-- Rentals are shown in the Living Situation card only - no need to duplicate
	if not alreadyHasResidence then
		local flags = self.playerState and self.playerState.Flags or {}
		local housingState = self.playerState and self.playerState.HousingState or {}
		local age = self.playerState and self.playerState.Age or 0
		local royalState = self.playerState and self.playerState.RoyalState
		
		-- CRITICAL FIX: Royalty gets a palace as their primary residence!
		if flags.is_royalty or (royalState and royalState.isRoyal) then
			local country = royalState and royalState.countryName or "European Kingdom"
			local title = royalState and royalState.title or "Royal"
			local residenceEntry = {
				id = "royal_palace",
				name = "Royal Palace",
				emoji = "ðŸ°",
				price = 0, -- Priceless!
				minAge = 0,
				isEventAcquired = true,
				description = title .. " residence in " .. country
			}
			table.insert(ownedProperties, 1, residenceEntry)
			log("  Added royal palace to property list")
		-- CRITICAL FIX: DO NOT add rental apartments to the property list!
		-- They are already shown in the Living Situation card and adding them
		-- creates the duplication bug the user complained about.
		-- Rentals are not manageable (can't sell) so they don't belong in "My Properties"
		-- elseif flags.moved_out or flags.renting or flags.has_apartment or housingState.status == "renter" then
		--     (REMOVED - this caused duplication)
		elseif flags.homeowner or flags.has_house or housingState.status == "owner" then
			-- Player owns home but it's not in list - add placeholder
			-- This IS an actual owned property that can be sold/managed
			local propValue = housingState.value or 150000
			local residenceEntry = {
				id = "current_home",
				name = flags.inherited_property and "Inherited Home" or "My Home",
				emoji = flags.inherited_property and "ðŸšï¸" or "ðŸ¡",
				price = propValue,
				minAge = 0,
				isEventAcquired = true,
				description = string.format("Property value: $%s", self:formatMoney(propValue))
			}
			table.insert(ownedProperties, 1, residenceEntry)
			log("  Added current owned home to property list")
		-- CRITICAL FIX: Don't show dorm rooms in property list either - they're temporary housing
		-- shown in Living Situation card already. Adding them here causes duplication.
		-- elseif flags.in_college or flags.in_university then
		--     (REMOVED - dorms are shown in Living Situation card, not My Properties)
		end
	end

	log("FINAL: Owned properties:", #ownedProperties, "of catalog:", #Properties)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- MY PROPERTIES SECTION (only if owns any)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	if #ownedProperties > 0 then
		local mySection = Instance.new("Frame")
		mySection.Name = "MyPropertiesSection"
		mySection.Size = UDim2.new(1, 0, 0, 0)
		mySection.AutomaticSize = Enum.AutomaticSize.Y
		mySection.BackgroundColor3 = C.TealPale
		mySection.LayoutOrder = 0
		mySection.ZIndex = 82
		mySection.Parent = self.contentScroll
		UI.corner(mySection, 18)
		UI.stroke(mySection, 2, 0.5, C.Teal)
		UI.pad(mySection, 14, 14, 14, 16)

		local myLayout = Instance.new("UIListLayout")
		myLayout.Padding = UDim.new(0, 10)
		myLayout.SortOrder = Enum.SortOrder.LayoutOrder
		myLayout.Parent = mySection

		-- Header
		local header = Instance.new("Frame")
		header.Size = UDim2.new(1, 0, 0, 36)
		header.BackgroundTransparency = 1
		header.LayoutOrder = 0
		header.ZIndex = 83
		header.Parent = mySection

		local badge = Instance.new("Frame")
		badge.Size = UDim2.new(0, 140, 0, 32)
		badge.BackgroundColor3 = C.Teal
		badge.ZIndex = 84
		badge.Parent = header
		UI.pill(badge)

		local badgeLabel = Instance.new("TextLabel")
		badgeLabel.Size = UDim2.fromScale(1, 1)
		badgeLabel.BackgroundTransparency = 1
		badgeLabel.Font = F.Button
		badgeLabel.TextSize = 14
		badgeLabel.TextColor3 = C.White
		badgeLabel.Text = "ðŸ  My Properties"
		badgeLabel.ZIndex = 85
		badgeLabel.Parent = badge

		local countLabel = Instance.new("TextLabel")
		countLabel.Size = UDim2.new(0, 100, 1, 0)
		countLabel.Position = UDim2.new(0, 150, 0, 0)
		countLabel.BackgroundTransparency = 1
		countLabel.Font = F.Medium
		countLabel.TextSize = 13
		countLabel.TextColor3 = C.TealDark
		countLabel.TextXAlignment = Enum.TextXAlignment.Left
		countLabel.Text = #ownedProperties .. " owned"
		countLabel.ZIndex = 84
		countLabel.Parent = header

		-- Show owned properties
		for i, item in ipairs(ownedProperties) do
			self:createOwnedAssetCard(mySection, item, i, "property", C.Teal, C.TealPale)
		end
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- AVAILABLE PROPERTIES SECTION
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local section = UI.createSectionCard(self.contentScroll, {
		name = "PropertySection",
		title = "Real Estate",
		subtitle = #Properties .. " properties",
		accentColor = C.Teal,
		badgeWidth = 100,
		order = 1,
		zIndex = 82
	})

	for i, item in ipairs(Properties) do
		self:createAssetCard(section, item, i, "property", C.Teal, C.TealPale)
	end
end

function AssetsScreen:populateVehicles()
	self:updateBalanceBar()
	
	-- CRITICAL FIX #700: Reset scroll to top when switching tabs
	if self.contentScroll then
		self.contentScroll.CanvasPosition = Vector2.new(0, 0)
	end

	local assets = self:getAssets()
	local ownedVehicles = {}
	local catalogIds = {}

	-- Find owned vehicles from shop catalog
	for _, veh in ipairs(Vehicles) do
		catalogIds[veh.id] = true
		if assets[veh.id] then
			table.insert(ownedVehicles, veh)
		end
	end

	-- Also include event-acquired vehicles that aren't in the catalog
	local ownedList = self:getOwnedList("vehicle")
	for _, owned in ipairs(ownedList) do
		if not catalogIds[owned.id] then
			-- Create a display entry for this event-acquired vehicle
			table.insert(ownedVehicles, {
				id = owned.id,
				name = owned.name or owned.id,
				emoji = "ðŸŽï¸",
				price = owned.value or 0,
				minAge = 0,
				isEventAcquired = true
			})
		end
	end

	log("Owned vehicles:", #ownedVehicles, "of", #Vehicles)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- MY VEHICLES SECTION (only if owns any)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	if #ownedVehicles > 0 then
		local mySection = Instance.new("Frame")
		mySection.Name = "MyVehiclesSection"
		mySection.Size = UDim2.new(1, 0, 0, 0)
		mySection.AutomaticSize = Enum.AutomaticSize.Y
		mySection.BackgroundColor3 = C.BluePale
		mySection.LayoutOrder = 0
		mySection.ZIndex = 82
		mySection.Parent = self.contentScroll
		UI.corner(mySection, 18)
		UI.stroke(mySection, 2, 0.5, C.Blue)
		UI.pad(mySection, 14, 14, 14, 16)

		local myLayout = Instance.new("UIListLayout")
		myLayout.Padding = UDim.new(0, 10)
		myLayout.SortOrder = Enum.SortOrder.LayoutOrder
		myLayout.Parent = mySection

		-- Header
		local header = Instance.new("Frame")
		header.Size = UDim2.new(1, 0, 0, 36)
		header.BackgroundTransparency = 1
		header.LayoutOrder = 0
		header.ZIndex = 83
		header.Parent = mySection

		local badge = Instance.new("Frame")
		badge.Size = UDim2.new(0, 130, 0, 32)
		badge.BackgroundColor3 = C.Blue
		badge.ZIndex = 84
		badge.Parent = header
		UI.pill(badge)

		local badgeLabel = Instance.new("TextLabel")
		badgeLabel.Size = UDim2.fromScale(1, 1)
		badgeLabel.BackgroundTransparency = 1
		badgeLabel.Font = F.Button
		badgeLabel.TextSize = 14
		badgeLabel.TextColor3 = C.White
		badgeLabel.Text = "ðŸš— My Garage"
		badgeLabel.ZIndex = 85
		badgeLabel.Parent = badge

		local countLabel = Instance.new("TextLabel")
		countLabel.Size = UDim2.new(0, 100, 1, 0)
		countLabel.Position = UDim2.new(0, 140, 0, 0)
		countLabel.BackgroundTransparency = 1
		countLabel.Font = F.Medium
		countLabel.TextSize = 13
		countLabel.TextColor3 = C.BlueDark
		countLabel.TextXAlignment = Enum.TextXAlignment.Left
		countLabel.Text = #ownedVehicles .. " owned"
		countLabel.ZIndex = 84
		countLabel.Parent = header

		-- Show owned vehicles
		for i, item in ipairs(ownedVehicles) do
			self:createOwnedAssetCard(mySection, item, i, "vehicle", C.Blue, C.BluePale)
		end
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- AVAILABLE VEHICLES SECTION
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local section = UI.createSectionCard(self.contentScroll, {
		name = "VehiclesSection",
		title = "Vehicles",
		subtitle = #Vehicles .. " options",
		accentColor = C.Blue,
		badgeWidth = 85,
		order = 1,
		zIndex = 82
	})

	for i, item in ipairs(Vehicles) do
		self:createAssetCard(section, item, i, "vehicle", C.Blue, C.BluePale)
	end
end

function AssetsScreen:populateShop()
	self:updateBalanceBar()
	
	-- CRITICAL FIX #700: Reset scroll to top when switching tabs
	if self.contentScroll then
		self.contentScroll.CanvasPosition = Vector2.new(0, 0)
	end

	local assets = self:getAssets()
	local ownedItems = {}
	local catalogIds = {}

	-- Find owned items from shop catalog
	for _, itm in ipairs(Shop) do
		catalogIds[itm.id] = true
		if assets[itm.id] then
			table.insert(ownedItems, itm)
		end
	end

	-- Also include event-acquired items that aren't in the catalog
	local ownedList = self:getOwnedList("item")
	for _, owned in ipairs(ownedList) do
		if not catalogIds[owned.id] then
			-- Create a display entry for this event-acquired item
			table.insert(ownedItems, {
				id = owned.id,
				name = owned.name or owned.id,
				emoji = "ðŸŽ",
				price = owned.value or 0,
				minAge = 0,
				isEventAcquired = true
			})
		end
	end

	log("Owned items:", #ownedItems, "of", #Shop)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- MY STUFF SECTION (only if owns any)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	if #ownedItems > 0 then
		local mySection = Instance.new("Frame")
		mySection.Name = "MyItemsSection"
		mySection.Size = UDim2.new(1, 0, 0, 0)
		mySection.AutomaticSize = Enum.AutomaticSize.Y
		mySection.BackgroundColor3 = C.PurplePale
		mySection.LayoutOrder = 0
		mySection.ZIndex = 82
		mySection.Parent = self.contentScroll
		UI.corner(mySection, 18)
		UI.stroke(mySection, 2, 0.5, C.Purple)
		UI.pad(mySection, 14, 14, 14, 16)

		local myLayout = Instance.new("UIListLayout")
		myLayout.Padding = UDim.new(0, 10)
		myLayout.SortOrder = Enum.SortOrder.LayoutOrder
		myLayout.Parent = mySection

		-- Header
		local header = Instance.new("Frame")
		header.Size = UDim2.new(1, 0, 0, 36)
		header.BackgroundTransparency = 1
		header.LayoutOrder = 0
		header.ZIndex = 83
		header.Parent = mySection

		local badge = Instance.new("Frame")
		badge.Size = UDim2.new(0, 115, 0, 32)
		badge.BackgroundColor3 = C.Purple
		badge.ZIndex = 84
		badge.Parent = header
		UI.pill(badge)

		local badgeLabel = Instance.new("TextLabel")
		badgeLabel.Size = UDim2.fromScale(1, 1)
		badgeLabel.BackgroundTransparency = 1
		badgeLabel.Font = F.Button
		badgeLabel.TextSize = 14
		badgeLabel.TextColor3 = C.White
		badgeLabel.Text = "ðŸ“¦ My Stuff"
		badgeLabel.ZIndex = 85
		badgeLabel.Parent = badge

		local countLabel = Instance.new("TextLabel")
		countLabel.Size = UDim2.new(0, 100, 1, 0)
		countLabel.Position = UDim2.new(0, 125, 0, 0)
		countLabel.BackgroundTransparency = 1
		countLabel.Font = F.Medium
		countLabel.TextSize = 13
		countLabel.TextColor3 = C.PurpleDark
		countLabel.TextXAlignment = Enum.TextXAlignment.Left
		countLabel.Text = #ownedItems .. " owned"
		countLabel.ZIndex = 84
		countLabel.Parent = header

		-- Show owned items
		for i, item in ipairs(ownedItems) do
			self:createOwnedAssetCard(mySection, item, i, "item", C.Purple, C.PurplePale)
		end
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- AVAILABLE ITEMS SECTION
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local section = UI.createSectionCard(self.contentScroll, {
		name = "ShopSection",
		title = "Shop",
		subtitle = #Shop .. " items",
		accentColor = C.Purple,
		badgeWidth = 70,
		order = 1,
		zIndex = 82
	})

	for i, item in ipairs(Shop) do
		self:createAssetCard(section, item, i, "item", C.Purple, C.PurplePale)
	end
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- OWNED ASSET CARD (with Sell button)
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function AssetsScreen:createOwnedAssetCard(parent, item, order, itemType, accentColor, paleColor)
	log("Creating owned asset card:", item.name, "type:", itemType)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL REVAMP: Premium Owned Card with Shell Structure (like LifeClient popup)
	-- Container -> Shadow -> Green Shell -> Inner Card
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	-- Container (holds everything)
	local container = Instance.new("Frame")
	container.Name = "Owned_" .. item.id .. "_Container"
	container.Size = UDim2.new(1, 0, 0, 95)
	container.BackgroundTransparency = 1
	container.LayoutOrder = order
	container.ZIndex = 82
	container.Parent = parent
	
	-- Shadow layer (premium depth)
	local shadow = Instance.new("Frame")
	shadow.Name = "Shadow"
	shadow.Size = UDim2.new(1, 4, 1, 4)
	shadow.Position = UDim2.new(0, 2, 0, 2)
	shadow.BackgroundColor3 = C.Black
	shadow.BackgroundTransparency = 0.88
	shadow.ZIndex = 82
	shadow.Parent = container
	UI.corner(shadow, 20)
	
	-- Green shell (shows ownership)
	local shell = Instance.new("Frame")
	shell.Name = "Shell"
	shell.Size = UDim2.new(1, 0, 1, 0)
	shell.BackgroundColor3 = C.Green
	shell.ZIndex = 83
	shell.Parent = container
	UI.corner(shell, 18)
	
	-- Inner white card
	local card = Instance.new("Frame")
	card.Name = "Card"
	card.Size = UDim2.new(1, -6, 1, -6)
	card.Position = UDim2.new(0, 3, 0, 3)
	card.BackgroundColor3 = C.White
	card.ZIndex = 84
	card.Parent = shell
	UI.corner(card, 16)
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- PREMIUM HOVER & PRESS EFFECTS
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	-- CRITICAL FIX: Reduced width to not cover the Sell button on the right
	local pressArea = Instance.new("TextButton")
	pressArea.Name = "PressArea"
	pressArea.Size = UDim2.new(1, -100, 1, 0)  -- Leave 100px for button
	pressArea.BackgroundTransparency = 1
	pressArea.Text = ""
	pressArea.ZIndex = 90
	pressArea.Parent = container
	
	local isHovering = false
	local isPressed = false
	
	pressArea.MouseEnter:Connect(function()
		if isPressed then return end
		isHovering = true
		UI.tween(container, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
			Size = UDim2.new(1, 0, 0, 99)
		})
		UI.tween(shell, TweenInfo.new(0.12), { BackgroundColor3 = C.GreenDark })
		UI.tween(shadow, TweenInfo.new(0.12), {
			BackgroundTransparency = 0.82,
			Position = UDim2.new(0, 3, 0, 4)
		})
		UI.tween(card, TweenInfo.new(0.12), { BackgroundColor3 = C.GreenPale:Lerp(C.White, 0.85) })
	end)
	
	pressArea.MouseLeave:Connect(function()
		isHovering = false
		isPressed = false
		UI.tween(container, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
			Size = UDim2.new(1, 0, 0, 95)
		})
		UI.tween(shell, TweenInfo.new(0.12), { BackgroundColor3 = C.Green })
		UI.tween(shadow, TweenInfo.new(0.12), {
			BackgroundTransparency = 0.88,
			Position = UDim2.new(0, 2, 0, 2)
		})
		UI.tween(card, TweenInfo.new(0.12), { BackgroundColor3 = C.White })
	end)
	
	pressArea.MouseButton1Down:Connect(function()
		isPressed = true
		UI.tween(container, TweenInfo.new(0.08), {
			Size = UDim2.new(1, 0, 0, 91)
		})
		UI.tween(shell, TweenInfo.new(0.08), { BackgroundColor3 = C.GreenDark:Lerp(C.Black, 0.1) })
	end)
	
	pressArea.MouseButton1Up:Connect(function()
		isPressed = false
		if isHovering then
			UI.tween(container, TweenInfo.new(0.1), {
				Size = UDim2.new(1, 0, 0, 99)
			})
			UI.tween(shell, TweenInfo.new(0.1), { BackgroundColor3 = C.GreenDark })
		end
	end)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- ICON (with green ownership ring)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	local iconRing = Instance.new("Frame")
	iconRing.Size = UDim2.new(0, 60, 0, 60)
	iconRing.Position = UDim2.new(0, 10, 0.5, -30)
	iconRing.BackgroundColor3 = C.GreenDark
	iconRing.ZIndex = 85
	iconRing.Parent = card
	UI.corner(iconRing, 16)
	
	local iconFrame = Instance.new("Frame")
	iconFrame.Size = UDim2.new(1, -6, 1, -6)
	iconFrame.Position = UDim2.new(0, 3, 0, 3)
	iconFrame.BackgroundColor3 = C.GreenPale
	iconFrame.ZIndex = 86
	iconFrame.Parent = iconRing
	UI.corner(iconFrame, 14)

	-- CRITICAL UI FIX: Responsive text sizes for asset cards
	local iconLabel = Instance.new("TextLabel")
	iconLabel.Size = UDim2.fromScale(1, 1)
	iconLabel.BackgroundTransparency = 1
	iconLabel.Font = F.Body
	iconLabel.TextSize = IS_TINY_PHONE and 24 or (IS_SMALL_PHONE and 28 or 32)
	iconLabel.Text = item.emoji
	iconLabel.ZIndex = 87
	iconLabel.Parent = iconFrame

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CONTENT - CRITICAL UI FIX: Responsive sizing for mobile
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	-- Title (CRITICAL FIX: Responsive + truncation)
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Size = UDim2.new(0.45, IS_TINY_PHONE and -70 or -85, 0, IS_TINY_PHONE and 22 or 26)
	titleLabel.Position = UDim2.new(0, IS_TINY_PHONE and 68 or 80, 0, IS_TINY_PHONE and 6 or 8)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Font = F.Title
	titleLabel.TextSize = IS_TINY_PHONE and 14 or (IS_SMALL_PHONE and 15 or 17)
	titleLabel.TextColor3 = C.Gray900
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.TextTruncate = Enum.TextTruncate.AtEnd
	titleLabel.Text = item.name
	titleLabel.ZIndex = 85
	titleLabel.Parent = card

	-- Owned badge (prominent) - CRITICAL UI FIX: Responsive sizing
	local ownedBadge = Instance.new("Frame")
	ownedBadge.Size = UDim2.new(0, IS_TINY_PHONE and 72 or 85, 0, IS_TINY_PHONE and 22 or 26)
	ownedBadge.Position = UDim2.new(0, IS_TINY_PHONE and 68 or 80, 0, IS_TINY_PHONE and 30 or 36)
	ownedBadge.BackgroundColor3 = C.Green
	ownedBadge.ZIndex = 85
	ownedBadge.Parent = card
	UI.pill(ownedBadge)

	local ownedLabel = Instance.new("TextLabel")
	ownedLabel.Size = UDim2.fromScale(1, 1)
	ownedLabel.BackgroundTransparency = 1
	ownedLabel.Font = F.Button
	ownedLabel.TextSize = IS_TINY_PHONE and 10 or (IS_SMALL_PHONE and 11 or 12)
	ownedLabel.TextColor3 = C.White
	ownedLabel.Text = "âœ“ OWNED"
	ownedLabel.ZIndex = 86
	ownedLabel.Parent = ownedBadge

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #SELL-VALUE: Use CURRENT value not purchase price!
	-- User complaint: "sell value showing wrong amounts"
	-- The issue was using item.price (purchase) instead of item.value (current)
	-- Also account for resaleModifier (different assets depreciate differently)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local currentValue = item.value or item.price or 0
	local resaleModifier = item.resaleModifier or 0.70  -- Default 70% of value
	local sellPrice = math.floor(currentValue * resaleModifier)
	
	-- Log for debugging
	log("Sell value calculation:", item.name)
	log("  - item.value:", item.value, "item.price:", item.price)
	log("  - currentValue:", currentValue, "resaleModifier:", resaleModifier)
	log("  - sellPrice:", sellPrice)
	
	local valueBadge = Instance.new("Frame")
	valueBadge.Size = UDim2.new(0, IS_TINY_PHONE and 88 or 100, 0, IS_TINY_PHONE and 20 or 22)
	valueBadge.Position = UDim2.new(0, IS_TINY_PHONE and 68 or 80, 0, IS_TINY_PHONE and 54 or 64)
	valueBadge.BackgroundColor3 = C.Gray100
	valueBadge.ZIndex = 85
	valueBadge.Parent = card
	UI.pill(valueBadge)
	
	local valueLabel = Instance.new("TextLabel")
	valueLabel.Size = UDim2.fromScale(1, 1)
	valueLabel.BackgroundTransparency = 1
	valueLabel.Font = F.Medium
	valueLabel.TextSize = IS_TINY_PHONE and 10 or (IS_SMALL_PHONE and 11 or 12)
	valueLabel.TextColor3 = C.Gray600
	valueLabel.Text = "ðŸ’° Sell: " .. UI.formatMoney(sellPrice)  -- Changed from "Value" to "Sell" for clarity
	valueLabel.ZIndex = 86
	valueLabel.Parent = valueBadge

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- SELL BUTTON (premium with shadow) - CRITICAL UI FIX: Responsive sizing
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	local sellBtnW = IS_TINY_PHONE and 65 or (IS_SMALL_PHONE and 72 or 80)
	local sellBtnH = IS_TINY_PHONE and 40 or (IS_SMALL_PHONE and 45 or 50)
	
	-- Button shadow (CRITICAL FIX: Must be SIBLING of button so emoji/text shows properly)
	local btnShadow = Instance.new("Frame")
	btnShadow.Name = "SellBtnShadow"
	btnShadow.Size = UDim2.new(0, sellBtnW + 4, 0, sellBtnH + 4)
	btnShadow.AnchorPoint = Vector2.new(1, 0.5)
	btnShadow.Position = UDim2.new(1, IS_TINY_PHONE and -4 or -6, 0.5, 2)
	btnShadow.BackgroundColor3 = C.AmberDark
	btnShadow.BackgroundTransparency = 0.6
	btnShadow.ZIndex = 94
	btnShadow.Parent = card
	UI.corner(btnShadow, IS_TINY_PHONE and 10 or 12)
	
	local sellBtn = Instance.new("TextButton")
	sellBtn.Name = "SellBtn"
	sellBtn.Size = UDim2.new(0, sellBtnW, 0, sellBtnH)
	sellBtn.AnchorPoint = Vector2.new(1, 0.5)
	sellBtn.Position = UDim2.new(1, IS_TINY_PHONE and -4 or -8, 0.5, 0)
	sellBtn.BackgroundColor3 = C.Amber
	sellBtn.Font = F.Button
	sellBtn.TextSize = IS_TINY_PHONE and 12 or (IS_SMALL_PHONE and 13 or 14)
	sellBtn.TextColor3 = C.White
	sellBtn.Text = "ðŸ’° Sell"
	sellBtn.AutoButtonColor = false
	sellBtn.ZIndex = 95  -- Higher than shadow and pressArea
	sellBtn.Parent = card
	UI.corner(sellBtn, 12)
	
	local isLoading = false

	sellBtn.MouseEnter:Connect(function()
		if isLoading then return end
		UI.tween(sellBtn, TweenInfo.new(0.12, Enum.EasingStyle.Quad), { 
			Size = UDim2.new(0, 85, 0, 54),
			BackgroundColor3 = C.AmberDark 
		})
		UI.tween(btnShadow, TweenInfo.new(0.12), { Size = UDim2.new(0, 89, 0, 58) })
	end)
	sellBtn.MouseLeave:Connect(function()
		if isLoading then return end
		UI.tween(sellBtn, TweenInfo.new(0.12), { 
			Size = UDim2.new(0, 80, 0, 50),
			BackgroundColor3 = C.Amber 
		})
		UI.tween(btnShadow, TweenInfo.new(0.12), { Size = UDim2.new(0, 84, 0, 54) })
	end)
	sellBtn.MouseButton1Click:Connect(function()
		if isLoading then return end
		isLoading = true
		log("Sell clicked for:", item.id, "type:", itemType)
		
		-- Loading state
		sellBtn.Text = "â³..."
		UI.tween(sellBtn, TweenInfo.new(0.1), { BackgroundColor3 = C.Gray400 })
		
		task.spawn(function()
			task.wait(0.1)
			self:sellAsset(item, itemType)
			
			-- Reset after completion
			task.wait(0.5)
			if sellBtn and sellBtn.Parent then
				isLoading = false
				sellBtn.Text = "ðŸ’° Sell"
				sellBtn.BackgroundColor3 = C.Amber
			end
		end)
	end)
end

function AssetsScreen:sellAsset(item, itemType)
	log("=== SELLING ASSET ===")
	log("Item:", item.name, "ID:", item.id, "Type:", itemType)

	if not SellAsset then
		self:showResult(false, "Server not available", "âŒ")
		return
	end

	-- CRITICAL FIX: Add pcall protection for server calls
	local success, result = pcall(function()
		return SellAsset:InvokeServer(item.id, itemType)
	end)
	if not success then
		logWarn("SellAsset call failed:", result)
		self:showResult(false, "Server error", "âŒ")
		return
	end
	if result then
		log("Sell result:", result.success, result.message)
		self:showResult(result.success, result.message, result.success and "ðŸ’°" or "ðŸ˜”")
	else
		self:showResult(false, "Server error", "âŒ")
	end
end

function AssetsScreen:createAssetCard(parent, item, order, itemType, accentColor, paleColor)
	local age = self:getAge()
	local money = self:getMoney()
	local assets = self:getAssets()
	local accentDark = accentColor:Lerp(C.Black, 0.2)

	local minAge = item.minAge or 0
	local meetsAge = age >= minAge
	local canAfford = money >= item.price
	local alreadyOwns = assets[item.id] ~= nil
	local canBuy = meetsAge and canAfford and not alreadyOwns

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL REVAMP: Premium Card with Shell Structure (like LifeClient popup)
	-- Container -> Shadow -> Shell -> Inner Card
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	-- Container (holds everything)
	local container = Instance.new("Frame")
	container.Name = item.id .. "_Container"
	container.Size = UDim2.new(1, 0, 0, 115)
	container.BackgroundTransparency = 1
	container.LayoutOrder = order
	container.ZIndex = 82
	container.Parent = parent
	
	-- Shadow layer (premium depth)
	local shadow = Instance.new("Frame")
	shadow.Name = "Shadow"
	shadow.Size = UDim2.new(1, 4, 1, 4)
	shadow.Position = UDim2.new(0, 2, 0, 2)
	shadow.BackgroundColor3 = C.Black
	shadow.BackgroundTransparency = alreadyOwns and 0.88 or (canBuy and 0.92 or 0.96)
	shadow.ZIndex = 82
	shadow.Parent = container
	UI.corner(shadow, 20)
	
	-- Colored shell (accent border - green if owned, accent if can buy, gray otherwise)
	local shellColor = alreadyOwns and C.Green or (canBuy and accentColor or C.Gray300)
	local shell = Instance.new("Frame")
	shell.Name = "Shell"
	shell.Size = UDim2.new(1, 0, 1, 0)
	shell.BackgroundColor3 = shellColor
	shell.ZIndex = 83
	shell.Parent = container
	UI.corner(shell, 18)
	
	-- Inner white card
	local card = Instance.new("Frame")
	card.Name = "Card"
	card.Size = UDim2.new(1, -6, 1, -6)
	card.Position = UDim2.new(0, 3, 0, 3)
	card.BackgroundColor3 = C.White
	card.ZIndex = 84
	card.Parent = shell
	UI.corner(card, 16)
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- PREMIUM HOVER & PRESS EFFECTS (only for buyable items)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	if canBuy then
		-- CRITICAL FIX: Reduced width to not cover the Buy button on the right
		local pressArea = Instance.new("TextButton")
		pressArea.Name = "PressArea"
		pressArea.Size = UDim2.new(1, -100, 1, 0)  -- Leave 100px for button
		pressArea.BackgroundTransparency = 1
		pressArea.Text = ""
		pressArea.ZIndex = 90
		pressArea.Parent = container
		
		local isHovering = false
		local isPressed = false
		
		pressArea.MouseEnter:Connect(function()
			if isPressed then return end
			isHovering = true
			UI.tween(container, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
				Size = UDim2.new(1, 0, 0, 119)
			})
			UI.tween(shell, TweenInfo.new(0.12), { BackgroundColor3 = accentDark })
			UI.tween(shadow, TweenInfo.new(0.12), {
				BackgroundTransparency = 0.85,
				Position = UDim2.new(0, 3, 0, 4)
			})
			UI.tween(card, TweenInfo.new(0.12), { BackgroundColor3 = paleColor:Lerp(C.White, 0.85) })
		end)
		
		pressArea.MouseLeave:Connect(function()
			isHovering = false
			isPressed = false
			UI.tween(container, TweenInfo.new(0.15, Enum.EasingStyle.Quad), {
				Size = UDim2.new(1, 0, 0, 115)
			})
			UI.tween(shell, TweenInfo.new(0.12), { BackgroundColor3 = accentColor })
			UI.tween(shadow, TweenInfo.new(0.12), {
				BackgroundTransparency = 0.92,
				Position = UDim2.new(0, 2, 0, 2)
			})
			UI.tween(card, TweenInfo.new(0.12), { BackgroundColor3 = C.White })
		end)
		
		pressArea.MouseButton1Down:Connect(function()
			isPressed = true
			UI.tween(container, TweenInfo.new(0.08), {
				Size = UDim2.new(1, 0, 0, 111)
			})
			UI.tween(shell, TweenInfo.new(0.08), { BackgroundColor3 = accentDark:Lerp(C.Black, 0.1) })
		end)
		
		pressArea.MouseButton1Up:Connect(function()
			isPressed = false
			if isHovering then
				UI.tween(container, TweenInfo.new(0.1), {
					Size = UDim2.new(1, 0, 0, 119)
				})
				UI.tween(shell, TweenInfo.new(0.1), { BackgroundColor3 = accentDark })
			end
		end)
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- ICON (with ring for owned items)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	-- Icon ring (shows ownership status)
	local iconRing = Instance.new("Frame")
	iconRing.Size = UDim2.new(0, 68, 0, 68)
	iconRing.Position = UDim2.new(0, 12, 0.5, -34)
	iconRing.BackgroundColor3 = alreadyOwns and C.Green or (canBuy and accentColor or C.Gray400)
	iconRing.ZIndex = 85
	iconRing.Parent = card
	UI.corner(iconRing, 18)
	
	local iconFrame = Instance.new("Frame")
	iconFrame.Size = UDim2.new(1, -6, 1, -6)
	iconFrame.Position = UDim2.new(0, 3, 0, 3)
	iconFrame.BackgroundColor3 = alreadyOwns and C.GreenPale or (canBuy and paleColor or C.Gray200)
	iconFrame.ZIndex = 86
	iconFrame.Parent = iconRing
	UI.corner(iconFrame, 16)
	
	-- Gradient for premium look
	if canBuy and not alreadyOwns then
		local iconGrad = Instance.new("UIGradient")
		iconGrad.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0, Color3.new(1, 1, 1)),
			ColorSequenceKeypoint.new(1, paleColor:Lerp(C.White, 0.3)),
		})
		iconGrad.Rotation = 135
		iconGrad.Parent = iconFrame
	end

	local iconLabel = Instance.new("TextLabel")
	iconLabel.Size = UDim2.fromScale(1, 1)
	iconLabel.BackgroundTransparency = 1
	iconLabel.Font = F.Body
	iconLabel.TextSize = 36
	iconLabel.Text = item.emoji
	iconLabel.TextTransparency = (not canBuy and not alreadyOwns) and 0.3 or 0
	iconLabel.ZIndex = 87
	iconLabel.Parent = iconFrame

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CONTENT
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	-- Owned badge (prominent)
	if alreadyOwns then
		local badge = Instance.new("Frame")
		badge.Size = UDim2.new(0, 90, 0, 26)
		badge.Position = UDim2.new(0, 92, 0, 8)
		badge.BackgroundColor3 = C.Green
		badge.ZIndex = 86
		badge.Parent = card
		UI.pill(badge)

		local badgeLabel = Instance.new("TextLabel")
		badgeLabel.Size = UDim2.fromScale(1, 1)
		badgeLabel.BackgroundTransparency = 1
		badgeLabel.Font = F.Button
		badgeLabel.TextSize = 12
		badgeLabel.TextColor3 = C.White
		badgeLabel.Text = "âœ“ OWNED"
		badgeLabel.ZIndex = 87
		badgeLabel.Parent = badge
	end

	-- Title (CRITICAL FIX: Added truncation to prevent overflow)
	local titleLabel = Instance.new("TextLabel")
	titleLabel.Size = UDim2.new(0.5, -95, 0, 26)  -- Adjusted width with margin
	titleLabel.Position = UDim2.new(0, 92, 0, alreadyOwns and 36 or 10)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Font = F.Title
	titleLabel.TextSize = 16  -- Slightly smaller for longer names
	titleLabel.TextColor3 = C.Gray900
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.TextTruncate = Enum.TextTruncate.AtEnd
	titleLabel.Text = item.name
	titleLabel.ZIndex = 85
	titleLabel.Parent = card

	-- Badges row
	local badgeY = alreadyOwns and 66 or 40

	-- Price badge (more prominent)
	local priceBadge = Instance.new("Frame")
	priceBadge.Size = UDim2.new(0, 95, 0, 28)
	priceBadge.Position = UDim2.new(0, 92, 0, badgeY)
	priceBadge.BackgroundColor3 = canAfford and C.GreenPale or C.RedPale
	priceBadge.ZIndex = 85
	priceBadge.Parent = card
	UI.pill(priceBadge)

	local priceLabel = Instance.new("TextLabel")
	priceLabel.Size = UDim2.fromScale(1, 1)
	priceLabel.BackgroundTransparency = 1
	priceLabel.Font = F.Button
	priceLabel.TextSize = 12
	priceLabel.TextColor3 = canAfford and C.GreenDark or C.RedDark
	priceLabel.Text = "ðŸ’µ " .. UI.formatMoney(item.price)
	priceLabel.ZIndex = 86
	priceLabel.Parent = priceBadge

	-- Income badge (for property)
	if item.income then
		local incomeBadge = Instance.new("Frame")
		incomeBadge.Size = UDim2.new(0, 95, 0, 28)
		incomeBadge.Position = UDim2.new(0, 192, 0, badgeY)
		incomeBadge.BackgroundColor3 = C.AmberPale
		incomeBadge.ZIndex = 85
		incomeBadge.Parent = card
		UI.pill(incomeBadge)

		local incomeLabel = Instance.new("TextLabel")
		incomeLabel.Size = UDim2.fromScale(1, 1)
		incomeLabel.BackgroundTransparency = 1
		incomeLabel.Font = F.Button
		incomeLabel.TextSize = 11
		incomeLabel.TextColor3 = C.AmberDark
		incomeLabel.Text = "ðŸ“ˆ +" .. UI.formatMoney(item.income) .. "/yr"
		incomeLabel.ZIndex = 86
		incomeLabel.Parent = incomeBadge
	end

	-- Age requirement
	if not alreadyOwns and minAge > 0 then
		local reqBadge = Instance.new("Frame")
		reqBadge.Size = UDim2.new(0, 60, 0, 20)
		reqBadge.Position = UDim2.new(0, 92, 0, badgeY + 32)
		reqBadge.BackgroundColor3 = meetsAge and C.Gray100 or C.RedPale
		reqBadge.ZIndex = 85
		reqBadge.Parent = card
		UI.pill(reqBadge)
		
		local reqLabel = Instance.new("TextLabel")
		reqLabel.Size = UDim2.fromScale(1, 1)
		reqLabel.BackgroundTransparency = 1
		reqLabel.Font = F.Medium
		reqLabel.TextSize = 10
		reqLabel.TextColor3 = meetsAge and C.Gray500 or C.RedDark
		reqLabel.Text = "ðŸŽ‚ Age " .. minAge
		reqLabel.ZIndex = 86
		reqLabel.Parent = reqBadge
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- BUY BUTTON (premium with shadow)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	if not alreadyOwns then
		-- Button shadow (CRITICAL FIX: Must be SIBLING of button so emoji/text shows properly)
		local btnShadow
		if canBuy then
			btnShadow = Instance.new("Frame")
			btnShadow.Name = "BuyBtnShadow"
			btnShadow.Size = UDim2.new(0, 89, 0, 58)
			btnShadow.AnchorPoint = Vector2.new(1, 0.5)
			btnShadow.Position = UDim2.new(1, -6, 0.5, 2)
			btnShadow.BackgroundColor3 = accentDark
			btnShadow.BackgroundTransparency = 0.6
			btnShadow.ZIndex = 94
			btnShadow.Parent = card
			UI.corner(btnShadow, 14)
		end

		local buyBtn = Instance.new("TextButton")
		buyBtn.Name = "BuyBtn"
		buyBtn.Size = UDim2.new(0, 85, 0, 54)
		buyBtn.AnchorPoint = Vector2.new(1, 0.5)
		buyBtn.Position = UDim2.new(1, -8, 0.5, 0)
		buyBtn.BackgroundColor3 = canBuy and accentColor or C.Gray300
		buyBtn.Font = F.Button
		buyBtn.TextSize = 15
		buyBtn.TextColor3 = canBuy and C.White or C.Gray500
		buyBtn.AutoButtonColor = false
		buyBtn.ZIndex = 95  -- Higher than shadow and pressArea
		buyBtn.Parent = card
		UI.corner(buyBtn, 14)

		if canBuy then
			local isLoading = false
			buyBtn.Text = "ðŸ›’ Buy"
			
			buyBtn.MouseEnter:Connect(function()
				if isLoading then return end
				UI.tween(buyBtn, TweenInfo.new(0.12, Enum.EasingStyle.Quad), { 
					Size = UDim2.new(0, 90, 0, 58),
					BackgroundColor3 = accentDark
				})
				if btnShadow then
					UI.tween(btnShadow, TweenInfo.new(0.12), { Size = UDim2.new(0, 94, 0, 62) })
				end
			end)
			buyBtn.MouseLeave:Connect(function()
				if isLoading then return end
				UI.tween(buyBtn, TweenInfo.new(0.12), { 
					Size = UDim2.new(0, 85, 0, 54),
					BackgroundColor3 = accentColor
				})
				if btnShadow then
					UI.tween(btnShadow, TweenInfo.new(0.12), { Size = UDim2.new(0, 89, 0, 58) })
				end
			end)
			buyBtn.MouseButton1Click:Connect(function()
				if isLoading then return end
				isLoading = true
				
				-- Loading state
				buyBtn.Text = "â³..."
				UI.tween(buyBtn, TweenInfo.new(0.1), { BackgroundColor3 = C.Gray400 })
				
				task.spawn(function()
					task.wait(0.1)
					self:buyAsset(item, itemType)
					
					-- Reset after completion
					task.wait(0.5)
					if buyBtn and buyBtn.Parent then
						isLoading = false
						buyBtn.Text = "ðŸ›’ Buy"
						buyBtn.BackgroundColor3 = accentColor
					end
				end)
			end)
		else
			local btnText = "ðŸ”’ "
			if not meetsAge then
				btnText = btnText .. "Age " .. minAge
			else
				btnText = "ðŸ’µ Need $"
			end
			buyBtn.Text = btnText
		end
	end
end

function AssetsScreen:buyAsset(item, itemType)
	local remote = nil
	if itemType == "property" then remote = BuyProperty
	elseif itemType == "vehicle" then remote = BuyVehicle
	else remote = BuyItem end

	if not remote then
		self:showResult(false, "Server not available", "âŒ")
		return
	end

	-- CRITICAL FIX: Add pcall protection for server calls
	local success, result = pcall(function()
		return remote:InvokeServer(item.id)
	end)
	if not success then
		logWarn("BuyAsset call failed:", result)
		self:showResult(false, "Server error", "âŒ")
		return
	end
	if result then
		self:showResult(result.success, result.message, result.success and "ðŸŽ‰" or "ðŸ˜”")
		
		-- CRITICAL FIX: Refresh the assets screen after successful purchase
		-- Without this, purchased items don't show in "owned" sections!
		if result.success then
			-- Update local state with the new asset
			self.playerState = self.playerState or {}
			self.playerState.Assets = self.playerState.Assets or {}
			
			local assetTypeName
			if itemType == "property" then
				assetTypeName = "Properties"
			elseif itemType == "vehicle" then
				assetTypeName = "Vehicles"
			else
				assetTypeName = "Items"
			end
			
			self.playerState.Assets[assetTypeName] = self.playerState.Assets[assetTypeName] or {}
			table.insert(self.playerState.Assets[assetTypeName], {
				id = item.id,
				name = item.name,
				emoji = item.emoji,
				value = item.price,
				price = item.price,
			})
			
			-- Deduct money locally to keep UI in sync
			if self.playerState.Money then
				self.playerState.Money = self.playerState.Money - item.price
			end
			
			-- Refresh the current tab to show the owned item
			task.delay(0.5, function()
				if self.isVisible then
					self:switchTab(self.currentTab)
					log("âœ… Refreshed assets screen after purchase")
				end
			end)
		end
	else
		self:showResult(false, "Server error", "âŒ")
	end
end

function AssetsScreen:showGambling()
	if self:getAge() < 21 then
		self:showResult(false, "You must be 21 or older to gamble!", "ðŸ”ž")
		return
	end

	self.gamblingOverlay.Visible = true
	self.gamblingCard.Position = UDim2.new(0.5, 0, 0.5, 50)
	self.gamblingCard.BackgroundTransparency = 1
	self.spinResult.Text = ""

	UI.tween(self.gamblingCard, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Position = UDim2.fromScale(0.5, 0.5),
		BackgroundTransparency = 0
	})
end

function AssetsScreen:hideGambling()
	local t = UI.tween(self.gamblingCard, TweenInfo.new(0.2), {
		Position = UDim2.new(0.5, 0, 0.5, 50),
		BackgroundTransparency = 1
	})
	t.Completed:Connect(function()
		self.gamblingOverlay.Visible = false
		self:updateBalanceBar()
		self:switchTab(self.currentTab)
	end)
end

function AssetsScreen:spin()
	if self.isSpinning then return end
	if self:getMoney() < self.betAmount then
		self.spinResult.Text = "Not enough money!"
		self.spinResult.TextColor3 = C.Red
		return
	end

	self.isSpinning = true
	self.spinBtn.BackgroundColor3 = C.Gray500
	self.spinResult.Text = ""

	local symbols = { "ðŸ’", "ðŸ‹", "ðŸŠ", "ðŸ‡", "â­", "7ï¸âƒ£", "ðŸ’Ž" }
	local finalSymbols = {}

	for spin = 1, 20 do
		task.wait(0.05 + spin * 0.01)
		for i = 1, 3 do
			local sym = symbols[math.random(1, #symbols)]
			self.slotLabels[i].Text = sym
			if spin == 20 then finalSymbols[i] = sym end
		end
	end

	task.delay(0.3, function()
		if Gamble then
			-- CRITICAL FIX: Add pcall protection for server calls
			local success, result = pcall(function()
				return Gamble:InvokeServer(self.betAmount, finalSymbols)
			end)
			if success and result then
				if result.success then
					self.spinResult.Text = "ðŸŽ‰ You won " .. UI.formatMoney(result.winnings) .. "!"
					self.spinResult.TextColor3 = C.Green
				else
					self.spinResult.Text = result.message or "Better luck next time!"
					self.spinResult.TextColor3 = C.Red
				end
			elseif not success then
				self.spinResult.Text = "Server error"
				self.spinResult.TextColor3 = C.Red
			end
		else
			local won = finalSymbols[1] == finalSymbols[2] and finalSymbols[2] == finalSymbols[3]
			if won then
				self.spinResult.Text = "ðŸŽ‰ JACKPOT! You won " .. UI.formatMoney(self.betAmount * 5) .. "!"
				self.spinResult.TextColor3 = C.Green
			elseif finalSymbols[1] == finalSymbols[2] or finalSymbols[2] == finalSymbols[3] then
				self.spinResult.Text = "Nice! You won " .. UI.formatMoney(self.betAmount) .. "!"
				self.spinResult.TextColor3 = C.Gold
			else
				self.spinResult.Text = "Better luck next time!"
				self.spinResult.TextColor3 = C.Red
			end
		end

		self.isSpinning = false
		self.spinBtn.BackgroundColor3 = C.Green
		self:updateBalanceBar()
	end)
end

function AssetsScreen:showResult(success, message, emoji)
	local shellColor = success and C.Green or C.Red
	local shellStroke = success and C.GreenDark or C.RedDark
	local pale = success and C.GreenPale or C.RedPale

	self.resultModal.shell.BackgroundColor3 = shellColor
	self.resultModal.shellStroke.Color = shellStroke
	self.resultModal.emojiFrame.BackgroundColor3 = pale
	
	-- Better emoji handling
	local displayEmoji = emoji
	if not displayEmoji then
		displayEmoji = success and "ðŸŽ‰" or "ðŸ˜”"
	elseif displayEmoji == "ðŸ’°" then
		displayEmoji = "ðŸ’¸"
	end
	self.resultModal.emojiLabel.Text = displayEmoji
	
	self.resultModal.titleLabel.Text = success and "Purchase Complete!" or "Uh oh..."
	self.resultModal.titleLabel.TextColor3 = success and C.GreenDark or C.RedDark
	self.resultModal.messageLabel.Text = message or ""
	self.resultModal.okButton.BackgroundColor3 = shellColor
	self.resultModal.okButton.Text = success and "ðŸ‘ Nice!" or "ðŸ˜” Okay..."

	-- Use custom show method if available
	if self.resultModal.show then
		self.resultModal.show()
	elseif UI.showModal then
		UI.showModal(self.resultModal)
	end
end

function AssetsScreen:show()
	log("=== SHOWING AssetsScreen ===")
	log("Current state - Age:", self:getAge(), "Money:", self:getMoney())
	self:updateBalanceBar()
	self:switchTab(self.currentTab)
	UI.slideInScreen(self.overlay, "right")
	self.isVisible = true
	log("âœ… AssetsScreen is now visible")
end

function AssetsScreen:hide()
	log("=== HIDING AssetsScreen ===")
	UI.slideOutScreen(self.overlay, "right", function()
		-- CRITICAL FIX: Add nil checks before accessing overlay properties
		-- resultModal.overlay might not exist if modal wasn't initialized
		if self.resultModal and self.resultModal.overlay then
			self.resultModal.overlay.Visible = false
		end
		-- CRITICAL FIX: gamblingOverlay was removed (Casino feature disabled)
		-- Add nil check to prevent "attempt to index nil" errors
		if self.gamblingOverlay then
			self.gamblingOverlay.Visible = false
		end
		log("âœ… AssetsScreen hidden, modals cleaned up")
	end)
	self.isVisible = false
end

-- CRITICAL DEBUG: Verify module before return
print("[AssetsScreen] âœ“ Module fully loaded, .new exists:", AssetsScreen.new ~= nil)
print("[AssetsScreen] âœ“ Type of AssetsScreen:", type(AssetsScreen))
print("[AssetsScreen] âœ“ Type of .new:", type(AssetsScreen.new))

return AssetsScreen
