-- StarterPlayerScripts / LifeClient (LocalScript)
-- BitLife-style UI: POLISHED AAA-quality recreation
-- Fixed: Header avoids Roblox logo, stats don't conflict with Age button
-- Professional modals, smooth animations, premium feel

local startTime = tick()

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService      = game:GetService("TweenService")
local MarketplaceService = game:GetService("MarketplaceService")

local player = Players.LocalPlayer

----------------------------------------------------------------
-- SCREEN MODULES (with error handling) - PARALLEL LOADING
----------------------------------------------------------------

local ScreensFolder = ReplicatedStorage:WaitForChild("Screens", 3) -- Reduced timeout

local OccupationScreen, AssetsScreen, RelationshipsScreen, ActivitiesScreen, StoryPathsScreen, MafiaScreen
local MinigamesModule

if ScreensFolder then
	-- Load modules in parallel using coroutines for faster startup
	local function safeRequire(name)
		local child = ScreensFolder:FindFirstChild(name)
		if child then
			local s, r = pcall(require, child)
			if not s then
				warn("[LifeClient] âŒ Failed to require", name, ":", r)
			end
			return s and r or nil
		else
			-- Don't warn for optional modules like MafiaScreen
			if name ~= "MafiaScreen" then
				warn("[LifeClient] âŒ Module not found:", name)
			end
		end
		return nil
	end

	-- Fast parallel loading - no WaitForChild delays
	OccupationScreen    = safeRequire("OccupationScreen")
	AssetsScreen        = safeRequire("AssetsScreen")
	RelationshipsScreen = safeRequire("RelationshipsScreen")
	ActivitiesScreen    = safeRequire("ActivitiesScreen")
	StoryPathsScreen    = safeRequire("StoryPathsScreen")
	MafiaScreen         = safeRequire("MafiaScreen")
end

-- Minigames module (directly in ReplicatedStorage) - wait for it!
local function safeRequireRS(name)
	-- Try immediate find first, then wait if not found
	local child = ReplicatedStorage:FindFirstChild(name)
	if not child then
		child = ReplicatedStorage:WaitForChild(name, 5)
	end
	if child then
		local s, r = pcall(require, child)
		if s then return r end
	end
	return nil
end
MinigamesModule = safeRequireRS("Minigames")

----------------------------------------------------------------
-- REMOTES (robust - wait for server to create them)
----------------------------------------------------------------

-- Wait for the remotes folder (server creates it on startup)
local remotesFolder = nil
local function waitForRemotes()
	-- Try LifeRemotes first
	remotesFolder = ReplicatedStorage:WaitForChild("LifeRemotes", 10)
	if not remotesFolder then
		-- Fallback to "Life" folder
		remotesFolder = ReplicatedStorage:WaitForChild("Life", 5)
	end
	if not remotesFolder then
		warn("[LifeClient] Could not find remotes folder! Server may not have initialized.")
		return false
	end
	return true
end

-- Wait for remotes before continuing
if not waitForRemotes() then
	-- Create a placeholder folder to prevent nil errors
	-- The game won't work properly, but at least it won't crash
	warn("[LifeClient] Creating placeholder remotes folder - game will not function correctly!")
	remotesFolder = Instance.new("Folder")
	remotesFolder.Name = "LifeRemotesPlaceholder"
	remotesFolder.Parent = ReplicatedStorage
end

-- Use FindFirstChild first, then WaitForChild as fallback
local function getRemote(name, timeout)
	if not remotesFolder then
		warn("[LifeClient] Remotes folder is nil when getting:", name)
		return nil
	end
	local remote = remotesFolder:FindFirstChild(name)
	if not remote then
		remote = remotesFolder:WaitForChild(name, timeout or 5)
	end
	return remote
end

local RequestAgeUp     = getRemote("RequestAgeUp")
local PresentEvent     = getRemote("PresentEvent")
local SubmitChoice     = getRemote("SubmitChoice")
local SyncState        = getRemote("SyncState")
local SetLifeInfo      = getRemote("SetLifeInfo")
local MinigameResult   = getRemote("MinigameResult", 2)
local MinigameStart    = getRemote("MinigameStart", 2)
local CheckGamepass    = getRemote("CheckGamepass", 2)
local PromptGamepass   = getRemote("PromptGamepass", 2)
local GodModeEdit      = getRemote("GodModeEdit", 2)

----------------------------------------------------------------
-- STATE
----------------------------------------------------------------

-- Base birth year for all characters (consistent year calculation)
local BIRTH_YEAR = 2025

local currentState = {
	Name = nil, Age = 0, Money = 0,
	Happiness = 50, Health = 100, Smarts = 50, Looks = 50,
	Education = "None", Experience = 0, CurrentJob = nil, InJail = false,
	-- CRITICAL: Initialize Assets structure to prevent nil errors
	Assets = { Properties = {}, Vehicles = {}, Items = {}, Crypto = {} },
	Relationships = {},
	Flags = {},
}

local awaitingEvent          = false
local hasShownAgeHint        = false
local introComplete          = false
local selectedGender         = nil

local ScreenInstances = {
	occupation = nil,
	assets = nil,
	relationships = nil,
	activities = nil,
	storypaths = nil,
	mafia = nil,
}
local minigamesInstance
local pendingMinigameEventId     = nil
local pendingMinigameChoiceIndex = nil
-- CRITICAL FIX #421: Cache ALL gamepass statuses to prevent reset on purchase
-- These are set to true immediately when purchased and NEVER set back to false
local hasGodMode = false
local hasRoyalty = false
local hasMafia = false
local hasCelebrity = false
local hasTimeMachine = false
local godModeOverlay = nil
local godModeButton = nil
local destroyGodModeModal
local showGodModeModal
local updateGodModeButtonAppearance

-- CRITICAL FIX #419: These refresh functions must NEVER downgrade true to false!
-- When a gamepass is purchased, we set hasGodMode = true immediately.
-- But the server might still return false due to caching delays.
-- So we ONLY update if the server says true (upgrading false to true).
-- We NEVER set hasGodMode = false if it's already true!
local function refreshGodModeStatus()
	-- If already true, don't even check - can't lose a purchased gamepass
	if hasGodMode then
		return true
	end
	if not CheckGamepass then
		return hasGodMode
	end
	local success, owns = pcall(function()
		return CheckGamepass:InvokeServer("GOD_MODE")
	end)
	if success and owns == true then
		hasGodMode = true  -- ONLY upgrade to true, never downgrade
	end
	return hasGodMode
end

-- CRITICAL FIX #420: Same logic for Royalty - NEVER downgrade true to false!
local function refreshRoyaltyStatus()
	-- If already true, don't even check - can't lose a purchased gamepass
	if hasRoyalty then
		return true
	end
	if not CheckGamepass then
		return hasRoyalty
	end
	local success, owns = pcall(function()
		return CheckGamepass:InvokeServer("ROYALTY")
	end)
	if success and owns == true then
		hasRoyalty = true  -- ONLY upgrade to true, never downgrade
	end
	return hasRoyalty
end

refreshGodModeStatus()
refreshRoyaltyStatus()

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: Listen for gamepass purchases to update UI smoothly
-- When user buys a gamepass, update all related buttons immediately
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local GAMEPASS_IDS = {
	ROYALTY = 1626378001,
	GOD_MODE = 1628050729,
	MAFIA = 1626238769,
	CELEBRITY = 1626461980,
	TIME_MACHINE = 1630681215,
}

local function onGamepassPurchaseFinished(plr, gamePassId, wasPurchased)
	if plr ~= player or not wasPurchased then return end
	
	print("[LifeClient] Gamepass purchase finished:", gamePassId, wasPurchased)
	
	-- CRITICAL FIX #422: Force set gamepass ownership immediately based on purchase
	-- This bypasses any caching delays from the server
	-- These values are NEVER set back to false once true!
	if gamePassId == GAMEPASS_IDS.GOD_MODE then
		hasGodMode = true
		print("[LifeClient] God Mode gamepass purchased - immediately enabling!")
	elseif gamePassId == GAMEPASS_IDS.ROYALTY then
		hasRoyalty = true
		print("[LifeClient] Royalty gamepass purchased - immediately enabling!")
	elseif gamePassId == GAMEPASS_IDS.MAFIA then
		hasMafia = true
		print("[LifeClient] Mafia gamepass purchased - immediately enabling!")
	elseif gamePassId == GAMEPASS_IDS.CELEBRITY then
		hasCelebrity = true
		print("[LifeClient] Celebrity gamepass purchased - immediately enabling!")
	elseif gamePassId == GAMEPASS_IDS.TIME_MACHINE then
		hasTimeMachine = true
		print("[LifeClient] Time Machine gamepass purchased - immediately enabling!")
	end
	
	-- CRITICAL FIX #405: Multiple retries to handle Roblox API delays
	-- The ownership might not be immediately reflected in MarketplaceService
	local function updateAllGamepassUI()
		refreshGodModeStatus()
		refreshRoyaltyStatus()  -- CRITICAL FIX #414: Also refresh royalty status
		
		-- Update God Mode button
		if IntroUI and IntroUI.updateCustomizeGenderBtn then
			IntroUI.updateCustomizeGenderBtn()
		end
		
		-- Update Royalty button
		if IntroUI and IntroUI.updateRoyaltyGenderBtn then
			IntroUI.updateRoyaltyGenderBtn()
		end
		
		-- CRITICAL FIX #417: Update God Mode wealth buttons if royalty purchased
		if IntroUI and IntroUI.updateWealthButtons then
			IntroUI.updateWealthButtons()
		end
		
		-- CRITICAL FIX #365: Update Time Machine UI if death overlay is showing
		if DeathUI and DeathUI.updateTimeMachineUI then
			DeathUI.updateTimeMachineUI()
		end
		
		-- CRITICAL FIX #406: Update God Mode in-game button if it exists
		if updateGodModeButtonAppearance then
			pcall(updateGodModeButtonAppearance)
		end
		
		-- Update main UI
		if updateFromState then
			pcall(updateFromState)
		end
	end
	
	-- Immediate update
	task.defer(updateAllGamepassUI)
	
	-- CRITICAL FIX #407: Retry after short delays to catch API propagation
	task.delay(0.5, updateAllGamepassUI)
	task.delay(1.5, updateAllGamepassUI)
end

MarketplaceService.PromptGamePassPurchaseFinished:Connect(onGamepassPurchaseFinished)

-- CRITICAL FIX #367: Listen for server-side gamepass purchase notification
-- This fires AFTER the purchase is verified and state is updated
local GamepassPurchased = remotesFolder and remotesFolder:FindFirstChild("GamepassPurchased")
if GamepassPurchased then
	GamepassPurchased.OnClientEvent:Connect(function(gamepassKey)
		print("[LifeClient] Server confirmed gamepass purchased:", gamepassKey)
		
		-- CRITICAL FIX #423: Immediately set gamepass flags based on server confirmation
		-- These are PERMANENT - never set back to false!
		if gamepassKey == "GOD_MODE" then
			hasGodMode = true
		elseif gamepassKey == "ROYALTY" then
			hasRoyalty = true
		elseif gamepassKey == "MAFIA" then
			hasMafia = true
		elseif gamepassKey == "CELEBRITY" then
			hasCelebrity = true
		elseif gamepassKey == "TIME_MACHINE" then
			hasTimeMachine = true
		end
		
		-- CRITICAL FIX #409: Update client state GamepassOwnership immediately
		if currentState then
			currentState.GamepassOwnership = currentState.GamepassOwnership or {}
			if gamepassKey == "GOD_MODE" then
				currentState.GamepassOwnership.godMode = true
				currentState.Flags = currentState.Flags or {}
				currentState.Flags.god_mode_gamepass = true
			elseif gamepassKey == "ROYALTY" then
				currentState.GamepassOwnership.royalty = true
				currentState.Flags = currentState.Flags or {}
				currentState.Flags.royalty_gamepass = true
			elseif gamepassKey == "MAFIA" then
				currentState.GamepassOwnership.mafia = true
				currentState.Flags = currentState.Flags or {}
				currentState.Flags.mafia_gamepass = true
			elseif gamepassKey == "CELEBRITY" then
				currentState.GamepassOwnership.celebrity = true
				currentState.Flags = currentState.Flags or {}
				currentState.Flags.celebrity_gamepass = true
			elseif gamepassKey == "TIME_MACHINE" then
				currentState.GamepassOwnership.timeMachine = true
				currentState.Flags = currentState.Flags or {}
				currentState.Flags.time_machine_gamepass = true
			end
		end
		
		-- Refresh server check as well
		refreshGodModeStatus()
		
		task.defer(function()
			-- Update intro UI buttons
			if IntroUI and IntroUI.updateCustomizeGenderBtn then
				IntroUI.updateCustomizeGenderBtn()
			end
			if IntroUI and IntroUI.updateRoyaltyGenderBtn then
				IntroUI.updateRoyaltyGenderBtn()
			end
			
			-- CRITICAL FIX #418: Update God Mode wealth buttons if royalty purchased
			if IntroUI and IntroUI.updateWealthButtons then
				IntroUI.updateWealthButtons()
			end
			
			-- Update Time Machine
			if DeathUI and DeathUI.updateTimeMachineUI then
				DeathUI.updateTimeMachineUI()
			end
			
			-- CRITICAL FIX #410: Update God Mode button appearance
			if updateGodModeButtonAppearance then
				pcall(updateGodModeButtonAppearance)
			end
			
			-- Force refresh the main UI
			if updateFromState then
				updateFromState()
			end
		end)
	end)
end

-- CRITICAL FIX #369: Listen for Developer Product purchase completion
-- When a time machine product is purchased, the ProcessReceipt handles it on server
-- The server will send a SyncState update which triggers hideDeathOverlay
MarketplaceService.PromptProductPurchaseFinished:Connect(function(userId, productId, wasPurchased)
	if userId ~= player.UserId or not wasPurchased then return end
	
	print("[LifeClient] Developer Product purchased:", productId)
	
	-- Time Machine product IDs
	local TIME_PRODUCTS = {
		[3477466389] = 5,   -- 5 years
		[3477466522] = 10,  -- 10 years
		[3477466619] = 20,  -- 20 years
		[3477466778] = -1,  -- Baby
	}
	
	if TIME_PRODUCTS[productId] then
		print("[LifeClient] Time Machine product purchased, waiting for server to process...")
		-- Server's ProcessReceipt will handle the time travel and send SyncState
		-- The SyncState handler will update the UI and hide death overlay
	end
end)

-- Forward declarations
local showEvent, hideEvent
local showIntro, hideIntro
local showTutorial, hideTutorial
local showDeathOverlay, hideDeathOverlay
local updateNameButtons
local updateFromState

-- Helper: Calculate current year from age
local function getCurrentYear(age)
	return BIRTH_YEAR + (age or 0)
end

----------------------------------------------------------------
-- COLORS (Premium BitLife Palette)
----------------------------------------------------------------

local C = {
	-- Primary Blues
	Blue      = Color3.fromRGB(37, 99, 235),
	BlueDark  = Color3.fromRGB(29, 78, 216),
	BlueLight = Color3.fromRGB(96, 165, 250),
	BluePale  = Color3.fromRGB(219, 234, 254),

	-- Greens
	Green      = Color3.fromRGB(34, 197, 94),
	GreenDark  = Color3.fromRGB(22, 163, 74),
	GreenRing  = Color3.fromRGB(21, 128, 61),
	GreenPale  = Color3.fromRGB(220, 252, 231),

	-- Accents
	Red      = Color3.fromRGB(239, 68, 68),
	RedDark  = Color3.fromRGB(220, 38, 38),
	RedPale  = Color3.fromRGB(254, 226, 226),
	Orange   = Color3.fromRGB(249, 115, 22),
	Pink     = Color3.fromRGB(244, 114, 182),
	PinkDark = Color3.fromRGB(219, 39, 119),
	PinkPale = Color3.fromRGB(252, 231, 243),
	Purple   = Color3.fromRGB(168, 85, 247),
	Yellow   = Color3.fromRGB(253, 224, 71),
	Amber    = Color3.fromRGB(245, 158, 11),

	-- Gender
	Male   = Color3.fromRGB(56, 189, 248),
	Female = Color3.fromRGB(244, 114, 182),

	-- Neutrals
	White    = Color3.fromRGB(255, 255, 255),
	OffWhite = Color3.fromRGB(250, 250, 250),
	Gray50   = Color3.fromRGB(249, 250, 251),
	Gray100  = Color3.fromRGB(243, 244, 246),
	Gray200  = Color3.fromRGB(229, 231, 235),
	Gray300  = Color3.fromRGB(209, 213, 219),
	Gray400  = Color3.fromRGB(156, 163, 175),
	Gray500  = Color3.fromRGB(107, 114, 128),
	Gray600  = Color3.fromRGB(75, 85, 99),
	Gray700  = Color3.fromRGB(55, 65, 81),
	Gray800  = Color3.fromRGB(31, 41, 55),
	Gray900  = Color3.fromRGB(17, 24, 39),

	-- Nav
	NavBlue = Color3.fromRGB(30, 58, 138),
	NavDark = Color3.fromRGB(23, 37, 84),

	-- Overlay
	Black = Color3.fromRGB(0, 0, 0),
	
	-- Background
	Bg = Color3.fromRGB(249, 250, 251), -- Same as Gray50
}

local F = {
	Title  = Enum.Font.GothamBold,
	Body   = Enum.Font.Gotham,
	Medium = Enum.Font.GothamMedium,
	Button = Enum.Font.GothamBold,
}

local function ensureSharedUITheme()
	local sharedUI = safeRequireRS("UIComponents")
	if not sharedUI then
		return
	end

	sharedUI.Colors = sharedUI.Colors or {}
	for name, value in pairs(C) do
		if sharedUI.Colors[name] == nil then
			sharedUI.Colors[name] = value
		end
	end

	-- Additional palette entries used by the standalone screens
	local extraColors = {
		Bg        = Color3.fromRGB(246, 248, 252),
		Teal      = Color3.fromRGB(20, 184, 166),
		TealDark  = Color3.fromRGB(13, 148, 136),
		TealPale  = Color3.fromRGB(204, 251, 241),
		Cyan      = Color3.fromRGB(14, 165, 233),
		CyanDark  = Color3.fromRGB(21, 94, 117),
		CyanPale  = Color3.fromRGB(224, 242, 254),
		Gold      = Color3.fromRGB(251, 191, 36),
		GoldDark  = Color3.fromRGB(217, 119, 6),
		GoldPale  = Color3.fromRGB(254, 243, 199),
		AmberDark = Color3.fromRGB(217, 119, 6),
		AmberPale = Color3.fromRGB(254, 243, 199),
		PurplePale= Color3.fromRGB(243, 232, 255),
		Gray950   = Color3.fromRGB(2, 6, 23),
	}
	for name, value in pairs(extraColors) do
		if sharedUI.Colors[name] == nil then
			sharedUI.Colors[name] = value
		end
	end

	sharedUI.Fonts = sharedUI.Fonts or {}
	for name, font in pairs(F) do
		if sharedUI.Fonts[name] == nil then
			sharedUI.Fonts[name] = font
		end
	end

	if not sharedUI.formatMoney then
		function sharedUI.formatMoney(amount)
			if not amount then return "$0" end
			if amount >= 1_000_000 then
				return string.format("$%.1fM", amount / 1_000_000)
			elseif amount >= 1_000 then
				return string.format("$%.1fK", amount / 1_000)
			else
				return "$" .. tostring(math.floor(amount + 0.5))
			end
		end
	end
end

ensureSharedUITheme()

----------------------------------------------------------------
-- HELPERS
----------------------------------------------------------------

local function corner(p, r)
	local c = Instance.new("UICorner")
	c.CornerRadius = UDim.new(0, r)
	c.Parent = p
	return c
end

local function pill(p)
	local c = Instance.new("UICorner")
	c.CornerRadius = UDim.new(0.5, 0)
	c.Parent = p
	return c
end

local function stroke(p, t, tr, col)
	local s = Instance.new("UIStroke")
	s.Thickness = t
	s.Transparency = tr or 0
	s.Color = col or C.White
	s.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	s.Parent = p
	return s
end

local function pad(p, l, r, t, b)
	local pd = Instance.new("UIPadding")
	pd.PaddingLeft   = UDim.new(0, l or 0)
	pd.PaddingRight  = UDim.new(0, r or 0)
	pd.PaddingTop    = UDim.new(0, t or 0)
	pd.PaddingBottom = UDim.new(0, b or 0)
	pd.Parent = p
	return pd
end

UI = UI or safeRequireRS("UIComponents") or {}
UI.corner = UI.corner or corner
UI.pill = UI.pill or pill
UI.stroke = UI.stroke or stroke
UI.pad = UI.pad or pad

local function tween(o, i, p)
	local t = TweenService:Create(o, i, p)
	t:Play()
	return t
end

local function formatMoney(n)
	if not n then return "$0" end
	if n >= 1000000 then
		return string.format("$%.1fM", n/1000000)
	elseif n >= 1000 then
		return string.format("$%.1fK", n/1000)
	else
		return "$"..math.floor(n)
	end
end

local function createShadow(parent, offset, blur, color, transparency)
	local shadow = Instance.new("ImageLabel")
	shadow.Name = "Shadow"
	shadow.Size = UDim2.new(1, blur*2, 1, blur*2)
	shadow.Position = UDim2.new(0, -blur + (offset or 0), 0, -blur + (offset or 4))
	shadow.BackgroundTransparency = 1
	shadow.Image = "rbxassetid://5554236805"
	shadow.ImageColor3 = color or C.Black
	shadow.ImageTransparency = transparency or 0.85
	shadow.ScaleType = Enum.ScaleType.Slice
	shadow.SliceCenter = Rect.new(23, 23, 277, 277)
	shadow.ZIndex = parent.ZIndex - 1
	shadow.Parent = parent
	return shadow
end

----------------------------------------------------------------
-- MOBILE RESPONSIVE SYSTEM
-- Detects device type and provides responsive sizing helpers
-- OPTIMIZED for tiny phones like iPhone 6 (375x667)
----------------------------------------------------------------

local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera

-- Device detection - consolidated into single table to reduce local register usage
-- (Luau has a 200 local register limit per function scope)
-- CRITICAL FIX: Improved mobile detection to prevent false positives on PC
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")

-- More robust mobile detection:
-- 1. Must have touch AND no keyboard (or mouse as primary)
-- 2. Must NOT be in Studio (Studio always counts as PC)
-- 3. Must NOT be console/ten-foot interface
local function detectMobile()
	-- Never consider Studio as mobile
	if RunService:IsStudio() then
		return false
	end
	-- Console is not mobile
	if GuiService:IsTenFootInterface() then
		return false
	end
	-- Mobile = touch enabled AND (no keyboard OR no mouse)
	-- This prevents touch-screen PCs from being detected as mobile
	local hasTouch = UserInputService.TouchEnabled
	local hasKeyboard = UserInputService.KeyboardEnabled
	local hasMouse = UserInputService.MouseEnabled
	-- PC with touch screen has all three - NOT mobile
	-- Mobile has touch but typically no mouse
	return hasTouch and not hasMouse
end

local Device = {
	ViewportSize = Camera.ViewportSize,
	IS_MOBILE = detectMobile(),
	IS_TABLET = false,
	IS_SMALL_PHONE = false,
	IS_TINY_PHONE = false,
}
Device.IS_TABLET = Device.IS_MOBILE and (Camera.ViewportSize.X >= 768 or Camera.ViewportSize.Y >= 768)
Device.IS_SMALL_PHONE = Device.IS_MOBILE and not Device.IS_TABLET and (Camera.ViewportSize.X < 450 or Camera.ViewportSize.Y < 750)
Device.IS_TINY_PHONE = Device.IS_MOBILE and not Device.IS_TABLET and (Camera.ViewportSize.X <= 380 or Camera.ViewportSize.Y <= 680)

-- Viewport tracking
local function updateViewport()
	Device.ViewportSize = Camera.ViewportSize
	Device.IS_MOBILE = detectMobile()
	Device.IS_TABLET = Device.IS_MOBILE and (Device.ViewportSize.X >= 768 or Device.ViewportSize.Y >= 768)
	Device.IS_SMALL_PHONE = Device.IS_MOBILE and not Device.IS_TABLET and (Device.ViewportSize.X < 450 or Device.ViewportSize.Y < 750)
	Device.IS_TINY_PHONE = Device.IS_MOBILE and not Device.IS_TABLET and (Device.ViewportSize.X <= 380 or Device.ViewportSize.Y <= 680)
end
Camera:GetPropertyChangedSignal("ViewportSize"):Connect(updateViewport)

-- Responsive sizing helpers - MORE AGGRESSIVE for tiny phones
local function getScale()
	-- Base scale on smaller dimension for consistent mobile experience
	local minDim = math.min(Device.ViewportSize.X, Device.ViewportSize.Y)
	if minDim <= 320 then return 0.50 end  -- Extremely tiny (iPhone SE 1st gen)
	if minDim <= 375 then return 0.58 end  -- Tiny phone (iPhone 6/7/8, SE)
	if minDim <= 400 then return 0.68 end  -- Small phone
	if minDim <= 450 then return 0.78 end  -- Medium-small phone
	if minDim <= 550 then return 0.88 end  -- Medium phone
	if minDim < 768 then return 0.95 end   -- Large phone / small tablet
	return 1.0  -- Tablet / Desktop
end

-- Scale pixel values for mobile
local function px(baseValue)
	return math.floor(baseValue * getScale())
end

-- Get responsive text size - with better minimums for tiny screens
local function textSize(baseSize)
	local scale = getScale()
	local scaled = math.floor(baseSize * scale)
	-- Minimum readable text sizes - smaller OK on tiny phones
	local minSize = Device.IS_TINY_PHONE and 9 or 10
	if scaled < minSize then scaled = minSize end
	return scaled
end

-- Get responsive padding - more compact on tiny phones
local function padSize(base)
	if Device.IS_TINY_PHONE then
		return math.max(2, math.floor(base * 0.5))
	end
	return math.max(4, math.floor(base * getScale()))
end

-- Minimum tap target size (44px per Apple/Google guidelines, but 40 OK on tiny)
local MIN_TAP_TARGET = Device.IS_TINY_PHONE and 40 or 44

-- Get touch-friendly button height
local function btnHeight(baseHeight)
	local scaled = math.floor(baseHeight * getScale())
	local minTarget = Device.IS_TINY_PHONE and 38 or MIN_TAP_TARGET
	if Device.IS_MOBILE and scaled < minTarget then
		return minTarget
	end
	return scaled
end

-- Get responsive modal width (percentage of screen with max)
local function modalWidth(maxWidth)
	if Device.IS_TINY_PHONE then
		return Device.ViewportSize.X - 12  -- 6px margin each side on tiny phones
	elseif Device.IS_SMALL_PHONE then
		return Device.ViewportSize.X - 16  -- 8px margin each side
	end
	return math.min(Device.ViewportSize.X * 0.92, maxWidth or 400)
end

-- Get responsive card width
local function cardWidth(maxWidth)
	if Device.IS_TINY_PHONE then
		return Device.ViewportSize.X - 12  -- 6px margin each side
	elseif Device.IS_SMALL_PHONE then
		return Device.ViewportSize.X - 16  -- 8px margin each side
	elseif Device.IS_MOBILE then
		return math.min(Device.ViewportSize.X - 24, maxWidth or 350)
	end
	return maxWidth or 350
end

----------------------------------------------------------------
-- SCREEN GUI
----------------------------------------------------------------

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "BitLifeUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = player:WaitForChild("PlayerGui")

local blurOverlay = Instance.new("Frame")
blurOverlay.Name = "BlurOverlay"
blurOverlay.Size = UDim2.fromScale(1, 1)
blurOverlay.BackgroundColor3 = C.Black
blurOverlay.BackgroundTransparency = 1
blurOverlay.ZIndex = 50
blurOverlay.Parent = screenGui

local function showBlur()
	tween(blurOverlay, TweenInfo.new(0.25), { BackgroundTransparency = 0.6 })
end

local function hideBlur()
	tween(blurOverlay, TweenInfo.new(0.25), { BackgroundTransparency = 1 })
end

----------------------------------------------------------------
-- MAIN CONTAINER
----------------------------------------------------------------

local mainContainer = Instance.new("Frame")
mainContainer.Name = "MainContainer"
mainContainer.Size = UDim2.fromScale(1, 1)
mainContainer.BackgroundColor3 = C.Gray100
mainContainer.BorderSizePixel = 0
mainContainer.ZIndex = 1
mainContainer.Parent = screenGui

----------------------------------------------------------------
-- SCREEN SHAKE EFFECT (for negative outcomes like BitLife)
----------------------------------------------------------------

local shakeActive = false

local function shakeScreen(intensity, duration)
	if shakeActive then return end
	shakeActive = true

	local originalPos = mainContainer.Position
	local elapsed = 0
	local shakeIntensity = intensity or 8

	task.spawn(function()
		while elapsed < (duration or 0.4) do
			local offsetX = math.random(-shakeIntensity, shakeIntensity)
			local offsetY = math.random(-shakeIntensity, shakeIntensity)
			mainContainer.Position = UDim2.new(
				originalPos.X.Scale, originalPos.X.Offset + offsetX,
				originalPos.Y.Scale, originalPos.Y.Offset + offsetY
			)
			task.wait(0.02)
			elapsed = elapsed + 0.02
			shakeIntensity = math.max(1, shakeIntensity - 0.5)
		end
		mainContainer.Position = originalPos
		shakeActive = false
	end)
end

----------------------------------------------------------------
-- FLASH OVERLAY (red for damage, green for good)
----------------------------------------------------------------

local flashOverlay = Instance.new("Frame")
flashOverlay.Size = UDim2.fromScale(1, 1)
flashOverlay.BackgroundColor3 = C.Red
flashOverlay.BackgroundTransparency = 1
flashOverlay.ZIndex = 100
flashOverlay.Name = "FlashOverlay"
flashOverlay.Parent = screenGui

local function flashScreen(color, intensity, duration)
	flashOverlay.BackgroundColor3 = color or C.Red
	flashOverlay.BackgroundTransparency = intensity or 0.7
	tween(flashOverlay, TweenInfo.new(duration or 0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		BackgroundTransparency = 1
	})
end

----------------------------------------------------------------
-- RESULT POPUP (BitLife-style card matching event modal)
----------------------------------------------------------------

local ResultUI = {
	overlay = nil,
	shadow = nil,
	shell = nil,
	card = nil,
	emoji = nil,
	title = nil,
	body = nil,
	okButton = nil,
	statsPreview = nil,
}
local resultVisible = false
local resultCallback = nil

-- Forward declare hideResultPopup
local hideResultPopup

local function createResultPopup()
	-- Overlay
	ResultUI.overlay = Instance.new("Frame")
	ResultUI.overlay.Name = "ResultOverlay"
	ResultUI.overlay.Size = UDim2.fromScale(1, 1)
	ResultUI.overlay.BackgroundColor3 = C.Black
	ResultUI.overlay.BackgroundTransparency = 0.45
	ResultUI.overlay.Visible = false
	ResultUI.overlay.ZIndex = 80
	ResultUI.overlay.Parent = screenGui

	-- TINY PHONE FIX: More compact popup width
	local popupWidth = modalWidth(320)
	
	-- Shadow frame (matches event modal) - thinner borders on tiny phones
	ResultUI.shadow = Instance.new("Frame")
	ResultUI.shadow.Size = UDim2.new(0, popupWidth, 0, 0)
	ResultUI.shadow.AutomaticSize = Enum.AutomaticSize.Y
	ResultUI.shadow.AnchorPoint = Vector2.new(0.5, 0.5)
	ResultUI.shadow.Position = UDim2.fromScale(0.5, 0.5)
	ResultUI.shadow.BackgroundColor3 = C.Black
	ResultUI.shadow.BackgroundTransparency = 0.92
	ResultUI.shadow.ZIndex = 81
	ResultUI.shadow.Parent = ResultUI.overlay
	corner(ResultUI.shadow, Device.IS_TINY_PHONE and 14 or px(28))

	-- Green/Red shell - thinner on tiny phones
	local shellMargin = Device.IS_TINY_PHONE and 2 or 6
	ResultUI.shell = Instance.new("Frame")
	ResultUI.shell.Name = "ResultShell"
	ResultUI.shell.Size = UDim2.new(1, -shellMargin, 1, -shellMargin)
	ResultUI.shell.Position = UDim2.new(0, shellMargin/2, 0, shellMargin/2)
	ResultUI.shell.BackgroundColor3 = C.Green
	ResultUI.shell.ZIndex = 82
	ResultUI.shell.Parent = ResultUI.shadow
	corner(ResultUI.shell, Device.IS_TINY_PHONE and 12 or px(26))
	stroke(ResultUI.shell, Device.IS_TINY_PHONE and 1 or 2, 0.4, C.GreenDark)
	if not Device.IS_TINY_PHONE then
		createShadow(ResultUI.shell, 4, px(16), C.Black, 0.9)
	end

	-- Inner white card - thinner on tiny phones
	local cardMargin = Device.IS_TINY_PHONE and 4 or 10
	ResultUI.card = Instance.new("Frame")
	ResultUI.card.Name = "ResultCard"
	ResultUI.card.Size = UDim2.new(1, -cardMargin, 1, -cardMargin)
	ResultUI.card.Position = UDim2.new(0, cardMargin/2, 0, cardMargin/2)
	ResultUI.card.BackgroundColor3 = C.White
	ResultUI.card.ZIndex = 83
	ResultUI.card.Parent = ResultUI.shell
	corner(ResultUI.card, Device.IS_TINY_PHONE and 10 or px(22))

	local cardLayout = Instance.new("UIListLayout")
	cardLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	cardLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	cardLayout.SortOrder = Enum.SortOrder.LayoutOrder
	cardLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 6 or padSize(12))
	cardLayout.Parent = ResultUI.card
	local cardPad = Device.IS_TINY_PHONE and 10 or padSize(20)
	pad(ResultUI.card, cardPad, cardPad, cardPad, cardPad)

	-- Emoji - TINY PHONE FIX: Much smaller emoji
	local emojiSize = Device.IS_TINY_PHONE and 36 or px(60)
	ResultUI.emoji = Instance.new("TextLabel")
	ResultUI.emoji.Size = UDim2.new(0, emojiSize, 0, emojiSize)
	ResultUI.emoji.BackgroundTransparency = 1
	ResultUI.emoji.Font = F.Body
	ResultUI.emoji.TextSize = Device.IS_TINY_PHONE and 28 or textSize(48)
	ResultUI.emoji.Text = "âœ¨"
	ResultUI.emoji.LayoutOrder = 1
	ResultUI.emoji.ZIndex = 84
	ResultUI.emoji.Parent = ResultUI.card

	-- Title - TINY PHONE FIX: Smaller text
	ResultUI.title = Instance.new("TextLabel")
	ResultUI.title.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 20 or px(32))
	ResultUI.title.BackgroundTransparency = 1
	ResultUI.title.Font = F.Title
	ResultUI.title.TextSize = Device.IS_TINY_PHONE and 15 or textSize(24)
	ResultUI.title.TextColor3 = C.Gray900
	ResultUI.title.Text = "Result"
	ResultUI.title.TextWrapped = true
	ResultUI.title.LayoutOrder = 2
	ResultUI.title.ZIndex = 84
	ResultUI.title.Parent = ResultUI.card

	-- Body - TINY PHONE FIX: Smaller text with tighter line height
	ResultUI.body = Instance.new("TextLabel")
	ResultUI.body.Size = UDim2.new(1, 0, 0, 0)
	ResultUI.body.AutomaticSize = Enum.AutomaticSize.Y
	ResultUI.body.BackgroundTransparency = 1
	ResultUI.body.Font = F.Body
	ResultUI.body.TextSize = Device.IS_TINY_PHONE and 11 or textSize(16)
	ResultUI.body.TextColor3 = C.Gray600
	ResultUI.body.TextWrapped = true
	ResultUI.body.TextXAlignment = Enum.TextXAlignment.Center
	ResultUI.body.LineHeight = Device.IS_TINY_PHONE and 1.2 or 1.4
	ResultUI.body.RichText = true
	ResultUI.body.Text = ""
	ResultUI.body.LayoutOrder = 3
	ResultUI.body.ZIndex = 84
	ResultUI.body.Parent = ResultUI.card

	-- Stats container - tighter on tiny phones
	ResultUI.statsPreview = Instance.new("Frame")
	ResultUI.statsPreview.Name = "StatsPreview"
	ResultUI.statsPreview.Size = UDim2.new(1, 0, 0, 0)
	ResultUI.statsPreview.AutomaticSize = Enum.AutomaticSize.Y
	ResultUI.statsPreview.BackgroundTransparency = 1
	ResultUI.statsPreview.LayoutOrder = 4
	ResultUI.statsPreview.ZIndex = 84
	ResultUI.statsPreview.Parent = ResultUI.card

	local statsLayout = Instance.new("UIListLayout")
	statsLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 2 or padSize(4))
	statsLayout.Parent = ResultUI.statsPreview

	-- OK Button - TINY PHONE FIX: Smaller but still tappable
	local okBtnHeight = Device.IS_TINY_PHONE and 38 or btnHeight(52)
	ResultUI.okButton = Instance.new("TextButton")
	ResultUI.okButton.Size = UDim2.new(1, 0, 0, okBtnHeight)
	ResultUI.okButton.BackgroundColor3 = C.Green
	ResultUI.okButton.Font = F.Button
	ResultUI.okButton.TextSize = Device.IS_TINY_PHONE and 13 or textSize(18)
	ResultUI.okButton.TextColor3 = C.White
	ResultUI.okButton.Text = "Continue"
	ResultUI.okButton.AutoButtonColor = false
	ResultUI.okButton.LayoutOrder = 99
	ResultUI.okButton.ZIndex = 84
	ResultUI.okButton.Parent = ResultUI.card
	corner(ResultUI.okButton, Device.IS_TINY_PHONE and 8 or px(12))

	ResultUI.okButton.MouseEnter:Connect(function()
		tween(ResultUI.okButton, TweenInfo.new(0.1), { BackgroundColor3 = C.GreenDark })
	end)
	ResultUI.okButton.MouseLeave:Connect(function()
		tween(ResultUI.okButton, TweenInfo.new(0.1), { BackgroundColor3 = C.Green })
	end)

	ResultUI.okButton.MouseButton1Click:Connect(function()
		hideResultPopup()
		if resultCallback then
			resultCallback()
			resultCallback = nil
		end
	end)
end

hideResultPopup = function()
	if not ResultUI.overlay then return end
	resultVisible = false

	tween(ResultUI.shadow, TweenInfo.new(0.2), {
		Position = UDim2.new(0.5, 0, 0.5, 40),
		BackgroundTransparency = 1,
	})
	tween(ResultUI.shell, TweenInfo.new(0.2), { BackgroundTransparency = 1 })
	tween(ResultUI.card, TweenInfo.new(0.2), { BackgroundTransparency = 1 })

	task.delay(0.2, function()
		if ResultUI.overlay then
			ResultUI.overlay.Visible = false
		end
	end)
end

local function showResultPopup(data, callback)
	if not ResultUI.overlay then createResultPopup() end

	resultCallback = callback

	-- PRIORITY: wasSuccess flag from minigames/events takes precedence
	-- Otherwise fall back to stat-based check
	local isPositive
	if data.wasSuccess ~= nil then
		-- Explicit success/fail flag from server (e.g., minigame results)
		isPositive = data.wasSuccess
	else
		-- Fall back to stat-based check
		isPositive = (data.happiness or 0) >= 0 and (data.health or 0) >= 0
	end

	local shellColor = isPositive and C.Green or C.Red
	local shellStrokeColor = isPositive and C.GreenDark or C.RedDark

	ResultUI.shell.BackgroundColor3 = shellColor
	local shellStroke = ResultUI.shell:FindFirstChildOfClass("UIStroke")
	if shellStroke then shellStroke.Color = shellStrokeColor end
	ResultUI.okButton.BackgroundColor3 = shellColor

	ResultUI.emoji.Text = data.emoji or (isPositive and "âœ¨" or "ðŸ˜¢")
	ResultUI.title.Text = data.title or "What Happened"
	-- CRITICAL UI FIX: More descriptive default body text
	local bodyText = data.body or "Something happened, but the details are unclear."
	if bodyText == "" then
		bodyText = isPositive and "Things worked out in your favor!" or "That didn't go as planned..."
	end
	ResultUI.body.Text = bodyText

	-- Clear old stat previews
	for _, child in ipairs(ResultUI.statsPreview:GetChildren()) do
		if child:IsA("Frame") then child:Destroy() end
	end

	-- Add stat changes (compact style)
	local statChanges = {
		{ key = "Happiness", icon = "ðŸ˜€", delta = data.happiness },
		{ key = "Health", icon = "â¤ï¸", delta = data.health },
		{ key = "Smarts", icon = "ðŸ§ ", delta = data.smarts },
		{ key = "Looks", icon = "ðŸ’„", delta = data.looks },
	}

	for _, stat in ipairs(statChanges) do
		if stat.delta and stat.delta ~= 0 then
			local row = Instance.new("Frame")
			row.Size = UDim2.new(1, 0, 0, 24)
			row.BackgroundTransparency = 1
			row.ZIndex = 85
			row.Parent = ResultUI.statsPreview

			local lbl = Instance.new("TextLabel")
			lbl.Size = UDim2.new(0.5, 0, 1, 0)
			lbl.BackgroundTransparency = 1
			lbl.Font = F.Medium
			lbl.TextSize = 14
			lbl.TextColor3 = C.Gray600
			lbl.TextXAlignment = Enum.TextXAlignment.Left
			lbl.Text = stat.icon .. " " .. stat.key
			lbl.ZIndex = 86
			lbl.Parent = row

			local val = Instance.new("TextLabel")
			val.Size = UDim2.new(0.5, 0, 1, 0)
			val.Position = UDim2.new(0.5, 0, 0, 0)
			val.BackgroundTransparency = 1
			val.Font = F.Title
			val.TextSize = 14
			val.TextColor3 = stat.delta > 0 and C.Green or C.Red
			val.TextXAlignment = Enum.TextXAlignment.Right
			val.Text = (stat.delta > 0 and "+" or "") .. stat.delta
			val.ZIndex = 86
			val.Parent = row
		end
	end

	-- Money change
	if data.money and data.money ~= 0 then
		local row = Instance.new("Frame")
		row.Size = UDim2.new(1, 0, 0, 24)
		row.BackgroundTransparency = 1
		row.ZIndex = 85
		row.Parent = ResultUI.statsPreview

		local lbl = Instance.new("TextLabel")
		lbl.Size = UDim2.new(0.5, 0, 1, 0)
		lbl.BackgroundTransparency = 1
		lbl.Font = F.Medium
		lbl.TextSize = 14
		lbl.TextColor3 = C.Gray600
		lbl.TextXAlignment = Enum.TextXAlignment.Left
		lbl.Text = "ðŸ’µ Money"
		lbl.ZIndex = 86
		lbl.Parent = row

		local val = Instance.new("TextLabel")
		val.Size = UDim2.new(0.5, 0, 1, 0)
		val.Position = UDim2.new(0.5, 0, 0, 0)
		val.BackgroundTransparency = 1
		val.Font = F.Title
		val.TextSize = 14
		val.TextColor3 = data.money > 0 and C.Green or C.Red
		val.TextXAlignment = Enum.TextXAlignment.Right
		val.Text = (data.money > 0 and "+" or "") .. formatMoney(data.money)
		val.ZIndex = 86
		val.Parent = row
	end

	-- Show with animation
	ResultUI.overlay.Visible = true
	ResultUI.shadow.Position = UDim2.new(0.5, 0, 0.5, 40)
	ResultUI.shadow.BackgroundTransparency = 1
	ResultUI.shell.BackgroundTransparency = 1
	ResultUI.card.BackgroundTransparency = 1

	tween(ResultUI.shadow, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Position = UDim2.fromScale(0.5, 0.5),
		BackgroundTransparency = 0.92,
	})
	tween(ResultUI.shell, TweenInfo.new(0.25), { BackgroundTransparency = 0 })
	tween(ResultUI.card, TweenInfo.new(0.25), { BackgroundTransparency = 0 })

	-- CRITICAL FIX: Visual feedback - BitLife style shake for negative outcomes
	-- More aggressive triggering for immersive gameplay feel
	local shouldShake = false
	local shouldFlash = false
	local shakeIntensity = 6
	
	-- Check for any negative outcomes
	if data.health and data.health < 0 then
		-- ANY health loss triggers shake
		shouldShake = true
		if data.health < -10 then
			-- Major health loss - bigger shake and flash
			shakeIntensity = 12
			shouldFlash = true
		elseif data.health < -5 then
			shakeIntensity = 8
			shouldFlash = true
		end
	end
	
	if data.happiness and data.happiness < -10 then
		-- Significant happiness loss - shake
		shouldShake = true
		shakeIntensity = math.max(shakeIntensity, 6)
	end
	
	if data.money and data.money < -1000 then
		-- Money loss > $1000 - subtle shake
		shouldShake = true
		if data.money < -10000 then
			shakeIntensity = math.max(shakeIntensity, 10)
		end
	end
	
	if data.wasSuccess == false then
		-- Explicit failure (minigame failed, driving test failed, etc)
		shouldShake = true
		shouldFlash = true
		shakeIntensity = math.max(shakeIntensity, 8)
	end
	
	-- Apply effects
	if shouldShake then
		shakeScreen(shakeIntensity, 0.25)
	end
	if shouldFlash then
		flashScreen(C.Red, 0.6, 0.3)
	end

	resultVisible = true
end

----------------------------------------------------------------
-- HEADER BAR (Offset to avoid Roblox logo)
----------------------------------------------------------------

-- TINY PHONE FIX: More compact header
-- CRITICAL FIX #253: Consolidate header UI into table to reduce file-level locals
local HeaderUI = {}
HeaderUI.height = Device.IS_TINY_PHONE and 48 or (Device.IS_SMALL_PHONE and 56 or px(70))
HeaderUI.topOffset = Device.IS_TINY_PHONE and 32 or px(44)  -- Less top offset on tiny phones

;(function() -- CRITICAL FIX #253: IIFE for header construction (do-blocks don't reduce register count)
local headerBar = Instance.new("Frame")
headerBar.Name = "Header"
headerBar.Size = UDim2.new(1, -padSize(12), 0, HeaderUI.height)
headerBar.Position = UDim2.new(0, padSize(6), 0, HeaderUI.topOffset)
headerBar.BackgroundColor3 = C.White
headerBar.ZIndex = 5
headerBar.Parent = mainContainer
corner(headerBar, Device.IS_TINY_PHONE and 12 or px(18))
HeaderUI.bar = headerBar

-- subtle shadow - skip on tiny phones for cleaner look
local headerShadow = Instance.new("Frame")
headerShadow.Size = UDim2.new(1, 4, 0, HeaderUI.height + 4)
headerShadow.Position = UDim2.new(0, padSize(4), 0, HeaderUI.topOffset + 2)
headerShadow.BackgroundColor3 = C.Black
headerShadow.BackgroundTransparency = Device.IS_TINY_PHONE and 0.98 or 0.95
headerShadow.ZIndex = 4
headerShadow.Parent = mainContainer
corner(headerShadow, Device.IS_TINY_PHONE and 14 or px(20))

-- TINY PHONE FIX: Smaller avatar
local avatarSize = Device.IS_TINY_PHONE and 32 or (Device.IS_SMALL_PHONE and 38 or px(50))
local avatarCircle = Instance.new("Frame")
avatarCircle.Size = UDim2.new(0, avatarSize, 0, avatarSize)
avatarCircle.Position = UDim2.new(0, Device.IS_TINY_PHONE and 8 or padSize(14), 0.5, -avatarSize/2)
avatarCircle.BackgroundColor3 = C.BluePale
avatarCircle.ZIndex = 6
avatarCircle.Parent = HeaderUI.bar
corner(avatarCircle, avatarSize/2)
stroke(avatarCircle, Device.IS_TINY_PHONE and 1 or 2, 0.5, C.BlueLight)

HeaderUI.avatarEmoji = Instance.new("TextLabel")
HeaderUI.avatarEmoji.Size = UDim2.fromScale(1, 1)
HeaderUI.avatarEmoji.BackgroundTransparency = 1
HeaderUI.avatarEmoji.Font = F.Body
HeaderUI.avatarEmoji.TextSize = Device.IS_TINY_PHONE and 18 or textSize(26)
HeaderUI.avatarEmoji.Text = "ðŸ‘¶"
HeaderUI.avatarEmoji.ZIndex = 7
HeaderUI.avatarEmoji.Parent = avatarCircle

-- TINY PHONE FIX: Tighter name container
local nameOffset = avatarSize + (Device.IS_TINY_PHONE and 12 or padSize(24))
local nameContainer = Instance.new("Frame")
nameContainer.Size = UDim2.new(0.5, -nameOffset, 1, 0)
nameContainer.Position = UDim2.new(0, nameOffset, 0, 0)
nameContainer.BackgroundTransparency = 1
nameContainer.ZIndex = 6
nameContainer.Parent = HeaderUI.bar

HeaderUI.nameLabel = Instance.new("TextLabel")
HeaderUI.nameLabel.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 16 or px(24))
HeaderUI.nameLabel.Position = UDim2.new(0, 0, 0.5, Device.IS_TINY_PHONE and -10 or px(-14))
HeaderUI.nameLabel.BackgroundTransparency = 1
HeaderUI.nameLabel.Font = F.Title
HeaderUI.nameLabel.TextSize = Device.IS_TINY_PHONE and 13 or textSize(17)
HeaderUI.nameLabel.TextColor3 = C.Gray900
HeaderUI.nameLabel.TextXAlignment = Enum.TextXAlignment.Left
HeaderUI.nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
HeaderUI.nameLabel.Text = "New Life"
HeaderUI.nameLabel.ZIndex = 7
HeaderUI.nameLabel.Parent = nameContainer

HeaderUI.ageYearLabel = Instance.new("TextLabel")
HeaderUI.ageYearLabel.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 12 or px(16))
HeaderUI.ageYearLabel.Position = UDim2.new(0, 0, 0.5, Device.IS_TINY_PHONE and 4 or padSize(8))
HeaderUI.ageYearLabel.BackgroundTransparency = 1
HeaderUI.ageYearLabel.Font = F.Body
HeaderUI.ageYearLabel.TextSize = Device.IS_TINY_PHONE and 10 or textSize(12)
HeaderUI.ageYearLabel.TextColor3 = C.Gray500
HeaderUI.ageYearLabel.TextXAlignment = Enum.TextXAlignment.Left
HeaderUI.ageYearLabel.Text = "Age 0 â€¢ 2025"
HeaderUI.ageYearLabel.ZIndex = 7
HeaderUI.ageYearLabel.Parent = nameContainer

-- TINY PHONE FIX: Smaller money display
local moneyWidth = Device.IS_TINY_PHONE and 70 or (Device.IS_SMALL_PHONE and 85 or px(110))
local moneyHeight = Device.IS_TINY_PHONE and 32 or btnHeight(44)
local moneyContainer = Instance.new("Frame")
moneyContainer.Size = UDim2.new(0, moneyWidth, 0, moneyHeight)
moneyContainer.AnchorPoint = Vector2.new(1, 0.5)
moneyContainer.Position = UDim2.new(1, Device.IS_TINY_PHONE and -6 or -padSize(12), 0.5, 0)
moneyContainer.BackgroundColor3 = C.GreenPale
moneyContainer.ZIndex = 6
moneyContainer.Parent = HeaderUI.bar
corner(moneyContainer, Device.IS_TINY_PHONE and 8 or px(14))
stroke(moneyContainer, Device.IS_TINY_PHONE and 1 or 2, 0.6, C.Green)

local moneyIcon = Instance.new("TextLabel")
moneyIcon.Size = UDim2.new(0, Device.IS_TINY_PHONE and 20 or px(30), 1, 0)
moneyIcon.BackgroundTransparency = 1
moneyIcon.Font = F.Body
moneyIcon.TextSize = Device.IS_TINY_PHONE and 14 or textSize(20)
moneyIcon.Text = "ðŸ’µ"
moneyIcon.ZIndex = 7
moneyIcon.Parent = moneyContainer

HeaderUI.moneyLabel = Instance.new("TextLabel")
HeaderUI.moneyLabel.Size = UDim2.new(1, Device.IS_TINY_PHONE and -22 or -px(34), 1, 0)
HeaderUI.moneyLabel.Position = UDim2.new(0, Device.IS_TINY_PHONE and 20 or px(30), 0, 0)
HeaderUI.moneyLabel.BackgroundTransparency = 1
HeaderUI.moneyLabel.Font = F.Title
HeaderUI.moneyLabel.TextSize = textSize(15)
HeaderUI.moneyLabel.TextColor3 = C.GreenDark
HeaderUI.moneyLabel.TextXAlignment = Enum.TextXAlignment.Left
HeaderUI.moneyLabel.Text = "$0"
HeaderUI.moneyLabel.ZIndex = 7
HeaderUI.moneyLabel.Parent = moneyContainer
end)() -- CRITICAL FIX #253: End header construction IIFE

-- CRITICAL FIX #253: Aliases removed - use HeaderUI.avatarEmoji, HeaderUI.nameLabel, etc.
-- These are set below after the do-block for backward compatibility
local avatarEmoji, nameLabel, ageYearLabel, moneyLabel, headerBar
avatarEmoji = HeaderUI.avatarEmoji
nameLabel = HeaderUI.nameLabel
ageYearLabel = HeaderUI.ageYearLabel
moneyLabel = HeaderUI.moneyLabel
headerBar = HeaderUI.bar

----------------------------------------------------------------
-- LIFE FEED AREA - TINY PHONE FIX: More compact layout
----------------------------------------------------------------

-- Calculate feed container position based on header
local feedTop = HeaderUI.topOffset + HeaderUI.height + (Device.IS_TINY_PHONE and 4 or padSize(8))
-- Nav height varies by device - smaller on tiny phones
local navHeight = Device.IS_TINY_PHONE and 50 or (Device.IS_SMALL_PHONE and 55 or px(65))
local feedBottomOffset = navHeight + (Device.IS_TINY_PHONE and 140 or px(200)) -- Nav + stats + premium row + age button

local feedContainer = Instance.new("Frame")
feedContainer.Name = "FeedContainer"
feedContainer.Size = UDim2.new(1, -padSize(12), 1, -feedTop - feedBottomOffset)
feedContainer.Position = UDim2.new(0, padSize(6), 0, feedTop)
feedContainer.BackgroundColor3 = C.White
feedContainer.ZIndex = 3
feedContainer.Parent = mainContainer
corner(feedContainer, Device.IS_TINY_PHONE and 10 or px(16))
local feedPad = Device.IS_TINY_PHONE and 8 or padSize(14)
pad(feedContainer, feedPad, feedPad, Device.IS_TINY_PHONE and 6 or padSize(12), Device.IS_TINY_PHONE and 6 or padSize(12))

local feedScroll = Instance.new("ScrollingFrame")
feedScroll.Size = UDim2.fromScale(1, 1)
feedScroll.BackgroundTransparency = 1
feedScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
feedScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
feedScroll.ScrollBarThickness = Device.IS_MOBILE and 6 or 3  -- MOBILE FIX: Thicker scrollbar for touch
feedScroll.ScrollBarImageColor3 = C.Gray300
feedScroll.ScrollingDirection = Enum.ScrollingDirection.Y
feedScroll.Parent = feedContainer

local feedLayout = Instance.new("UIListLayout")
feedLayout.Padding = UDim.new(0, padSize(8))
feedLayout.SortOrder = Enum.SortOrder.LayoutOrder
feedLayout.Parent = feedScroll

local feedEntryCount = 0

local function addFeedEntry(text)
	if not text or text == "" then return end
	feedEntryCount += 1

	local entry = Instance.new("Frame")
	entry.Size = UDim2.new(1, 0, 0, 0)
	entry.AutomaticSize = Enum.AutomaticSize.Y
	entry.BackgroundColor3 = C.Gray50
	entry.LayoutOrder = feedEntryCount
	entry.Parent = feedScroll
	corner(entry, 10)
	pad(entry, 12, 12, 10, 10)

	local isAge = text:match("years old")

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 0, 0)
	label.AutomaticSize = Enum.AutomaticSize.Y
	label.BackgroundTransparency = 1
	label.Font = isAge and F.Title or F.Body
	label.TextSize = isAge and 14 or 13
	label.TextColor3 = isAge and C.Blue or C.Gray700
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.TextWrapped = true
	label.Text = text
	label.Parent = entry

	entry.BackgroundTransparency = 1
	label.TextTransparency = 1
	tween(entry, TweenInfo.new(0.2), { BackgroundTransparency = 0 })
	tween(label, TweenInfo.new(0.2), { TextTransparency = 0 })

	task.defer(function()
		feedScroll.CanvasPosition = Vector2.new(
			0,
			math.max(0, feedScroll.AbsoluteCanvasSize.Y - feedScroll.AbsoluteWindowSize.Y)
		)
	end)
end

----------------------------------------------------------------
-- BOTTOM SECTION: Stats + Nav + Age Button - TINY PHONE FIX
----------------------------------------------------------------

-- TINY PHONE FIX: Smaller stats row
local statsRowHeight = Device.IS_TINY_PHONE and 38 or 52
local statsRowBottom = Device.IS_TINY_PHONE and 68 or 88
local statsGap = Device.IS_TINY_PHONE and 35 or 55

local statsRow = Instance.new("Frame")
statsRow.Name = "StatsRow"
statsRow.Size = UDim2.new(1, -12, 0, statsRowHeight)
statsRow.AnchorPoint = Vector2.new(0.5, 1)
statsRow.Position = UDim2.new(0.5, 0, 1, -statsRowBottom)
statsRow.BackgroundColor3 = C.White
statsRow.ZIndex = 8
statsRow.Parent = mainContainer
corner(statsRow, Device.IS_TINY_PHONE and 10 or 14)
stroke(statsRow, 1, 0.85, C.Gray200)

-- left stats
local statsLeft = Instance.new("Frame")
statsLeft.Name = "StatsLeft"
statsLeft.Size = UDim2.new(0.5, -statsGap, 1, 0)
statsLeft.Position = UDim2.new(0, 0, 0, 0)
statsLeft.BackgroundTransparency = 1
statsLeft.ZIndex = 9
statsLeft.Parent = statsRow
pad(statsLeft, Device.IS_TINY_PHONE and 4 or 8, Device.IS_TINY_PHONE and 4 or 8, Device.IS_TINY_PHONE and 4 or 6, Device.IS_TINY_PHONE and 4 or 6)

local statsLeftLayout = Instance.new("UIListLayout")
statsLeftLayout.FillDirection = Enum.FillDirection.Horizontal
statsLeftLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
statsLeftLayout.VerticalAlignment = Enum.VerticalAlignment.Center
statsLeftLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 3 or 6)
statsLeftLayout.Parent = statsLeft

-- right stats
local statsRight = Instance.new("Frame")
statsRight.Name = "StatsRight"
statsRight.Size = UDim2.new(0.5, -statsGap, 1, 0)
statsRight.Position = UDim2.new(0.5, statsGap, 0, 0)
statsRight.BackgroundTransparency = 1
statsRight.ZIndex = 9
statsRight.Parent = statsRow
pad(statsRight, Device.IS_TINY_PHONE and 4 or 8, Device.IS_TINY_PHONE and 4 or 8, Device.IS_TINY_PHONE and 4 or 6, Device.IS_TINY_PHONE and 4 or 6)

local statsRightLayout = Instance.new("UIListLayout")
statsRightLayout.FillDirection = Enum.FillDirection.Horizontal
statsRightLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
statsRightLayout.VerticalAlignment = Enum.VerticalAlignment.Center
statsRightLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 3 or 6)
statsRightLayout.Parent = statsRight

local statCards = {}

-- TINY PHONE FIX: Smaller stat cards
local statCardWidth = Device.IS_TINY_PHONE and 56 or 76
local statCardHeight = Device.IS_TINY_PHONE and 30 or 40

local function createStatCard(info, parent, order)
	local statCard = Instance.new("Frame")
	statCard.Name = "Stat_" .. info.key
	statCard.Size = UDim2.new(0, statCardWidth, 0, statCardHeight)
	statCard.BackgroundColor3 = C.Gray50
	statCard.LayoutOrder = order
	statCard.ZIndex = 10
	statCard.Parent = parent
	corner(statCard, Device.IS_TINY_PHONE and 6 or 10)

	local iconLbl = Instance.new("TextLabel")
	iconLbl.Size = UDim2.new(0, Device.IS_TINY_PHONE and 16 or 22, 0, Device.IS_TINY_PHONE and 16 or 22)
	iconLbl.Position = UDim2.new(0, Device.IS_TINY_PHONE and 2 or 4, 0, Device.IS_TINY_PHONE and 2 or 3)
	iconLbl.BackgroundTransparency = 1
	iconLbl.Font = F.Body
	iconLbl.TextSize = Device.IS_TINY_PHONE and 11 or 15
	iconLbl.Text = info.icon
	iconLbl.ZIndex = 11
	iconLbl.Parent = statCard

	local percentLbl = Instance.new("TextLabel")
	percentLbl.Name = "Percent"
	percentLbl.Size = UDim2.new(0, Device.IS_TINY_PHONE and 28 or 38, 0, Device.IS_TINY_PHONE and 12 or 16)
	percentLbl.Position = UDim2.new(0, Device.IS_TINY_PHONE and 18 or 26, 0, Device.IS_TINY_PHONE and 2 or 4)
	percentLbl.BackgroundTransparency = 1
	percentLbl.Font = F.Title
	percentLbl.TextSize = Device.IS_TINY_PHONE and 9 or 12
	percentLbl.TextColor3 = info.col
	percentLbl.TextXAlignment = Enum.TextXAlignment.Left
	percentLbl.Text = "100%"
	percentLbl.ZIndex = 11
	percentLbl.Parent = statCard

	local barBg = Instance.new("Frame")
	barBg.Size = UDim2.new(1, Device.IS_TINY_PHONE and -6 or -10, 0, Device.IS_TINY_PHONE and 4 or 6)
	barBg.Position = UDim2.new(0, Device.IS_TINY_PHONE and 3 or 5, 1, Device.IS_TINY_PHONE and -7 or -11)
	barBg.BackgroundColor3 = C.Gray200
	barBg.ZIndex = 11
	barBg.Parent = statCard
	corner(barBg, Device.IS_TINY_PHONE and 2 or 3)

	local barFill = Instance.new("Frame")
	barFill.Name = "Fill"
	barFill.Size = UDim2.new(1, 0, 1, 0)
	barFill.BackgroundColor3 = info.col
	barFill.ZIndex = 12
	barFill.Parent = barBg
	corner(barFill, Device.IS_TINY_PHONE and 2 or 3)

	statCards[info.key] = {
		percentLabel = percentLbl,
		barFill      = barFill,
		color        = info.col,
	}
	return statCard
end

createStatCard({ key = "Happiness", icon = "ðŸ˜€", col = C.Green  }, statsLeft, 1)
createStatCard({ key = "Health",    icon = "â¤ï¸", col = C.Red    }, statsLeft, 2)
createStatCard({ key = "Smarts",    icon = "ðŸ§ ", col = C.Purple }, statsRight, 1)
createStatCard({ key = "Looks",     icon = "ðŸ’„", col = C.Pink   }, statsRight, 2)

----------------------------------------------------------------
-- GOD MODE IN-GAME EDITOR
-- CRITICAL FIX #162: Re-enabled God Mode for in-game stat editing
-- Allows players to edit stats, cure diseases, remove addictions, etc.
-- CRITICAL FIX: Wrapped in IIFE to reduce local register usage
----------------------------------------------------------------

;(function()
-- God Mode overlay for in-game editing
godModeOverlay = Instance.new("Frame")
godModeOverlay.Name = "GodModeOverlay"
godModeOverlay.Size = UDim2.fromScale(1, 1)
godModeOverlay.BackgroundColor3 = Color3.new(0, 0, 0)
godModeOverlay.BackgroundTransparency = 0.35
godModeOverlay.Visible = false
godModeOverlay.ZIndex = 150
godModeOverlay.Parent = mainContainer

-- CRITICAL FIX #163 & #275: Create God Mode Button in header area
-- CRITICAL FIX #275: Better mobile positioning - centered in header right side
-- CRITICAL FIX #317: Moved button LEFT to avoid overlapping cash display
local godModeBtnSize = Device.IS_TINY_PHONE and 28 or (Device.IS_SMALL_PHONE and 30 or 34)
godModeButton = Instance.new("TextButton")
godModeButton.Name = "GodModeBtn"
godModeButton.Size = UDim2.new(0, godModeBtnSize, 0, godModeBtnSize)
-- Position: More to the left to avoid cash overlap - increased offset significantly
local godModeBtnOffset = Device.IS_TINY_PHONE and 95 or (Device.IS_SMALL_PHONE and 110 or 140)
godModeButton.Position = UDim2.new(1, -(godModeBtnSize + godModeBtnOffset), 0.5, 0)
godModeButton.AnchorPoint = Vector2.new(0, 0.5) -- Center vertically
godModeButton.BackgroundColor3 = Color3.fromRGB(253, 230, 138)
godModeButton.Text = "âš¡"
godModeButton.TextSize = Device.IS_TINY_PHONE and 16 or 18
godModeButton.ZIndex = 8
godModeButton.Visible = false -- Hidden by default, shown if hasGodMode
godModeButton.Parent = headerBar
corner(godModeButton, godModeBtnSize/2)
stroke(godModeButton, 2, 0, Color3.fromRGB(217, 119, 6))

-- God Mode button hover effect
godModeButton.MouseEnter:Connect(function()
	godModeButton.BackgroundColor3 = Color3.fromRGB(252, 211, 77)
end)
godModeButton.MouseLeave:Connect(function()
	godModeButton.BackgroundColor3 = Color3.fromRGB(253, 230, 138)
end)

-- Update God Mode button visibility
updateGodModeButtonAppearance = function()
	refreshGodModeStatus()
	if godModeButton then
		godModeButton.Visible = hasGodMode
	end
end

-- Create the God Mode Modal
-- CRITICAL FIX #316: Wider modal to fit buttons properly
local godModeModal = Instance.new("Frame")
godModeModal.Name = "GodModeModal"
godModeModal.Size = UDim2.new(0, Device.IS_TINY_PHONE and 320 or 420, 0, 0)
godModeModal.AutomaticSize = Enum.AutomaticSize.Y
godModeModal.AnchorPoint = Vector2.new(0.5, 0.5)
godModeModal.Position = UDim2.new(0.5, 0, 0.5, 0)
godModeModal.BackgroundColor3 = C.White
godModeModal.ZIndex = 151
godModeModal.Parent = godModeOverlay
corner(godModeModal, 16)
stroke(godModeModal, 1, 0.85, C.Gray200)

-- CRITICAL FIX #316: More padding for better layout
local modalPad = Instance.new("UIPadding")
modalPad.PaddingTop = UDim.new(0, 16)
modalPad.PaddingBottom = UDim.new(0, 16)
modalPad.PaddingLeft = UDim.new(0, 20)
modalPad.PaddingRight = UDim.new(0, 20)
modalPad.Parent = godModeModal

local modalScroll = Instance.new("ScrollingFrame")
modalScroll.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 350 or 450)
modalScroll.BackgroundTransparency = 1
modalScroll.ScrollBarThickness = 4
modalScroll.CanvasSize = UDim2.new(1, 0, 0, 0)
modalScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
modalScroll.ZIndex = 152
modalScroll.Parent = godModeModal

local modalLayout = Instance.new("UIListLayout")
modalLayout.FillDirection = Enum.FillDirection.Vertical
modalLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
modalLayout.Padding = UDim.new(0, 10)
modalLayout.Parent = modalScroll

-- Title
local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1, 0, 0, 30)
titleLabel.BackgroundTransparency = 1
titleLabel.Font = F.Title
titleLabel.TextSize = textSize(20)
titleLabel.TextColor3 = C.Gray800
titleLabel.Text = "âš¡ God Mode Editor"
titleLabel.ZIndex = 153
titleLabel.LayoutOrder = 0
titleLabel.Parent = modalScroll

-- Subtitle
local subtitleLabel = Instance.new("TextLabel")
subtitleLabel.Size = UDim2.new(1, 0, 0, 20)
subtitleLabel.BackgroundTransparency = 1
subtitleLabel.Font = F.Body
subtitleLabel.TextSize = textSize(12)
subtitleLabel.TextColor3 = C.Gray500
subtitleLabel.Text = "Edit stats, cure diseases, and more!"
subtitleLabel.ZIndex = 153
subtitleLabel.LayoutOrder = 1
subtitleLabel.Parent = modalScroll

-- STAT SLIDERS SECTION
local statSection = Instance.new("Frame")
statSection.Size = UDim2.new(1, 0, 0, 0)
statSection.AutomaticSize = Enum.AutomaticSize.Y
statSection.BackgroundTransparency = 1
statSection.ZIndex = 152
statSection.LayoutOrder = 2
statSection.Parent = modalScroll

local statLayout = Instance.new("UIListLayout")
statLayout.Padding = UDim.new(0, 8)
statLayout.Parent = statSection

local godModeStatInputs = {}
local stats = {
	{ key = "Happiness", emoji = "ðŸ˜Š", color = C.Yellow },
	{ key = "Health", emoji = "â¤ï¸", color = C.Red },
	{ key = "Smarts", emoji = "ðŸ§ ", color = C.Purple },
	{ key = "Looks", emoji = "ðŸ’„", color = C.Pink },
}

for i, stat in ipairs(stats) do
	local row = Instance.new("Frame")
	row.Size = UDim2.new(1, 0, 0, 40)
	row.BackgroundTransparency = 1
	row.LayoutOrder = i
	row.ZIndex = 153
	row.Parent = statSection
	
	local lbl = Instance.new("TextLabel")
	lbl.Size = UDim2.new(0, 80, 1, 0)
	lbl.BackgroundTransparency = 1
	lbl.Font = F.Medium
	lbl.TextSize = 14
	lbl.TextColor3 = C.Gray700
	lbl.TextXAlignment = Enum.TextXAlignment.Left
	lbl.Text = stat.emoji .. " " .. stat.key
	lbl.ZIndex = 154
	lbl.Parent = row
	
	local sliderBg = Instance.new("Frame")
	sliderBg.Size = UDim2.new(1, -130, 0, 20)
	sliderBg.Position = UDim2.new(0, 85, 0.5, -10)
	sliderBg.BackgroundColor3 = C.Gray200
	sliderBg.ZIndex = 154
	sliderBg.Parent = row
	corner(sliderBg, 6)
	
	local sliderFill = Instance.new("Frame")
	sliderFill.Size = UDim2.new(0.5, 0, 1, 0)
	sliderFill.BackgroundColor3 = stat.color
	sliderFill.ZIndex = 155
	sliderFill.Parent = sliderBg
	corner(sliderFill, 6)
	
	local valInput = Instance.new("TextBox")
	valInput.Size = UDim2.new(0, 40, 0, 28)
	valInput.Position = UDim2.new(1, -40, 0.5, -14)
	valInput.BackgroundColor3 = C.Gray100
	valInput.Font = F.Medium
	valInput.TextSize = 14
	valInput.TextColor3 = C.Gray800
	valInput.Text = "50"
	valInput.ZIndex = 154
	valInput.Parent = row
	corner(valInput, 6)
	
	godModeStatInputs[stat.key] = { input = valInput, fill = sliderFill, bg = sliderBg }
	
	-- Slider drag functionality
	local dragging = false
	sliderBg.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
		end
	end)
	sliderBg.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = false
		end
	end)
	sliderBg.InputChanged:Connect(function(input)
		if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
			local relX = math.clamp((input.Position.X - sliderBg.AbsolutePosition.X) / sliderBg.AbsoluteSize.X, 0, 1)
			local newVal = math.floor(relX * 100)
			valInput.Text = tostring(newVal)
			sliderFill.Size = UDim2.new(relX, 0, 1, 0)
		end
	end)
	
	valInput.FocusLost:Connect(function()
		local val = math.clamp(tonumber(valInput.Text) or 50, 0, 100)
		valInput.Text = tostring(val)
		sliderFill.Size = UDim2.new(val/100, 0, 1, 0)
	end)
end

-- QUICK ACTIONS SECTION
local actionsTitle = Instance.new("TextLabel")
actionsTitle.Size = UDim2.new(1, 0, 0, 30)
actionsTitle.BackgroundTransparency = 1
actionsTitle.Font = F.Title
actionsTitle.TextSize = textSize(16)
actionsTitle.TextColor3 = C.Gray700
actionsTitle.Text = "ðŸ› ï¸ Quick Actions"
actionsTitle.ZIndex = 153
actionsTitle.LayoutOrder = 3
actionsTitle.Parent = modalScroll

local actionsGrid = Instance.new("Frame")
actionsGrid.Size = UDim2.new(1, 0, 0, 0)
actionsGrid.AutomaticSize = Enum.AutomaticSize.Y
actionsGrid.BackgroundTransparency = 1
actionsGrid.ZIndex = 152
actionsGrid.LayoutOrder = 4
actionsGrid.Parent = modalScroll

local gridLayout = Instance.new("UIGridLayout")
gridLayout.CellSize = UDim2.new(0.48, 0, 0, 50)
gridLayout.CellPadding = UDim2.new(0.02, 0, 0, 8)
gridLayout.Parent = actionsGrid

-- CRITICAL FIX #164 + #183: Quick action buttons for God Mode - Expanded list
local quickActions = {
	{ id = "cure_diseases", emoji = "ðŸ’Š", name = "Cure Diseases", desc = "Remove all illnesses" },
	{ id = "remove_addictions", emoji = "ðŸš­", name = "No Addictions", desc = "Remove all addictions" },
	{ id = "clear_record", emoji = "ðŸ“‹", name = "Clear Record", desc = "Erase criminal record" },
	{ id = "max_stats", emoji = "â¬†ï¸", name = "Max Stats", desc = "Set all stats to 100" },
	{ id = "clear_debt", emoji = "ðŸ’³", name = "Clear Debt", desc = "Erase all debts" },
	{ id = "full_heal", emoji = "â¤ï¸", name = "Full Heal", desc = "Restore health to 100" },
	{ id = "max_relationships", emoji = "ðŸ’•", name = "Max Relations", desc = "Max all relationships" },
	{ id = "jail_break", emoji = "ðŸ”“", name = "Jail Break", desc = "Get out of jail free" },
	{ id = "fresh_start", emoji = "ðŸ”„", name = "Fresh Start", desc = "Clear all negative flags" },
	{ id = "revive_family", emoji = "âœ¨", name = "Revive Family", desc = "Bring back the dead" },
}

local godModeActionBtns = {}
for i, action in ipairs(quickActions) do
	local btn = Instance.new("TextButton")
	btn.Name = action.id
	btn.Size = UDim2.new(0.48, 0, 0, 50)
	btn.BackgroundColor3 = C.Gray100
	btn.Text = ""
	btn.ZIndex = 153
	btn.Parent = actionsGrid
	corner(btn, 10)
	
	local btnContent = Instance.new("Frame")
	btnContent.Size = UDim2.fromScale(1, 1)
	btnContent.BackgroundTransparency = 1
	btnContent.ZIndex = 154
	btnContent.Parent = btn
	
	local emoji = Instance.new("TextLabel")
	emoji.Size = UDim2.new(0, 30, 1, 0)
	emoji.Position = UDim2.new(0, 5, 0, 0)
	emoji.BackgroundTransparency = 1
	emoji.Font = F.Body
	emoji.TextSize = 20
	emoji.Text = action.emoji
	emoji.ZIndex = 155
	emoji.Parent = btnContent
	
	local name = Instance.new("TextLabel")
	name.Size = UDim2.new(1, -40, 0, 20)
	name.Position = UDim2.new(0, 35, 0, 5)
	name.BackgroundTransparency = 1
	name.Font = F.Medium
	name.TextSize = 12
	name.TextColor3 = C.Gray800
	name.TextXAlignment = Enum.TextXAlignment.Left
	name.Text = action.name
	name.ZIndex = 155
	name.Parent = btnContent
	
	local desc = Instance.new("TextLabel")
	desc.Size = UDim2.new(1, -40, 0, 16)
	desc.Position = UDim2.new(0, 35, 0, 26)
	desc.BackgroundTransparency = 1
	desc.Font = F.Body
	desc.TextSize = 10
	desc.TextColor3 = C.Gray500
	desc.TextXAlignment = Enum.TextXAlignment.Left
	desc.Text = action.desc
	desc.ZIndex = 155
	desc.Parent = btnContent
	
	btn.MouseEnter:Connect(function() btn.BackgroundColor3 = C.Gray200 end)
	btn.MouseLeave:Connect(function() btn.BackgroundColor3 = C.Gray100 end)
	
	godModeActionBtns[action.id] = btn
end

-- Error label
local errorLabel = Instance.new("TextLabel")
errorLabel.Size = UDim2.new(1, 0, 0, 20)
errorLabel.BackgroundTransparency = 1
errorLabel.Font = F.Body
errorLabel.TextSize = 12
errorLabel.TextColor3 = C.Red
errorLabel.Text = ""
errorLabel.ZIndex = 153
errorLabel.LayoutOrder = 5
errorLabel.Parent = modalScroll

-- Button bar
-- CRITICAL FIX #316: Properly centered button bar with fixed width buttons
local buttonBar = Instance.new("Frame")
buttonBar.Size = UDim2.new(1, 0, 0, 50)
buttonBar.BackgroundTransparency = 1
buttonBar.ZIndex = 152
buttonBar.LayoutOrder = 6
buttonBar.Parent = modalScroll

local buttonLayout = Instance.new("UIListLayout")
buttonLayout.FillDirection = Enum.FillDirection.Horizontal
buttonLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
buttonLayout.VerticalAlignment = Enum.VerticalAlignment.Center
buttonLayout.Padding = UDim.new(0, 12)
buttonLayout.Parent = buttonBar

-- CRITICAL FIX #316: Fixed width buttons that fit nicely in the modal
local btnWidth = Device.IS_TINY_PHONE and 130 or 160
local btnHeight = Device.IS_TINY_PHONE and 38 or 42

local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, btnWidth, 0, btnHeight)
closeBtn.BackgroundColor3 = C.Gray300
closeBtn.Text = "Close"
closeBtn.TextColor3 = C.Gray700
closeBtn.TextSize = Device.IS_TINY_PHONE and 14 or 16
closeBtn.Font = F.Medium
closeBtn.ZIndex = 153
closeBtn.Parent = buttonBar
corner(closeBtn, 10)

local applyBtn = Instance.new("TextButton")
applyBtn.Size = UDim2.new(0, btnWidth, 0, btnHeight)
applyBtn.BackgroundColor3 = Color3.fromRGB(253, 230, 138)
applyBtn.Text = "âš¡ Apply"
applyBtn.TextColor3 = C.Gray800
applyBtn.TextSize = Device.IS_TINY_PHONE and 14 or 16
applyBtn.Font = F.Medium
applyBtn.ZIndex = 153
applyBtn.Parent = buttonBar
corner(applyBtn, 10)
stroke(applyBtn, 2, 0, Color3.fromRGB(217, 119, 6))

-- Hide/Show functions
destroyGodModeModal = function()
	godModeOverlay.Visible = false
end

showGodModeModal = function()
	refreshGodModeStatus()
	if not hasGodMode then
		if PromptGamepass then
			PromptGamepass:FireServer("GOD_MODE")
		end
		return
	end
	
	-- Update stat inputs from current state
	if currentState and currentState.Stats then
		for key, data in pairs(godModeStatInputs) do
			local val = currentState.Stats[key] or currentState[key] or 50
			data.input.Text = tostring(math.floor(val))
			data.fill.Size = UDim2.new(val/100, 0, 1, 0)
		end
	end
	
	errorLabel.Text = ""
	godModeOverlay.Visible = true
end

-- Connect buttons
closeBtn.MouseButton1Click:Connect(destroyGodModeModal)
godModeButton.MouseButton1Click:Connect(showGodModeModal)

-- Connect quick action buttons
for actionId, btn in pairs(godModeActionBtns) do
	btn.MouseButton1Click:Connect(function()
		if not GodModeEdit then
			errorLabel.Text = "Server not ready"
			return
		end
		
		local payload = { quickAction = actionId }
		local ok, result = pcall(function()
			return GodModeEdit:InvokeServer(payload)
		end)
		
		if ok and result and result.success then
			addFeedEntry(result.message or ("Applied: " .. actionId))
			destroyGodModeModal()
		else
			errorLabel.Text = (result and result.message) or "Action failed"
		end
	end)
end

-- Apply button
applyBtn.MouseButton1Click:Connect(function()
	errorLabel.Text = ""
	
	if not GodModeEdit then
		errorLabel.Text = "Server not ready for God Mode edits."
		return
	end
	
	-- Build payload
	local payload = {
		stats = {}
	}
	
	for key, data in pairs(godModeStatInputs) do
		local val = math.clamp(tonumber(data.input.Text) or 50, 0, 100)
		payload.stats[key] = val
	end
	
	applyBtn.Text = "Applying..."
	applyBtn.AutoButtonColor = false
	
	local ok, result = pcall(function()
		return GodModeEdit:InvokeServer(payload)
	end)
	
	if ok and result and result.success then
		addFeedEntry(result.message or "God Mode changes applied!")
		destroyGodModeModal()
	else
		errorLabel.Text = (result and result.message) or "Unable to apply changes."
	end
	
	applyBtn.Text = "âš¡ Apply Changes"
	applyBtn.AutoButtonColor = true
end)

-- Background click to close
godModeOverlay.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		local pos = input.Position
		local modalPos = godModeModal.AbsolutePosition
		local modalSize = godModeModal.AbsoluteSize
		if pos.X < modalPos.X or pos.X > modalPos.X + modalSize.X or
		   pos.Y < modalPos.Y or pos.Y > modalPos.Y + modalSize.Y then
			destroyGodModeModal()
		end
	end
end)

-- Update button visibility on state sync
task.spawn(function()
	task.wait(1)
	updateGodModeButtonAppearance()
end)
end)() -- End God Mode In-Game Editor IIFE

-- LEGACY CODE BELOW (disabled)
if false then -- Disabled: Old modal code kept for reference
	godModeOverlay = Instance.new("Frame")
	godModeOverlay.Name = "GodModeOverlay"
	godModeOverlay.Size = UDim2.fromScale(1, 1)
	godModeOverlay.BackgroundColor3 = Color3.new(0, 0, 0)
	godModeOverlay.BackgroundTransparency = 0.35
	godModeOverlay.ZIndex = 150
	godModeOverlay.Parent = mainContainer

	local modal = Instance.new("Frame")
	modal.Name = "GodModeModal"
	modal.Size = UDim2.new(0, Device.IS_TINY_PHONE and 280 or 360, 0, 0)
	modal.AutomaticSize = Enum.AutomaticSize.Y
	modal.AnchorPoint = Vector2.new(0.5, 0.5)
	modal.Position = UDim2.new(0.5, 0, 0.5, 0)
	modal.BackgroundColor3 = C.White
	modal.ZIndex = 151
	modal.Parent = godModeOverlay
	corner(modal, 16)
	stroke(modal, 1, 0.85, C.Gray200)
	pad(modal, 14, 14, 14, 14)

	local modalLayout = Instance.new("UIListLayout")
	modalLayout.FillDirection = Enum.FillDirection.Vertical
	modalLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	modalLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	modalLayout.Padding = UDim.new(0, 8)
	modalLayout.Parent = modal

	local titleLabel = Instance.new("TextLabel")
	titleLabel.Size = UDim2.new(1, 0, 0, textSize(18) + 6)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Font = F.Title
	titleLabel.TextSize = textSize(18)
	titleLabel.TextColor3 = C.Gray800
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Text = "God Mode Editor"
	titleLabel.ZIndex = 152
	titleLabel.Parent = modal

	local subtitleLabel = Instance.new("TextLabel")
	subtitleLabel.Size = UDim2.new(1, 0, 0, textSize(11) + 6)
	subtitleLabel.BackgroundTransparency = 1
	subtitleLabel.Font = F.Body
	subtitleLabel.TextSize = textSize(11)
	subtitleLabel.TextColor3 = C.Gray500
	subtitleLabel.TextXAlignment = Enum.TextXAlignment.Left
	subtitleLabel.TextWrapped = true
	subtitleLabel.Text = "Edit your stats, name, and job instantly. Values are clamped between 0 and 100."
	subtitleLabel.ZIndex = 152
	subtitleLabel.Parent = modal

	local function createInputRow(labelText, defaultText, placeholder, numeric)
		local row = Instance.new("Frame")
		row.Size = UDim2.new(1, 0, 0, 0)
		row.AutomaticSize = Enum.AutomaticSize.Y
		row.BackgroundTransparency = 1
		row.ZIndex = 152

		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(1, 0, 0, textSize(11) + 4)
		label.BackgroundTransparency = 1
		label.Font = F.Medium
		label.TextSize = textSize(11)
		label.TextColor3 = C.Gray600
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.Text = labelText
		label.Parent = row

		local input = Instance.new("TextBox")
		input.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 26 or 32)
		input.BackgroundColor3 = Color3.fromRGB(248, 250, 252)
		input.Font = F.Body
		input.TextSize = textSize(12)
		input.TextColor3 = C.Gray800
		input.ClearTextOnFocus = false
		input.Text = defaultText or ""
		input.PlaceholderText = placeholder or ""
		input.TextXAlignment = Enum.TextXAlignment.Left
		input.Parent = row
		corner(input, 8)
		stroke(input, 1, 0.9, C.Gray200)
		pad(input, 8, 8, 4, 4)

		if numeric then
			input.Text = tostring(defaultText or 0)
		end

		return row, input
	end

	local currentName = currentState.Name or player.Name or ""
	local nameRow, nameInput = createInputRow("Name", currentName, "Enter a new name")
	nameRow.Parent = modal

	local statsGrid = Instance.new("Frame")
	statsGrid.Name = "StatsGrid"
	statsGrid.Size = UDim2.new(1, 0, 0, 0)
	statsGrid.AutomaticSize = Enum.AutomaticSize.Y
	statsGrid.BackgroundTransparency = 1
	statsGrid.ZIndex = 152
	statsGrid.Parent = modal

	local gridLayout = Instance.new("UIGridLayout")
	gridLayout.CellPadding = UDim2.new(0, 8, 0, 8)
	gridLayout.CellSize = UDim2.new(0.5, -4, 0, Device.IS_TINY_PHONE and 60 or 70)
	gridLayout.Parent = statsGrid

	local statInputs = {}
	local statList = {
		{ label = "Happiness", key = "Happiness", value = currentState.Happiness or 50 },
		{ label = "Health", key = "Health", value = currentState.Health or 100 },
		{ label = "Smarts", key = "Smarts", value = currentState.Smarts or 50 },
		{ label = "Looks", key = "Looks", value = currentState.Looks or 50 },
	}

	for _, stat in ipairs(statList) do
		local card = Instance.new("Frame")
		card.BackgroundColor3 = Color3.fromRGB(248, 250, 252)
		card.ZIndex = 153
		card.Parent = statsGrid
		corner(card, 10)
		stroke(card, 1, 0.9, C.Gray200)
		pad(card, 8, 8, 6, 6)

		local title = Instance.new("TextLabel")
		title.Size = UDim2.new(1, 0, 0, textSize(11) + 2)
		title.BackgroundTransparency = 1
		title.Font = F.Medium
		title.TextSize = textSize(11)
		title.TextColor3 = C.Gray600
		title.TextXAlignment = Enum.TextXAlignment.Left
		title.Text = stat.label
		title.Parent = card

		local input = Instance.new("TextBox")
		input.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 24 or 28)
		input.Position = UDim2.new(0, 0, 0, textSize(11) + 6)
		input.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		input.Font = F.Body
		input.TextSize = textSize(12)
		input.TextColor3 = C.Gray800
		input.TextXAlignment = Enum.TextXAlignment.Left
		input.ClearTextOnFocus = false
		input.Text = tostring(stat.value)
		input.Parent = card
		corner(input, 6)
		stroke(input, 1, 0.9, C.Gray200)
		pad(input, 6, 6, 2, 2)

		statInputs[stat.key] = input
	end

	local careerRow, careerInput = createInputRow("Career (ID or name)", "", "e.g. police_officer or clear")
	careerRow.Parent = modal

	local moneyRow, moneyInput = createInputRow("Money", tostring(currentState.Money or 0), "Optional", true)
	moneyRow.Parent = modal

	local errorLabel = Instance.new("TextLabel")
	errorLabel.Size = UDim2.new(1, 0, 0, textSize(11) + 4)
	errorLabel.BackgroundTransparency = 1
	errorLabel.Font = F.Body
	errorLabel.TextSize = textSize(11)
	errorLabel.TextColor3 = C.Red
	errorLabel.TextXAlignment = Enum.TextXAlignment.Left
	errorLabel.Text = ""
	errorLabel.ZIndex = 152
	errorLabel.Parent = modal

	local buttonBar = Instance.new("Frame")
	buttonBar.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 32 or 40)
	buttonBar.BackgroundTransparency = 1
	buttonBar.ZIndex = 152
	buttonBar.Parent = modal

	local buttonLayout = Instance.new("UIListLayout")
	buttonLayout.FillDirection = Enum.FillDirection.Horizontal
	buttonLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
	buttonLayout.Padding = UDim.new(0, 8)
	buttonLayout.Parent = buttonBar

	local closeBtn = Instance.new("TextButton")
	closeBtn.Size = UDim2.new(0, Device.IS_TINY_PHONE and 70 or 90, 1, 0)
	closeBtn.BackgroundColor3 = C.Gray200
	closeBtn.Font = F.Button
	closeBtn.TextSize = textSize(12)
	closeBtn.TextColor3 = C.Gray700
	closeBtn.Text = "Cancel"
	closeBtn.AutoButtonColor = false
	closeBtn.Parent = buttonBar
	corner(closeBtn, 8)

	local applyBtn = Instance.new("TextButton")
	applyBtn.Size = UDim2.new(0, Device.IS_TINY_PHONE and 120 or 150, 1, 0)
	applyBtn.BackgroundColor3 = Color3.fromRGB(249, 200, 10)
	applyBtn.Font = F.Button
	applyBtn.TextSize = textSize(13)
	applyBtn.TextColor3 = C.Black
	applyBtn.Text = "Apply Changes"
	applyBtn.AutoButtonColor = false
	applyBtn.Parent = buttonBar
	corner(applyBtn, 8)

	closeBtn.MouseButton1Click:Connect(destroyGodModeModal)

	applyBtn.MouseButton1Click:Connect(function()
		errorLabel.Text = ""
		local payload = { stats = {} }
		local trimmedName = nameInput.Text and nameInput.Text:gsub("^%s+", ""):gsub("%s+$", "") or ""
		if trimmedName ~= "" and trimmedName ~= (currentState.Name or "") then
			payload.name = trimmedName
		end

		for key, input in pairs(statInputs) do
			local value = tonumber(input.Text)
			if value then
				payload.stats[key] = value
			end
		end

		local moneyValue = tonumber(moneyInput.Text)
		if moneyValue then
			payload.money = moneyValue
		end

		local careerText = careerInput.Text and careerInput.Text:gsub("^%s+", ""):gsub("%s+$", "") or ""
		if careerText ~= "" then
			if careerText:lower() == "clear" or careerText:lower() == "none" then
				payload.clearCareer = true
			else
				payload.careerId = careerText
			end
		end

		local hasChanges = payload.name or payload.money or payload.careerId or payload.clearCareer
		if payload.stats and next(payload.stats) ~= nil then
			hasChanges = true
		else
			payload.stats = nil
		end

		if not hasChanges then
			errorLabel.Text = "Enter at least one change."
			return
		end

		if not GodModeEdit then
			errorLabel.Text = "Server not ready for God Mode edits."
			return
		end

		applyBtn.Text = "Saving..."
		applyBtn.AutoButtonColor = false

		local ok, result = pcall(function()
			return GodModeEdit:InvokeServer(payload)
		end)

		if ok and result and result.success then
			addFeedEntry(result.message or "God Mode updated.")
			destroyGodModeModal()
		else
			errorLabel.Text = (result and result.message) or "Unable to apply changes."
			applyBtn.Text = "Apply Changes"
		end
	end)
end

----------------------------------------------------------------
-- NAV BAR - TINY PHONE FIX: More compact
-- CRITICAL FIX: Wrapped in IIFE to reduce local register usage
----------------------------------------------------------------

-- Variables that need to be accessible outside IIFE
local navBar, navBtnRefs
local navBarHeight = Device.IS_TINY_PHONE and 50 or (Device.IS_SMALL_PHONE and 60 or px(80))

;(function()
-- TINY PHONE FIX: Much smaller nav bar
navBar = Instance.new("Frame")
navBar.Name = "NavBar"
navBar.Size = UDim2.new(1, 0, 0, navBarHeight)
navBar.AnchorPoint = Vector2.new(0.5, 1)
navBar.Position = UDim2.new(0.5, 0, 1, 0)
navBar.BackgroundColor3 = C.NavBlue
navBar.ZIndex = 6
navBar.Parent = mainContainer

local navGrad = Instance.new("UIGradient")
navGrad.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, C.NavBlue),
	ColorSequenceKeypoint.new(1, C.NavDark),
})
navGrad.Rotation = 90
navGrad.Parent = navBar

-- TINY PHONE FIX: Smaller center gap for age button
local ageBtnGap = Device.IS_TINY_PHONE and 28 or (Device.IS_SMALL_PHONE and 36 or px(50))
local navLeft = Instance.new("Frame")
navLeft.Name = "NavLeft"
navLeft.Size = UDim2.new(0.5, -ageBtnGap, 1, 0)
navLeft.Position = UDim2.new(0, 0, 0, 0)
navLeft.BackgroundTransparency = 1
navLeft.ZIndex = 7
navLeft.Parent = navBar
local navPadSide = Device.IS_TINY_PHONE and 4 or padSize(8)
local navPadTop = Device.IS_TINY_PHONE and 4 or padSize(6)
local navPadBottom = Device.IS_TINY_PHONE and 12 or padSize(20)
pad(navLeft, navPadSide, Device.IS_TINY_PHONE and 8 or padSize(15), navPadTop, navPadBottom)

local navLeftLayout = Instance.new("UIListLayout")
navLeftLayout.FillDirection = Enum.FillDirection.Horizontal
navLeftLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
navLeftLayout.VerticalAlignment = Enum.VerticalAlignment.Center
navLeftLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 2 or padSize(6))
navLeftLayout.Parent = navLeft

local navRight = Instance.new("Frame")
navRight.Name = "NavRight"
navRight.Size = UDim2.new(0.5, -ageBtnGap, 1, 0)
navRight.Position = UDim2.new(0.5, ageBtnGap, 0, 0)
navRight.BackgroundTransparency = 1
navRight.ZIndex = 7
navRight.Parent = navBar
pad(navRight, Device.IS_TINY_PHONE and 8 or padSize(15), navPadSide, navPadTop, navPadBottom)

local navRightLayout = Instance.new("UIListLayout")
navRightLayout.FillDirection = Enum.FillDirection.Horizontal
navRightLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
navRightLayout.VerticalAlignment = Enum.VerticalAlignment.Center
navRightLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 2 or padSize(6))
navRightLayout.Parent = navRight

navBtnRefs = {}

-- CRITICAL FIX: Adjusted nav button sizes for 5 buttons (added Story Paths)
-- Slightly smaller to fit all buttons without overflow
local navBtnWidth = Device.IS_TINY_PHONE and 32 or (Device.IS_SMALL_PHONE and 38 or px(48))
local navBtnHeight = Device.IS_TINY_PHONE and 30 or btnHeight(46)

local function createNavButton(info, parent, order)
	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(0, navBtnWidth, 0, navBtnHeight)
	btn.BackgroundTransparency = 1
	btn.AutoButtonColor = false
	btn.LayoutOrder = order
	btn.Text = ""
	btn.ZIndex = 8
	btn.Parent = parent

	local btnLayout = Instance.new("UIListLayout")
	btnLayout.FillDirection = Enum.FillDirection.Vertical
	btnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	btnLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 0 or 1)
	btnLayout.Parent = btn

	local iconLbl = Instance.new("TextLabel")
	iconLbl.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 16 or px(24))
	iconLbl.BackgroundTransparency = 1
	iconLbl.Font = F.Body
	iconLbl.TextSize = Device.IS_TINY_PHONE and 14 or textSize(20)
	iconLbl.TextColor3 = C.White
	iconLbl.Text = info.icon
	iconLbl.ZIndex = 9
	iconLbl.Parent = btn

	local textLbl = Instance.new("TextLabel")
	textLbl.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 10 or px(14))
	textLbl.BackgroundTransparency = 1
	textLbl.Font = F.Medium
	textLbl.TextSize = Device.IS_TINY_PHONE and 8 or textSize(10)
	textLbl.TextColor3 = Color3.fromRGB(148, 163, 184)
	textLbl.Text = info.text
	textLbl.ZIndex = 9
	textLbl.Parent = btn

	btn.MouseEnter:Connect(function()
		iconLbl.TextColor3 = C.Yellow
		textLbl.TextColor3 = C.White
	end)
	btn.MouseLeave:Connect(function()
		iconLbl.TextColor3 = C.White
		textLbl.TextColor3 = Color3.fromRGB(148, 163, 184)
	end)

	btn.MouseButton1Click:Connect(function()
		if info.screen == "occupation" and ScreenInstances.occupation then
			ScreenInstances.occupation:show()
		elseif info.screen == "assets" and ScreenInstances.assets then
			ScreenInstances.assets:show()
		elseif info.screen == "relationships" and ScreenInstances.relationships then
			ScreenInstances.relationships:show()
		elseif info.screen == "activities" and ScreenInstances.activities then
			ScreenInstances.activities:show()
		elseif info.screen == "storypaths" and ScreenInstances.storypaths then
			ScreenInstances.storypaths:show()
		end
	end)

	navBtnRefs[info.screen] = btn
	return btn
end

-- BitLife-style nav: Jobs, Assets, Relationships, Activities, Story Paths
-- CRITICAL FIX: Added Story Paths button that was missing from bottom navigation
-- CRITICAL FIX #801: Shortened text labels to prevent overlap on right side
createNavButton({ icon = "ðŸ’¼", text = "Jobs",    screen = "occupation"   }, navLeft,  1)
createNavButton({ icon = "ðŸ ", text = "Assets",  screen = "assets"       }, navLeft,  2)
createNavButton({ icon = "ðŸ‘¥", text = "People",  screen = "relationships"}, navRight, 1)  -- CRITICAL FIX #801: "Relations" -> "People"
createNavButton({ icon = "âš¡", text = "Actions", screen = "activities"   }, navRight, 2)  -- CRITICAL FIX #801: "Activities" -> "Actions"
createNavButton({ icon = "ðŸ“–", text = "Story",   screen = "storypaths"   }, navRight, 3)  -- CRITICAL FIX #801: "Paths" -> "Story"
end)() -- End Nav Bar IIFE

----------------------------------------------------------------
-- AGE BUTTON - TINY PHONE FIX: More compact
-- CRITICAL FIX: Wrapped in IIFE to reduce local register usage
----------------------------------------------------------------

-- Variables that need to be accessible outside IIFE
local ageBtnContainer, ageButton, ageOuterRing, ageBtnSize

;(function()
-- TINY PHONE FIX: Much smaller age button
ageBtnSize = Device.IS_TINY_PHONE and 54 or (Device.IS_SMALL_PHONE and 65 or px(90))
local ageBtnOffset = Device.IS_TINY_PHONE and 6 or padSize(10)
ageBtnContainer = Instance.new("Frame")
ageBtnContainer.Size = UDim2.new(0, ageBtnSize, 0, ageBtnSize)
ageBtnContainer.AnchorPoint = Vector2.new(0.5, 0.5)
ageBtnContainer.Position = UDim2.new(0.5, 0, 1, -(navBarHeight/2 + ageBtnOffset))
ageBtnContainer.BackgroundTransparency = 1
ageBtnContainer.ZIndex = 15
ageBtnContainer.Parent = mainContainer

ageOuterRing = Instance.new("Frame")
ageOuterRing.Size = UDim2.new(1, Device.IS_TINY_PHONE and 4 or 8, 1, Device.IS_TINY_PHONE and 4 or 8)
ageOuterRing.AnchorPoint = Vector2.new(0.5, 0.5)
ageOuterRing.Position = UDim2.fromScale(0.5, 0.5)
ageOuterRing.BackgroundColor3 = C.White
ageOuterRing.ZIndex = 15
ageOuterRing.Parent = ageBtnContainer
corner(ageOuterRing, ageBtnSize/2)

local ageShadowSize = Device.IS_TINY_PHONE and 10 or 16
local ageShadow = Instance.new("Frame")
ageShadow.Size = UDim2.new(1, ageShadowSize, 1, ageShadowSize)
ageShadow.AnchorPoint = Vector2.new(0.5, 0.5)
ageShadow.Position = UDim2.new(0.5, 0, 0.5, Device.IS_TINY_PHONE and 2 or 4)
ageShadow.BackgroundColor3 = C.Black
ageShadow.BackgroundTransparency = 0.9
ageShadow.ZIndex = 14
ageShadow.Parent = ageBtnContainer
corner(ageShadow, ageBtnSize/2 + (Device.IS_TINY_PHONE and 2 or 4))

local ageBtnMargin = Device.IS_TINY_PHONE and 4 or 6
ageButton = Instance.new("TextButton")
ageButton.Size = UDim2.new(1, -ageBtnMargin, 1, -ageBtnMargin)
ageButton.AnchorPoint = Vector2.new(0.5, 0.5)
ageButton.Position = UDim2.fromScale(0.5, 0.5)
ageButton.BackgroundColor3 = C.Green
ageButton.AutoButtonColor = false
ageButton.Text = ""
ageButton.ZIndex = 16
ageButton.Parent = ageBtnContainer
corner(ageButton, ageBtnSize/2 - (Device.IS_TINY_PHONE and 2 or 3))
stroke(ageButton, Device.IS_TINY_PHONE and 2 or 3, 0, C.GreenRing)

local ageGrad = Instance.new("UIGradient")
ageGrad.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(74, 222, 128)),
	ColorSequenceKeypoint.new(1, C.Green),
})
ageGrad.Rotation = 90
ageGrad.Parent = ageButton

-- Age button content - use vertical layout for proper stacking
local ageBtnContent = Instance.new("Frame")
ageBtnContent.Size = UDim2.fromScale(1, 1)
ageBtnContent.BackgroundTransparency = 1
ageBtnContent.ZIndex = 17
ageBtnContent.Parent = ageButton

local ageBtnLayout = Instance.new("UIListLayout")
ageBtnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
ageBtnLayout.VerticalAlignment = Enum.VerticalAlignment.Center
ageBtnLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and -2 or 0)
ageBtnLayout.Parent = ageBtnContent

local agePlus = Instance.new("TextLabel")
agePlus.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 22 or px(32))
agePlus.BackgroundTransparency = 1
agePlus.Font = F.Title
agePlus.TextSize = Device.IS_TINY_PHONE and 24 or textSize(32)
agePlus.TextColor3 = C.White
agePlus.Text = "+"
agePlus.LayoutOrder = 1
agePlus.ZIndex = 17
agePlus.Parent = ageBtnContent

local ageText = Instance.new("TextLabel")
ageText.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 14 or 18)
ageText.BackgroundTransparency = 1
ageText.Font = F.Button
ageText.TextSize = Device.IS_TINY_PHONE and 11 or 16
ageText.TextColor3 = C.White
ageText.Text = "Age"
ageText.LayoutOrder = 2
ageText.ZIndex = 17
ageText.Parent = ageBtnContent

local tutorialRing = Instance.new("Frame")
tutorialRing.Size = UDim2.new(1, Device.IS_TINY_PHONE and 20 or 30, 1, Device.IS_TINY_PHONE and 20 or 30)
tutorialRing.AnchorPoint = Vector2.new(0.5, 0.5)
tutorialRing.Position = UDim2.fromScale(0.5, 0.5)
tutorialRing.BackgroundTransparency = 1
tutorialRing.Visible = false
tutorialRing.ZIndex = 14
tutorialRing.Parent = ageBtnContainer
corner(tutorialRing, 60)
stroke(tutorialRing, 4, 0, C.White) -- Changed to WHITE and thicker for visibility

----------------------------------------------------------------
-- TUTORIAL OVERLAY
----------------------------------------------------------------

local tutorialOverlay = Instance.new("Frame")
tutorialOverlay.Size = UDim2.fromScale(1, 1)
tutorialOverlay.BackgroundTransparency = 1
tutorialOverlay.Visible = false
tutorialOverlay.ZIndex = 40
tutorialOverlay.Parent = screenGui

local tutTextCont = Instance.new("Frame")
tutTextCont.Size = UDim2.new(0.85, 0, 0, 0)
tutTextCont.AutomaticSize = Enum.AutomaticSize.Y
tutTextCont.AnchorPoint = Vector2.new(0.5, 1)
-- Position above the age button (which is near bottom of screen)
tutTextCont.Position = UDim2.new(0.5, 0, 1, Device.IS_TINY_PHONE and -140 or -180)
tutTextCont.BackgroundTransparency = 1
tutTextCont.Parent = tutorialOverlay

local tutLayout = Instance.new("UIListLayout")
tutLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
tutLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 4 or 8)
tutLayout.Parent = tutTextCont

-- Tutorial text FIRST, then pointing finger at the bottom (pointing DOWN to Age button)
local tutLines = {
	{ text = "Tap the AGE button to grow older!", isEmoji = false },
	{ text = "Make choices as events happen.", isEmoji = false },
	{ text = "Live your best (or worst) life!", isEmoji = false },
	{ text = "ðŸ‘‡", isEmoji = true },  -- Finger at BOTTOM pointing DOWN to Age button
}
for i, lineData in ipairs(tutLines) do
	local lbl = Instance.new("TextLabel")
	lbl.Size = UDim2.new(1, 0, 0, lineData.isEmoji and 40 or (Device.IS_TINY_PHONE and 22 or 28))
	lbl.BackgroundTransparency = 1
	lbl.Font = lineData.isEmoji and F.Body or F.Title
	lbl.TextSize = lineData.isEmoji and 36 or (Device.IS_TINY_PHONE and 16 or 20)
	lbl.TextColor3 = C.Gray900  -- DARK text for visibility
	lbl.TextStrokeColor3 = C.White
	lbl.TextStrokeTransparency = 0.5  -- White outline for contrast
	lbl.Text = lineData.text
	lbl.LayoutOrder = i
	lbl.Parent = tutTextCont
end

showTutorial = function()
	if hasShownAgeHint then return end
	hasShownAgeHint = true
	tutorialOverlay.Visible = true
	tutorialRing.Visible = true

	-- Pulse the ring stroke for attention
	local pulse = TweenInfo.new(0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
	local s = tutorialRing:FindFirstChildOfClass("UIStroke")
	if s then
		s.Color = C.White -- Ensure it's white
		s.Thickness = 4
		tween(s, pulse, { Transparency = 0.4, Thickness = 6 })
	end

	-- Also scale pulse the ring for extra visibility
	local scalePulse = TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
	tween(tutorialRing, scalePulse, { 
		Size = UDim2.new(1, 38, 1, 38) 
	})
end

hideTutorial = function()
	tutorialOverlay.Visible = false
	tutorialRing.Visible = false
	-- Reset ring size for next time
	tutorialRing.Size = UDim2.new(1, 30, 1, 30)
end
end)() -- End Age Button/Tutorial IIFE

----------------------------------------------------------------
-- PREMIUM EVENT MODAL (BitLife-style red card) - MOBILE FIX
----------------------------------------------------------------

-- EventUI table to store event modal references and reduce local variable count
local EventUI = {
	activeChoiceButtons = {},
	currentEventId = nil,
	surpriseConnection = nil,
	currentHideTween = nil,
}

-- Builder function to create event modal UI
local function buildEventModal()
	EventUI.overlay = Instance.new("Frame")
	EventUI.overlay.Name = "EventOverlay"
	EventUI.overlay.Size = UDim2.fromScale(1, 1)
	EventUI.overlay.BackgroundColor3 = C.Black
	EventUI.overlay.BackgroundTransparency = 0.45
	EventUI.overlay.Visible = false
	EventUI.overlay.ZIndex = 60
	EventUI.overlay.Parent = screenGui

	-- MOBILE FIX: Responsive modal sizing for ALL mobile devices
	local eventWidth = modalWidth(360)
	local maxEventHeight
	if Device.IS_TINY_PHONE then
		maxEventHeight = Device.ViewportSize.Y - 80
	elseif Device.IS_SMALL_PHONE then
		maxEventHeight = Device.ViewportSize.Y - 100
	elseif Device.IS_MOBILE then
		maxEventHeight = Device.ViewportSize.Y - 120
	else
		maxEventHeight = Device.ViewportSize.Y - 140
	end
	
	-- Calculate responsive corner radii and margins (slightly larger for cleaner look)
	local eventCornerRadius = Device.IS_TINY_PHONE and 14 or (Device.IS_SMALL_PHONE and 18 or px(24))
	local shellMargin = Device.IS_TINY_PHONE and 3 or (Device.IS_SMALL_PHONE and 4 or 4)
	local cardMargin = Device.IS_TINY_PHONE and 6 or (Device.IS_SMALL_PHONE and 8 or 8)
	
	-- Shadow frame: fixed width, autosize height
	EventUI.shadowFrame = Instance.new("Frame")
	EventUI.shadowFrame.Size = UDim2.new(0, eventWidth, 0, 0)
	EventUI.shadowFrame.AutomaticSize = Enum.AutomaticSize.Y
	EventUI.shadowFrame.AnchorPoint = Vector2.new(0.5, 0.5)
	EventUI.shadowFrame.Position = UDim2.fromScale(0.5, 0.5)
	EventUI.shadowFrame.BackgroundColor3 = C.Black
	EventUI.shadowFrame.BackgroundTransparency = 0.88
	EventUI.shadowFrame.ZIndex = 61
	EventUI.shadowFrame.Parent = EventUI.overlay
	corner(EventUI.shadowFrame, eventCornerRadius)
	
	-- Add size constraint to prevent modal from being too tall
	local eventSizeConstraint = Instance.new("UISizeConstraint")
	eventSizeConstraint.MaxSize = Vector2.new(eventWidth, maxEventHeight)
	eventSizeConstraint.Parent = EventUI.shadowFrame

	-- Shell: autosize height (no Y scale) - fixes button overflow
	EventUI.shell = Instance.new("Frame")
	EventUI.shell.Name = "EventShell"
	EventUI.shell.Size = UDim2.new(1, -shellMargin, 0, 0)
	EventUI.shell.AutomaticSize = Enum.AutomaticSize.Y
	EventUI.shell.Position = UDim2.new(0, shellMargin/2, 0, shellMargin/2)
	EventUI.shell.BackgroundColor3 = C.Red
	EventUI.shell.ZIndex = 62
	EventUI.shell.Parent = EventUI.shadowFrame
	corner(EventUI.shell, Device.IS_TINY_PHONE and 12 or (Device.IS_SMALL_PHONE and 16 or px(22)))
	stroke(EventUI.shell, Device.IS_TINY_PHONE and 1 or 2, 0.3, C.RedDark)
	if not Device.IS_TINY_PHONE then
		createShadow(EventUI.shell, Device.IS_SMALL_PHONE and 4 or 6, Device.IS_SMALL_PHONE and px(14) or px(20), C.Black, 0.85)
	end

	-- Card: autosize height (no Y scale) - fixes button overflow
	EventUI.card = Instance.new("Frame")
	EventUI.card.Name = "EventCard"
	EventUI.card.Size = UDim2.new(1, -cardMargin, 0, 0)
	EventUI.card.AutomaticSize = Enum.AutomaticSize.Y
	EventUI.card.Position = UDim2.new(0, cardMargin/2, 0, cardMargin/2)
	EventUI.card.BackgroundColor3 = C.White
	EventUI.card.ZIndex = 63
	EventUI.card.ClipsDescendants = true  -- Safety clip to prevent visual leaks
	EventUI.card.Parent = EventUI.shell
	corner(EventUI.card, Device.IS_TINY_PHONE and 10 or (Device.IS_SMALL_PHONE and 14 or px(20)))

	local eventLayout = Instance.new("UIListLayout")
	eventLayout.Padding = UDim.new(0, 0)
	eventLayout.SortOrder = Enum.SortOrder.LayoutOrder  -- CRITICAL: Force correct order
	eventLayout.Parent = EventUI.card

	-- TINY PHONE FIX: Much smaller header
	local eventHeaderHeight = Device.IS_TINY_PHONE and 44 or (Device.IS_SMALL_PHONE and 54 or px(76))
	EventUI.header = Instance.new("Frame")
	EventUI.header.Name = "Header"
	EventUI.header.Size = UDim2.new(1, 0, 0, eventHeaderHeight)
	EventUI.header.BackgroundColor3 = C.White
	EventUI.header.LayoutOrder = 1
	EventUI.header.Visible = false
	EventUI.header.ZIndex = 64
	EventUI.header.Parent = EventUI.card
	pad(EventUI.header, padSize(16), padSize(16), padSize(10), padSize(8))

	-- TINY PHONE FIX: Smaller avatar
	local eventAvatarSize = Device.IS_TINY_PHONE and 28 or (Device.IS_SMALL_PHONE and 36 or px(50))
	EventUI.avatar = Instance.new("Frame")
	EventUI.avatar.Size = UDim2.new(0, eventAvatarSize, 0, eventAvatarSize)
	EventUI.avatar.BackgroundColor3 = Color3.fromRGB(254, 226, 226)
	EventUI.avatar.ZIndex = 65
	EventUI.avatar.Parent = EventUI.header
	corner(EventUI.avatar, eventAvatarSize/2)
	stroke(EventUI.avatar, Device.IS_TINY_PHONE and 1 or 2, 0.3, C.Red)

	EventUI.avatarEmoji = Instance.new("TextLabel")
	EventUI.avatarEmoji.Size = UDim2.fromScale(1, 1)
	EventUI.avatarEmoji.BackgroundTransparency = 1
	EventUI.avatarEmoji.Font = F.Body
	EventUI.avatarEmoji.TextSize = Device.IS_TINY_PHONE and 16 or textSize(26)
	EventUI.avatarEmoji.Text = "ðŸ‘¤"
	EventUI.avatarEmoji.ZIndex = 66
	EventUI.avatarEmoji.Parent = EventUI.avatar

	EventUI.nameLbl = Instance.new("TextLabel")
	EventUI.nameLbl.Size = UDim2.new(0.6, 0, 0, Device.IS_TINY_PHONE and 16 or px(22))
	EventUI.nameLbl.Position = UDim2.new(0, eventAvatarSize + padSize(8), 0, padSize(4))
	EventUI.nameLbl.BackgroundTransparency = 1
	EventUI.nameLbl.Font = F.Title
	EventUI.nameLbl.TextSize = Device.IS_TINY_PHONE and 11 or textSize(16)
	EventUI.nameLbl.TextColor3 = C.Gray900
	EventUI.nameLbl.TextXAlignment = Enum.TextXAlignment.Left
	EventUI.nameLbl.TextTruncate = Enum.TextTruncate.AtEnd
	EventUI.nameLbl.Text = "Person Name"
	EventUI.nameLbl.ZIndex = 65
	EventUI.nameLbl.Parent = EventUI.header

	-- TINY PHONE FIX: Smaller relation banner
	local relationBannerWidth = Device.IS_TINY_PHONE and 65 or (Device.IS_SMALL_PHONE and 80 or px(115))
	local relationBannerHeight = Device.IS_TINY_PHONE and 18 or px(26)
	EventUI.relationBanner = Instance.new("Frame")
	EventUI.relationBanner.Size = UDim2.new(0, relationBannerWidth, 0, relationBannerHeight)
	EventUI.relationBanner.AnchorPoint = Vector2.new(1, 0)
	EventUI.relationBanner.Position = UDim2.new(1, 0, 0, padSize(4))
	EventUI.relationBanner.BackgroundColor3 = C.Red
	EventUI.relationBanner.ZIndex = 65
	EventUI.relationBanner.Parent = EventUI.header
	pill(EventUI.relationBanner)

	EventUI.relationLbl = Instance.new("TextLabel")
	EventUI.relationLbl.Size = UDim2.fromScale(1, 0.9)
	EventUI.relationLbl.Position = UDim2.new(0, 0, 0.05, 0)
	EventUI.relationLbl.BackgroundTransparency = 1
	EventUI.relationLbl.Font = F.Button
	EventUI.relationLbl.TextSize = Device.IS_TINY_PHONE and 9 or textSize(11)
	EventUI.relationLbl.TextColor3 = C.White
	EventUI.relationLbl.Text = "Classmate"
	EventUI.relationLbl.ZIndex = 66
	EventUI.relationLbl.Parent = EventUI.relationBanner

	-- title section (emoji + event title) - TINY PHONE FIX: Much more compact
	local titleSection = Instance.new("Frame")
	titleSection.Size = UDim2.new(1, 0, 0, 0)
	titleSection.AutomaticSize = Enum.AutomaticSize.Y
	titleSection.BackgroundTransparency = 1
	titleSection.LayoutOrder = 2
	titleSection.ZIndex = 64
	titleSection.Parent = EventUI.card

	-- MOBILE FIX: Responsive tighter padding
	local titlePadTop = Device.IS_TINY_PHONE and 8 or (Device.IS_SMALL_PHONE and 10 or padSize(16))
	local titlePadBottom = Device.IS_TINY_PHONE and 4 or (Device.IS_SMALL_PHONE and 6 or padSize(8))
	local titlePadSide = Device.IS_TINY_PHONE and 8 or (Device.IS_SMALL_PHONE and 10 or padSize(16))
	local titlePadding = Instance.new("UIPadding")
	titlePadding.PaddingTop = UDim.new(0, titlePadTop)
	titlePadding.PaddingBottom = UDim.new(0, titlePadBottom)
	titlePadding.PaddingLeft = UDim.new(0, titlePadSide)
	titlePadding.PaddingRight = UDim.new(0, titlePadSide)
	titlePadding.Parent = titleSection

	local titleLayout = Instance.new("UIListLayout")
	titleLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	titleLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	titleLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 4 or padSize(10))
	titleLayout.Parent = titleSection

	-- MOBILE FIX: Responsive emoji sizing
	local eventEmojiSize = Device.IS_TINY_PHONE and 32 or (Device.IS_SMALL_PHONE and 40 or px(64))
	local eventEmojiTextSize = Device.IS_TINY_PHONE and 28 or (Device.IS_SMALL_PHONE and 36 or textSize(52))
	EventUI.emoji = Instance.new("TextLabel")
	EventUI.emoji.Size = UDim2.new(0, eventEmojiSize, 0, eventEmojiSize)
	EventUI.emoji.BackgroundTransparency = 1
	EventUI.emoji.Font = F.Body
	EventUI.emoji.TextSize = eventEmojiTextSize
	EventUI.emoji.Text = "ðŸ™‚"
	EventUI.emoji.LayoutOrder = 1
	EventUI.emoji.ZIndex = 65
	EventUI.emoji.Parent = titleSection

	-- MOBILE FIX: Responsive title text
	-- CRITICAL FIX #804: Increased title text sizes for better readability
	local eventTitleTextSize = Device.IS_TINY_PHONE and 18 or (Device.IS_SMALL_PHONE and 22 or textSize(28))
	EventUI.title = Instance.new("TextLabel")
	EventUI.title.Size = UDim2.new(1, 0, 0, 0)
	EventUI.title.AutomaticSize = Enum.AutomaticSize.Y
	EventUI.title.BackgroundTransparency = 1
	EventUI.title.Font = F.Title
	EventUI.title.TextSize = eventTitleTextSize
	EventUI.title.TextColor3 = C.Gray900
	EventUI.title.Text = "Life Event"
	EventUI.title.TextWrapped = true
	EventUI.title.TextXAlignment = Enum.TextXAlignment.Center
	EventUI.title.LayoutOrder = 2
	EventUI.title.ZIndex = 65
	EventUI.title.Parent = titleSection

	-- body + "What will you do?" question - MOBILE FIX: Responsive sizing
	local bodySection = Instance.new("Frame")
	bodySection.Size = UDim2.new(1, 0, 0, 0)
	bodySection.AutomaticSize = Enum.AutomaticSize.Y
	bodySection.BackgroundTransparency = 1
	bodySection.LayoutOrder = 3
	bodySection.ZIndex = 64
	bodySection.Parent = EventUI.card
	local bodyPadSide = Device.IS_TINY_PHONE and 10 or (Device.IS_SMALL_PHONE and 14 or padSize(28))
	local bodyPadBottom = Device.IS_TINY_PHONE and 6 or (Device.IS_SMALL_PHONE and 8 or padSize(12))
	pad(bodySection, bodyPadSide, bodyPadSide, 0, bodyPadBottom)

	local bodyLayout = Instance.new("UIListLayout")
	bodyLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	bodyLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	bodyLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 4 or (Device.IS_SMALL_PHONE and 6 or padSize(10)))
	bodyLayout.Parent = bodySection

	-- MOBILE FIX: Responsive body text with tighter line height
	-- CRITICAL FIX #USER-3: Increased body text sizes for MUCH better readability on mobile!
	-- User feedback: "text inside cards are a bit too small"
	local eventBodyTextSize = Device.IS_TINY_PHONE and 16 or (Device.IS_SMALL_PHONE and 18 or textSize(22))
	EventUI.body = Instance.new("TextLabel")
	EventUI.body.Size = UDim2.new(1, 0, 0, 0)
	EventUI.body.AutomaticSize = Enum.AutomaticSize.Y
	EventUI.body.BackgroundTransparency = 1
	EventUI.body.Font = F.Body
	EventUI.body.TextSize = eventBodyTextSize
	EventUI.body.TextColor3 = C.Gray700  -- CRITICAL FIX #USER-3: Darker color for better readability
	EventUI.body.TextWrapped = true
	EventUI.body.TextXAlignment = Enum.TextXAlignment.Center
	EventUI.body.LineHeight = Device.IS_TINY_PHONE and 1.25 or (Device.IS_SMALL_PHONE and 1.35 or 1.5)  -- Increased line height
	EventUI.body.RichText = true
	EventUI.body.Text = ""
	EventUI.body.LayoutOrder = 1
	EventUI.body.ZIndex = 65
	EventUI.body.Parent = bodySection

	-- MOBILE FIX: Responsive question text
	-- CRITICAL FIX #USER-4: Increased question text sizes for better readability
	local eventQuestionTextSize = Device.IS_TINY_PHONE and 15 or (Device.IS_SMALL_PHONE and 17 or textSize(20))
	EventUI.question = Instance.new("TextLabel")
	EventUI.question.Name = "EventQuestion"
	EventUI.question.Size = UDim2.new(1, 0, 0, 0)
	EventUI.question.AutomaticSize = Enum.AutomaticSize.Y
	EventUI.question.BackgroundTransparency = 1
	EventUI.question.Font = F.Title
	EventUI.question.TextSize = eventQuestionTextSize
	EventUI.question.TextColor3 = C.Gray800
	EventUI.question.Text = "What will you do?"
	EventUI.question.TextXAlignment = Enum.TextXAlignment.Center
	EventUI.question.TextWrapped = true
	EventUI.question.LineHeight = Device.IS_TINY_PHONE and 1.1 or (Device.IS_SMALL_PHONE and 1.15 or 1.25)
	EventUI.question.LayoutOrder = 2
	EventUI.question.ZIndex = 65
	EventUI.question.Parent = bodySection

	-- CRITICAL FIX: BitLife-style - NO SCROLLING on event cards!
	-- The card expands to show ALL buttons without scrolling
	-- Changed from ScrollingFrame to regular Frame with AutomaticSize
	EventUI.choicesSection = Instance.new("Frame")
	EventUI.choicesSection.Name = "ChoicesContainer"
	EventUI.choicesSection.Size = UDim2.new(1, 0, 0, 0)
	EventUI.choicesSection.AutomaticSize = Enum.AutomaticSize.Y  -- Expand to fit all buttons!
	EventUI.choicesSection.BackgroundTransparency = 1
	EventUI.choicesSection.LayoutOrder = 4
	EventUI.choicesSection.ZIndex = 64
	EventUI.choicesSection.Parent = EventUI.card

	-- MOBILE FIX: Tighter choice section padding
	local choicePadSide = Device.IS_TINY_PHONE and 6 or (Device.IS_SMALL_PHONE and 10 or padSize(22))
	local choicePadTop = Device.IS_TINY_PHONE and 2 or (Device.IS_SMALL_PHONE and 3 or padSize(4))
	local choicePadBottom = Device.IS_TINY_PHONE and 8 or (Device.IS_SMALL_PHONE and 12 or padSize(24))
	pad(EventUI.choicesSection, choicePadSide, choicePadSide, choicePadTop, choicePadBottom)

	local choicesLayout = Instance.new("UIListLayout")
	choicesLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	choicesLayout.SortOrder = Enum.SortOrder.LayoutOrder  -- CRITICAL: Force correct order
	-- MOBILE FIX: Tighter spacing between buttons
	choicesLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 4 or (Device.IS_SMALL_PHONE and 6 or padSize(10)))
	choicesLayout.Parent = EventUI.choicesSection
end

-- Build the event modal immediately
buildEventModal()

local function clearChoices()
	for _, b in ipairs(EventUI.activeChoiceButtons) do
		b:Destroy()
	end
	table.clear(EventUI.activeChoiceButtons)

	if EventUI.surpriseConnection then
		EventUI.surpriseConnection:Disconnect()
		EventUI.surpriseConnection = nil
	end
end

-- MOBILE FIX: Touch-friendly surprise button
local surpriseBtn = Instance.new("TextButton")
surpriseBtn.Size = UDim2.new(1, 0, 0, btnHeight(36))
surpriseBtn.BackgroundTransparency = 1
surpriseBtn.Font = F.Medium
surpriseBtn.TextSize = textSize(14)
surpriseBtn.TextColor3 = C.Gray400
surpriseBtn.Text = "âœ¨ Surprise me!"
surpriseBtn.AutoButtonColor = false
surpriseBtn.LayoutOrder = 100
surpriseBtn.ZIndex = 65
surpriseBtn.Parent = EventUI.choicesSection

surpriseBtn.MouseEnter:Connect(function()
	surpriseBtn.TextColor3 = C.Blue
end)
surpriseBtn.MouseLeave:Connect(function()
	surpriseBtn.TextColor3 = C.Gray400
end)

----------------------------------------------------------------
-- DEATH OVERLAY - MOBILE FIX: Responsive death screen
----------------------------------------------------------------

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- BITLIFE-STYLE DEATH SCREEN - Full screen memorial with comprehensive stats
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local DeathUI = {}

-- Builder function to reduce local variable count in module scope
local function buildDeathUI()
	DeathUI.overlay = Instance.new("Frame")
	DeathUI.overlay.Name = "DeathOverlay"
	DeathUI.overlay.Size = UDim2.fromScale(1, 1)
	DeathUI.overlay.BackgroundColor3 = Color3.fromRGB(15, 20, 25)
	DeathUI.overlay.BackgroundTransparency = 0
	DeathUI.overlay.Visible = false
	DeathUI.overlay.ZIndex = 120
	DeathUI.overlay.Parent = screenGui

	-- Scrollable container for all content - MOBILE FIX: Thicker scrollbar for touch
	DeathUI.scroll = Instance.new("ScrollingFrame")
	DeathUI.scroll.Name = "DeathScroll"
	DeathUI.scroll.Size = UDim2.fromScale(1, 1)
	DeathUI.scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
	DeathUI.scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
	DeathUI.scroll.BackgroundTransparency = 1
	DeathUI.scroll.ScrollBarThickness = Device.IS_MOBILE and 8 or 4
	DeathUI.scroll.ScrollBarImageColor3 = C.Gray400
	DeathUI.scroll.ZIndex = 121
	DeathUI.scroll.Parent = DeathUI.overlay

	local deathScrollLayout = Instance.new("UIListLayout")
	deathScrollLayout.Padding = UDim.new(0, 0)
	deathScrollLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	deathScrollLayout.SortOrder = Enum.SortOrder.LayoutOrder
	deathScrollLayout.Parent = DeathUI.scroll

	-- MOBILE FIX: Responsive header height
	local deathHeaderHeight = Device.IS_SMALL_PHONE and 220 or px(280)
	DeathUI.headerSection = Instance.new("Frame")
	DeathUI.headerSection.Name = "Header"
	DeathUI.headerSection.Size = UDim2.new(1, 0, 0, deathHeaderHeight)
	DeathUI.headerSection.BackgroundColor3 = Color3.fromRGB(30, 35, 45)
	DeathUI.headerSection.ZIndex = 121
	DeathUI.headerSection.LayoutOrder = 1
	DeathUI.headerSection.Parent = DeathUI.scroll

	-- MOBILE FIX: Responsive gravestone emoji
	local deathEmojiSize = Device.IS_SMALL_PHONE and 70 or px(100)
	DeathUI.emojiFrame = Instance.new("Frame")
	DeathUI.emojiFrame.Size = UDim2.new(0, deathEmojiSize, 0, deathEmojiSize)
	DeathUI.emojiFrame.Position = UDim2.new(0.5, -deathEmojiSize/2, 0, padSize(30))
	DeathUI.emojiFrame.BackgroundColor3 = Color3.fromRGB(60, 65, 75)
	DeathUI.emojiFrame.ZIndex = 122
	DeathUI.emojiFrame.Parent = DeathUI.headerSection
	corner(DeathUI.emojiFrame, deathEmojiSize/2)

	local deathEmojiLabel = Instance.new("TextLabel")
	deathEmojiLabel.Size = UDim2.fromScale(1, 1)
	deathEmojiLabel.BackgroundTransparency = 1
	deathEmojiLabel.Font = F.Body
	deathEmojiLabel.TextSize = textSize(56)
	deathEmojiLabel.Text = "âš°ï¸"
	deathEmojiLabel.ZIndex = 123
	deathEmojiLabel.Parent = DeathUI.emojiFrame

	-- MOBILE FIX: Responsive RIP label positioning
	local ripLabelY = deathEmojiSize + padSize(40)
	local ripLabel = Instance.new("TextLabel")
	ripLabel.Name = "RIP"
	ripLabel.Size = UDim2.new(1, 0, 0, px(28))
	ripLabel.Position = UDim2.new(0, 0, 0, ripLabelY)
	ripLabel.BackgroundTransparency = 1
	ripLabel.Font = F.Medium
	ripLabel.TextSize = textSize(14)
	ripLabel.TextColor3 = C.Gray400
	ripLabel.Text = "REST IN PEACE"
	ripLabel.ZIndex = 122
	ripLabel.Parent = DeathUI.headerSection

	-- MOBILE FIX: Responsive name text
	local titleLabelY = ripLabelY + px(28)
	DeathUI.title = Instance.new("TextLabel")
	DeathUI.title.Size = UDim2.new(1, -padSize(32), 0, px(36))
	DeathUI.title.Position = UDim2.new(0, padSize(16), 0, titleLabelY)
	DeathUI.title.BackgroundTransparency = 1
	DeathUI.title.Font = F.Title
	DeathUI.title.TextSize = textSize(28)
	DeathUI.title.TextColor3 = C.White
	DeathUI.title.TextWrapped = true
	DeathUI.title.Text = "Name Here"
	DeathUI.title.ZIndex = 122
	DeathUI.title.Parent = DeathUI.headerSection

	-- MOBILE FIX: Responsive lifespan text
	local lifespanY = titleLabelY + px(36)
	DeathUI.lifespan = Instance.new("TextLabel")
	DeathUI.lifespan.Name = "Lifespan"
	DeathUI.lifespan.Size = UDim2.new(1, 0, 0, px(24))
	DeathUI.lifespan.Position = UDim2.new(0, 0, 0, lifespanY)
	DeathUI.lifespan.BackgroundTransparency = 1
	DeathUI.lifespan.Font = F.Body
	DeathUI.lifespan.TextSize = textSize(16)
	DeathUI.lifespan.TextColor3 = C.Gray300
	DeathUI.lifespan.Text = "2000 - 2080 (80 years)"
	DeathUI.lifespan.ZIndex = 122
	DeathUI.lifespan.Parent = DeathUI.headerSection

	-- Cause of death
	DeathUI.cause = Instance.new("TextLabel")
	DeathUI.cause.Size = UDim2.new(0.9, 0, 0, 0)
	DeathUI.cause.Position = UDim2.new(0.05, 0, 0, 235)
	DeathUI.cause.AutomaticSize = Enum.AutomaticSize.Y
	DeathUI.cause.BackgroundTransparency = 1
	DeathUI.cause.Font = F.Body
	DeathUI.cause.TextSize = 14
	DeathUI.cause.TextColor3 = C.Gray400
	DeathUI.cause.TextWrapped = true
	DeathUI.cause.Text = "Cause of death"
	DeathUI.cause.ZIndex = 122
	DeathUI.cause.Parent = DeathUI.headerSection

	-- Stats container
	DeathUI.statsSection = Instance.new("Frame")
	DeathUI.statsSection.Name = "StatsSection"
	DeathUI.statsSection.Size = UDim2.new(1, 0, 0, 0)
	DeathUI.statsSection.AutomaticSize = Enum.AutomaticSize.Y
	DeathUI.statsSection.BackgroundColor3 = Color3.fromRGB(20, 25, 32)
	DeathUI.statsSection.ZIndex = 121
	DeathUI.statsSection.LayoutOrder = 2
	DeathUI.statsSection.Parent = DeathUI.scroll

	local statsSectionPad = Instance.new("UIPadding")
	statsSectionPad.PaddingTop = UDim.new(0, 20)
	statsSectionPad.PaddingBottom = UDim.new(0, 20)
	statsSectionPad.PaddingLeft = UDim.new(0, 16)
	statsSectionPad.PaddingRight = UDim.new(0, 16)
	statsSectionPad.Parent = DeathUI.statsSection

	local statsSectionLayout = Instance.new("UIListLayout")
	statsSectionLayout.Padding = UDim.new(0, 12)
	statsSectionLayout.SortOrder = Enum.SortOrder.LayoutOrder
	statsSectionLayout.Parent = DeathUI.statsSection

	-- Stats title
	local statsTitle = Instance.new("TextLabel")
	statsTitle.Name = "StatsTitle"
	statsTitle.Size = UDim2.new(1, 0, 0, 28)
	statsTitle.BackgroundTransparency = 1
	statsTitle.Font = F.Title
	statsTitle.TextSize = 18
	statsTitle.TextColor3 = C.White
	statsTitle.TextXAlignment = Enum.TextXAlignment.Left
	statsTitle.Text = "ðŸ“Š LIFE STATISTICS"
	statsTitle.LayoutOrder = 0
	statsTitle.ZIndex = 122
	statsTitle.Parent = DeathUI.statsSection

	DeathUI.statsFrame = Instance.new("Frame")
	DeathUI.statsFrame.Name = "StatsFrame"
	DeathUI.statsFrame.Size = UDim2.new(1, 0, 0, 0)
	DeathUI.statsFrame.AutomaticSize = Enum.AutomaticSize.Y
	DeathUI.statsFrame.BackgroundTransparency = 1
	DeathUI.statsFrame.LayoutOrder = 1
	DeathUI.statsFrame.ZIndex = 122
	DeathUI.statsFrame.Parent = DeathUI.statsSection

	local deathStatsLayout = Instance.new("UIListLayout")
	deathStatsLayout.Padding = UDim.new(0, 8)
	deathStatsLayout.Parent = DeathUI.statsFrame

	-- Achievements section
	DeathUI.achievementsSection = Instance.new("Frame")
	DeathUI.achievementsSection.Name = "AchievementsSection"
	DeathUI.achievementsSection.Size = UDim2.new(1, 0, 0, 0)
	DeathUI.achievementsSection.AutomaticSize = Enum.AutomaticSize.Y
	DeathUI.achievementsSection.BackgroundColor3 = Color3.fromRGB(25, 30, 38)
	DeathUI.achievementsSection.ZIndex = 121
	DeathUI.achievementsSection.LayoutOrder = 3
	DeathUI.achievementsSection.Parent = DeathUI.scroll

	local achievePad = Instance.new("UIPadding")
	achievePad.PaddingTop = UDim.new(0, 16)
	achievePad.PaddingBottom = UDim.new(0, 16)
	achievePad.PaddingLeft = UDim.new(0, 16)
	achievePad.PaddingRight = UDim.new(0, 16)
	achievePad.Parent = DeathUI.achievementsSection

	local achieveLayout = Instance.new("UIListLayout")
	achieveLayout.Padding = UDim.new(0, 10)
	achieveLayout.SortOrder = Enum.SortOrder.LayoutOrder
	achieveLayout.Parent = DeathUI.achievementsSection

	local achieveTitle = Instance.new("TextLabel")
	achieveTitle.Name = "AchieveTitle"
	achieveTitle.Size = UDim2.new(1, 0, 0, 24)
	achieveTitle.BackgroundTransparency = 1
	achieveTitle.Font = F.Title
	achieveTitle.TextSize = 16
	achieveTitle.TextColor3 = C.Gold or Color3.fromRGB(255, 193, 7)
	achieveTitle.TextXAlignment = Enum.TextXAlignment.Left
	achieveTitle.Text = "ðŸ† ACHIEVEMENTS"
	achieveTitle.LayoutOrder = 0
	achieveTitle.ZIndex = 122
	achieveTitle.Parent = DeathUI.achievementsSection

	DeathUI.achieveFrame = Instance.new("Frame")
	DeathUI.achieveFrame.Name = "AchieveFrame"
	DeathUI.achieveFrame.Size = UDim2.new(1, 0, 0, 0)
	DeathUI.achieveFrame.AutomaticSize = Enum.AutomaticSize.Y
	DeathUI.achieveFrame.BackgroundTransparency = 1
	DeathUI.achieveFrame.LayoutOrder = 1
	DeathUI.achieveFrame.ZIndex = 122
	DeathUI.achieveFrame.Parent = DeathUI.achievementsSection

	local achieveListLayout = Instance.new("UIListLayout")
	achieveListLayout.Padding = UDim.new(0, 6)
	achieveListLayout.Parent = DeathUI.achieveFrame

	-- Epitaph section
	DeathUI.epitaphSection = Instance.new("Frame")
	DeathUI.epitaphSection.Name = "EpitaphSection"
	DeathUI.epitaphSection.Size = UDim2.new(1, 0, 0, 0)
	DeathUI.epitaphSection.AutomaticSize = Enum.AutomaticSize.Y
	DeathUI.epitaphSection.BackgroundColor3 = Color3.fromRGB(20, 25, 32)
	DeathUI.epitaphSection.ZIndex = 121
	DeathUI.epitaphSection.LayoutOrder = 4
	DeathUI.epitaphSection.Parent = DeathUI.scroll

	local epitaphPad = Instance.new("UIPadding")
	epitaphPad.PaddingTop = UDim.new(0, 16)
	epitaphPad.PaddingBottom = UDim.new(0, 24)
	epitaphPad.PaddingLeft = UDim.new(0, 20)
	epitaphPad.PaddingRight = UDim.new(0, 20)
	epitaphPad.Parent = DeathUI.epitaphSection

	DeathUI.epitaph = Instance.new("TextLabel")
	DeathUI.epitaph.Name = "Epitaph"
	DeathUI.epitaph.Size = UDim2.new(1, 0, 0, 0)
	DeathUI.epitaph.AutomaticSize = Enum.AutomaticSize.Y
	DeathUI.epitaph.BackgroundTransparency = 1
	DeathUI.epitaph.Font = F.Body
	DeathUI.epitaph.TextSize = 14
	DeathUI.epitaph.TextColor3 = C.Gray400
	DeathUI.epitaph.TextWrapped = true
	DeathUI.epitaph.TextXAlignment = Enum.TextXAlignment.Center
	DeathUI.epitaph.Text = ""
	DeathUI.epitaph.ZIndex = 122
	DeathUI.epitaph.Parent = DeathUI.epitaphSection

	-- Restart button section (EXPANDED: Time Machine + New Life + Promo)
	DeathUI.buttonSection = Instance.new("Frame")
	DeathUI.buttonSection.Name = "ButtonSection"
	-- CRITICAL FIX: Increased height to fit promo section
	DeathUI.buttonSection.Size = UDim2.new(1, 0, 0, 300)
	DeathUI.buttonSection.BackgroundColor3 = Color3.fromRGB(15, 20, 25)
	DeathUI.buttonSection.ZIndex = 121
	DeathUI.buttonSection.LayoutOrder = 5
	DeathUI.buttonSection.Parent = DeathUI.scroll
	
	-- TIME MACHINE SECTION (BitLife-style premium feature)
	-- CRITICAL FIX #424: Use global hasTimeMachine cache, never downgrade true to false
	local function checkTimeMachineGamepass()
		-- If already true, don't even check - can't lose a purchased gamepass
		if hasTimeMachine then
			return true
		end
		if CheckGamepass then
			local success, owns = pcall(function()
				return CheckGamepass:InvokeServer("TIME_MACHINE")
			end)
			if success and owns == true then
				hasTimeMachine = true  -- ONLY upgrade to true, never downgrade
			end
		end
		return hasTimeMachine
	end
	
	local tmTitle = Instance.new("TextLabel")
	tmTitle.Size = UDim2.new(1, 0, 0, 30)
	tmTitle.Position = UDim2.new(0, 0, 0, 8)
	tmTitle.BackgroundTransparency = 1
	tmTitle.Font = F.Title
	tmTitle.TextSize = 16
	tmTitle.TextColor3 = Color3.fromRGB(255, 215, 0)
	tmTitle.Text = "â° TIME MACHINE"
	tmTitle.ZIndex = 122
	tmTitle.Parent = DeathUI.buttonSection
	DeathUI.tmTitle = tmTitle
	
	-- Time Machine buttons container
	local tmContainer = Instance.new("Frame")
	tmContainer.Size = UDim2.new(0.92, 0, 0, 85)
	tmContainer.Position = UDim2.new(0.04, 0, 0, 40)
	tmContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	tmContainer.ZIndex = 122
	tmContainer.Parent = DeathUI.buttonSection
	corner(tmContainer, 12)
	DeathUI.tmContainer = tmContainer
	
	local tmGrid = Instance.new("UIGridLayout")
	tmGrid.CellSize = UDim2.new(0.48, 0, 0, 36)
	tmGrid.CellPadding = UDim2.new(0.02, 0, 0, 6)
	tmGrid.HorizontalAlignment = Enum.HorizontalAlignment.Center
	tmGrid.SortOrder = Enum.SortOrder.LayoutOrder
	tmGrid.Parent = tmContainer
	
	local tmPad = Instance.new("UIPadding")
	tmPad.PaddingTop = UDim.new(0, 6)
	tmPad.PaddingLeft = UDim.new(0, 6)
	tmPad.PaddingRight = UDim.new(0, 6)
	tmPad.Parent = tmContainer
	
	-- CRITICAL FIX: Add "Get Unlimited Rewinds" promo button for users without gamepass
	local tmPromoContainer = Instance.new("Frame")
	tmPromoContainer.Name = "TimeMachinePromo"
	tmPromoContainer.Size = UDim2.new(0.92, 0, 0, 50)
	tmPromoContainer.Position = UDim2.new(0.04, 0, 0, 40)
	tmPromoContainer.BackgroundColor3 = Color3.fromRGB(45, 35, 60)
	tmPromoContainer.ZIndex = 122
	tmPromoContainer.Visible = false  -- Hidden by default, shown if no gamepass
	tmPromoContainer.Parent = DeathUI.buttonSection
	corner(tmPromoContainer, 12)
	DeathUI.tmPromoContainer = tmPromoContainer
	
	local tmPromoBtn = Instance.new("TextButton")
	tmPromoBtn.Size = UDim2.new(1, 0, 1, 0)
	tmPromoBtn.BackgroundTransparency = 1
	tmPromoBtn.Font = F.Title
	tmPromoBtn.TextSize = 15
	tmPromoBtn.TextColor3 = Color3.fromRGB(255, 215, 0)
	tmPromoBtn.Text = "ðŸ”“ Get Unlimited Rewinds!"
	tmPromoBtn.AutoButtonColor = false
	tmPromoBtn.ZIndex = 123
	tmPromoBtn.Parent = tmPromoContainer
	
	local tmPromoSubtext = Instance.new("TextLabel")
	tmPromoSubtext.Size = UDim2.new(1, 0, 0, 16)
	tmPromoSubtext.Position = UDim2.new(0, 0, 1, -18)
	tmPromoSubtext.BackgroundTransparency = 1
	tmPromoSubtext.Font = F.Body
	tmPromoSubtext.TextSize = 11
	tmPromoSubtext.TextColor3 = C.Gray400
	tmPromoSubtext.Text = "Go back anytime with Time Machine Pass"
	tmPromoSubtext.ZIndex = 123
	tmPromoSubtext.Parent = tmPromoContainer
	
	-- CRITICAL FIX: Promo button prompts gamepass purchase
	tmPromoBtn.MouseButton1Click:Connect(function()
		local PromptGamepass = remotesFolder:FindFirstChild("PromptGamepass")
		if PromptGamepass then
			PromptGamepass:FireServer("TIME_MACHINE")
		end
	end)
	
	local tmOptions = { {5, "5 Years"}, {10, "10 Years"}, {20, "20 Years"}, {-1, "Baby"} }
	local tmButtons = {}
	
	for i, opt in ipairs(tmOptions) do
		local tmBtn = Instance.new("TextButton")
		tmBtn.Name = "TM_" .. opt[1]
		tmBtn.BackgroundColor3 = Color3.fromRGB(80, 70, 20)
		tmBtn.Font = F.Button
		tmBtn.TextSize = 13
		tmBtn.TextColor3 = Color3.fromRGB(255, 215, 0)
		tmBtn.Text = "â° " .. opt[2]
		tmBtn.AutoButtonColor = false
		tmBtn.LayoutOrder = i
		tmBtn.ZIndex = 123
		tmBtn.Parent = tmContainer
		corner(tmBtn, 8)
		table.insert(tmButtons, {btn = tmBtn, opt = opt})
		
		tmBtn.MouseButton1Click:Connect(function()
			local UseTimeMachine = remotesFolder:FindFirstChild("UseTimeMachine")
			if UseTimeMachine then
				tmBtn.Text = "â³..."
				local ok, result = pcall(function() return UseTimeMachine:InvokeServer(opt[1]) end)
				if ok and result and result.success then
					-- CRITICAL FIX: After Time Machine success:
					-- 1. Hide the death overlay
					-- 2. Update the current state from server result
					-- 3. Refresh the UI to show new age/stats
					hideDeathOverlay()
					
					-- Update currentState with new age if provided
					if result.newAge then
						currentState.Age = result.newAge
						currentState.Health = 100 -- Restore health
						currentState.Stats = currentState.Stats or {}
						currentState.Stats.Health = 100
						
						-- Clear death flags
						if currentState.Flags then
							currentState.Flags.dead = nil
						end
					end
					
					-- Refresh UI
					if updateFromState then
						updateFromState()
					end
				elseif ok and result and result.needsProduct then
					-- CRITICAL FIX #363: Player needs to purchase developer product (one-time use)
					tmBtn.Text = "ðŸ’° " .. opt[2]
					-- The server already prompted the product purchase
					-- The ProcessReceipt will handle the time travel
				elseif ok and result and result.needsGamepass then
					-- CRITICAL FIX: Player needs to purchase the gamepass for unlimited uses
					tmBtn.Text = "ðŸ‘‘ " .. opt[2]
					-- Prompt the gamepass purchase
					local PromptGamepass = remotesFolder:FindFirstChild("PromptGamepass")
					if PromptGamepass then
						PromptGamepass:FireServer("TIME_MACHINE")
					end
				else
					tmBtn.Text = "â° " .. opt[2]
				end
			end
		end)
	end
	
	-- CRITICAL FIX #425: Function to update Time Machine UI based on gamepass ownership
	-- Uses global hasTimeMachine cache that NEVER downgrades true to false
	DeathUI.updateTimeMachineUI = function()
		-- Check if already true (purchased this session), if so don't even call server
		if not hasTimeMachine then
			-- Only call server if we don't already know they own it
			if CheckGamepass then
				local ok, owns = pcall(function() return CheckGamepass:InvokeServer("TIME_MACHINE") end)
				if ok and owns == true then
					hasTimeMachine = true  -- ONLY upgrade to true
				end
			end
		end
		
		if hasTimeMachine then
			-- User owns gamepass - show full time machine UI with UNLIMITED badge
			tmContainer.Visible = true
			tmPromoContainer.Visible = false
			tmTitle.Text = "â° TIME MACHINE (UNLIMITED)"
			tmTitle.TextColor3 = Color3.fromRGB(255, 215, 0)
			for _, data in ipairs(tmButtons) do
				data.btn.BackgroundColor3 = Color3.fromRGB(80, 70, 20)
				data.btn.TextColor3 = Color3.fromRGB(255, 215, 0)
				data.btn.Text = "â° " .. data.opt[2]
			end
		else
			-- User doesn't own gamepass - show one-time purchase options
			tmContainer.Visible = true
			tmPromoContainer.Visible = true
			tmPromoContainer.Position = UDim2.new(0.04, 0, 0, 130)
			tmTitle.Text = "â° TIME MACHINE"
			tmTitle.TextColor3 = Color3.fromRGB(200, 170, 60)
			-- Buttons work but will cost Robux per use (Developer Products)
			for _, data in ipairs(tmButtons) do
				data.btn.BackgroundColor3 = Color3.fromRGB(60, 50, 30)
				data.btn.TextColor3 = Color3.fromRGB(200, 170, 60)
				data.btn.Text = "ðŸ’° " .. data.opt[2]
			end
		end
	end

	DeathUI.restart = Instance.new("TextButton")
	DeathUI.restart.Size = UDim2.new(0.85, 0, 0, 56)
	-- CRITICAL FIX: Moved down to accommodate promo section
	DeathUI.restart.Position = UDim2.new(0.075, 0, 0, 195)
	DeathUI.restart.BackgroundColor3 = C.Green
	DeathUI.restart.Font = F.Button
	DeathUI.restart.TextSize = 20
	DeathUI.restart.TextColor3 = C.White
	DeathUI.restart.Text = "ðŸ”„ Start New Life"
	DeathUI.restart.AutoButtonColor = false
	DeathUI.restart.ZIndex = 122
	DeathUI.restart.Parent = DeathUI.buttonSection
	corner(DeathUI.restart, 16)

	DeathUI.restart.MouseEnter:Connect(function()
		tween(DeathUI.restart, TweenInfo.new(0.12), { BackgroundColor3 = C.GreenDark })
	end)
	DeathUI.restart.MouseLeave:Connect(function()
		tween(DeathUI.restart, TweenInfo.new(0.12), { BackgroundColor3 = C.Green })
	end)

	local ResetLife = remotesFolder:FindFirstChild("ResetLife")

	DeathUI.restart.MouseButton1Click:Connect(function()
		if ResetLife then
			DeathUI.restart.Text = "Starting new life..."
			ResetLife:FireServer()
		end
	end)
end

-- Build the Death UI immediately
buildDeathUI()

-- Helper to create a stat row
local function createDeathStatRow(icon, label, value, color, order)
	local row = Instance.new("Frame")
	row.Size = UDim2.new(1, 0, 0, 36)
	row.BackgroundColor3 = Color3.fromRGB(35, 40, 50)
	row.LayoutOrder = order or 0
	row.ZIndex = 123
	corner(row, 10)

	local lbl = Instance.new("TextLabel")
	lbl.Size = UDim2.new(0.55, 0, 1, 0)
	lbl.Position = UDim2.new(0, 12, 0, 0)
	lbl.BackgroundTransparency = 1
	lbl.Font = F.Medium
	lbl.TextSize = 14
	lbl.TextColor3 = C.Gray300
	lbl.TextXAlignment = Enum.TextXAlignment.Left
	lbl.Text = icon .. " " .. label
	lbl.ZIndex = 124
	lbl.Parent = row

	local val = Instance.new("TextLabel")
	val.Size = UDim2.new(0.45, -12, 1, 0)
	val.Position = UDim2.new(0.55, 0, 0, 0)
	val.BackgroundTransparency = 1
	val.Font = F.Title
	val.TextSize = 14
	val.TextColor3 = color or C.White
	val.TextXAlignment = Enum.TextXAlignment.Right
	val.Text = tostring(value)
	val.ZIndex = 124
	val.Parent = row
	
	return row
end

-- Helper to create achievement badge
local function createAchievementBadge(icon, text, order)
	local badge = Instance.new("Frame")
	badge.Size = UDim2.new(1, 0, 0, 32)
	badge.BackgroundColor3 = Color3.fromRGB(45, 40, 20)
	badge.LayoutOrder = order or 0
	badge.ZIndex = 123
	corner(badge, 8)
	
	local lbl = Instance.new("TextLabel")
	lbl.Size = UDim2.new(1, -16, 1, 0)
	lbl.Position = UDim2.new(0, 8, 0, 0)
	lbl.BackgroundTransparency = 1
	lbl.Font = F.Medium
	lbl.TextSize = 13
	lbl.TextColor3 = C.Gold or Color3.fromRGB(255, 193, 7)
	lbl.TextXAlignment = Enum.TextXAlignment.Left
	lbl.Text = icon .. " " .. text
	lbl.ZIndex = 124
	lbl.Parent = badge
	
	return badge
end

showDeathOverlay = function(causeText, age)
	local name = currentState.Name or "Unknown"
	local finalAge = age or currentState.Age or 0
	local birthYear = 2024 - finalAge
	local deathYear = 2024
	
	DeathUI.title.Text = name
	DeathUI.lifespan.Text = string.format("%d - %d (%d years)", birthYear, deathYear, finalAge)
	DeathUI.cause.Text = causeText or "Natural causes"
	DeathUI.overlay.Visible = true
	DeathUI.restart.Text = "ðŸ”„ Start New Life"
	DeathUI.scroll.CanvasPosition = Vector2.new(0, 0)
	
	-- CRITICAL FIX: Update Time Machine UI based on gamepass ownership
	if DeathUI.updateTimeMachineUI then
		DeathUI.updateTimeMachineUI()
	end

	-- Clear old stats
	for _, child in ipairs(DeathUI.statsFrame:GetChildren()) do
		if child:IsA("Frame") then child:Destroy() end
	end
	for _, child in ipairs(DeathUI.achieveFrame:GetChildren()) do
		if child:IsA("Frame") then child:Destroy() end
	end

	-- Gather comprehensive stats
	local stats = currentState.Stats or {}
	local money = currentState.Money or 0
	local happiness = stats.Happiness or currentState.Happiness or 50
	local health = stats.Health or currentState.Health or 0
	local smarts = stats.Smarts or currentState.Smarts or 50
	local looks = stats.Looks or currentState.Looks or 50
	local education = currentState.Education or "None"
	local career = currentState.CurrentJob and currentState.CurrentJob.Title or "Unemployed"
	local flags = currentState.Flags or {}
	local assets = currentState.Assets or {}
	
	-- Count assets
	local propertyCount = assets.Properties and #assets.Properties or 0
	local vehicleCount = assets.Vehicles and #assets.Vehicles or 0
	local itemCount = assets.Items and #assets.Items or 0
	
	-- Count relationships
	local relationships = currentState.Relationships or {}
	local relationshipCount = 0
	local childCount = 0
	local marriageCount = 0
	for _, rel in pairs(relationships) do
		relationshipCount = relationshipCount + 1
		if rel.Type == "Child" then childCount = childCount + 1 end
		if rel.Type == "Spouse" then marriageCount = marriageCount + 1 end
	end
	
	-- Create stat rows
	local statList = {
		{ icon = "ðŸŽ‚", label = "Years Lived", value = finalAge .. " years", color = C.White, order = 1 },
		{ icon = "ðŸ’°", label = "Net Worth", value = formatMoney(money), color = money >= 1000000 and C.Gold or (money >= 100000 and C.Green or C.White), order = 2 },
		{ icon = "ðŸ˜€", label = "Final Happiness", value = happiness .. "%", color = happiness >= 70 and C.Green or (happiness >= 40 and C.Amber or C.Red), order = 3 },
		{ icon = "â¤ï¸", label = "Final Health", value = health .. "%", color = C.Red, order = 4 },
		{ icon = "ðŸ§ ", label = "Intelligence", value = smarts .. "%", color = C.Blue, order = 5 },
		{ icon = "âœ¨", label = "Looks", value = looks .. "%", color = C.Purple, order = 6 },
		{ icon = "ðŸŽ“", label = "Education", value = education == "none" and "None" or education:gsub("^%l", string.upper), color = C.Teal, order = 7 },
		{ icon = "ðŸ’¼", label = "Last Career", value = career, color = C.Amber, order = 8 },
		{ icon = "ðŸ ", label = "Properties", value = propertyCount, color = C.White, order = 9 },
		{ icon = "ðŸš—", label = "Vehicles", value = vehicleCount, color = C.White, order = 10 },
		{ icon = "ðŸ“¦", label = "Items", value = itemCount, color = C.White, order = 11 },
		{ icon = "ðŸ‘¥", label = "Relationships", value = relationshipCount, color = C.Pink or C.Purple, order = 12 },
		{ icon = "ðŸ‘¶", label = "Children", value = childCount, color = C.White, order = 13 },
		{ icon = "ðŸ’", label = "Marriages", value = marriageCount, color = C.White, order = 14 },
	}
	
	for _, s in ipairs(statList) do
		local row = createDeathStatRow(s.icon, s.label, s.value, s.color, s.order)
		row.Parent = DeathUI.statsFrame
	end
	
	-- Generate achievements (EXPANDED - BitLife-style comprehensive list)
	local achievements = {}
	
	-- Age achievements
	if finalAge >= 100 then
		table.insert(achievements, { icon = "ðŸŽ–ï¸", text = "Centenarian - Lived 100+ years!" })
	elseif finalAge >= 80 then
		table.insert(achievements, { icon = "ðŸ‘´", text = "Golden Years - Lived to 80+" })
	elseif finalAge >= 65 then
		table.insert(achievements, { icon = "ðŸ§“", text = "Retiree - Made it to 65+" })
	end
	
	-- Early death achievements
	if finalAge < 20 then
		table.insert(achievements, { icon = "ðŸ˜¢", text = "Gone Too Soon - Died before 20" })
	elseif finalAge < 40 then
		table.insert(achievements, { icon = "ðŸ’”", text = "Life Cut Short - Died before 40" })
	end
	
	-- Wealth achievements
	if money >= 100000000 then
		table.insert(achievements, { icon = "ðŸ‘‘", text = "Billionaire Club - $100M+ net worth" })
	elseif money >= 10000000 then
		table.insert(achievements, { icon = "ðŸ’Ž", text = "Mega Millionaire - $10M+ net worth" })
	elseif money >= 1000000 then
		table.insert(achievements, { icon = "ðŸ’°", text = "Millionaire - $1M+ net worth" })
	elseif money >= 100000 then
		table.insert(achievements, { icon = "ðŸ¦", text = "Wealthy - $100K+ net worth" })
	elseif money < 0 then
		table.insert(achievements, { icon = "ðŸ’¸", text = "In Debt - Died owing money" })
	elseif money < 1000 then
		table.insert(achievements, { icon = "ðŸª™", text = "Broke - Died nearly penniless" })
	end
	
	-- Happiness achievements
	if happiness >= 90 then
		table.insert(achievements, { icon = "ðŸ˜Š", text = "Joyful Life - 90%+ happiness" })
	elseif happiness < 20 then
		table.insert(achievements, { icon = "ðŸ˜ž", text = "Miserable - Low happiness" })
	end
	
	-- Intelligence achievements
	if smarts >= 90 then
		table.insert(achievements, { icon = "ðŸ§ ", text = "Genius - 90%+ intelligence" })
	end
	
	-- Looks achievements
	if looks >= 90 then
		table.insert(achievements, { icon = "ðŸ˜", text = "Gorgeous - 90%+ looks" })
	end
	
	-- Education achievements
	if education == "phd" or education == "doctorate" then
		table.insert(achievements, { icon = "ðŸ“š", text = "Scholar - Earned a Doctorate" })
	elseif education == "master" then
		table.insert(achievements, { icon = "ðŸŽ“", text = "Academic - Master's Degree" })
	elseif education == "law" then
		table.insert(achievements, { icon = "âš–ï¸", text = "Lawyer - Earned a Law Degree" })
	elseif education == "medical" then
		table.insert(achievements, { icon = "ðŸ¥", text = "Doctor - Earned a Medical Degree" })
	elseif education == "bachelor" then
		table.insert(achievements, { icon = "ðŸŽ“", text = "Graduate - Bachelor's Degree" })
	elseif education == "none" and finalAge >= 18 then
		table.insert(achievements, { icon = "ðŸš«", text = "School Dropout - No diploma" })
	end
	
	-- Family achievements
	if childCount >= 10 then
		table.insert(achievements, { icon = "ðŸ†", text = "Super Parent - 10+ children" })
	elseif childCount >= 5 then
		table.insert(achievements, { icon = "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦", text = "Big Family - 5+ children" })
	elseif childCount >= 1 then
		table.insert(achievements, { icon = "ðŸ‘¶", text = "Parent - Had children" })
	end
	
	if marriageCount >= 3 then
		table.insert(achievements, { icon = "ðŸ’", text = "Serial Spouse - Married 3+ times" })
	elseif marriageCount >= 1 then
		table.insert(achievements, { icon = "ðŸ’’", text = "Married - Found love" })
	end
	
	-- Property/Assets achievements
	if propertyCount >= 5 then
		table.insert(achievements, { icon = "ðŸ°", text = "Property Baron - 5+ properties" })
	elseif propertyCount >= 3 then
		table.insert(achievements, { icon = "ðŸ˜ï¸", text = "Real Estate Mogul - 3+ properties" })
	elseif propertyCount >= 1 then
		table.insert(achievements, { icon = "ðŸ ", text = "Homeowner - Owned property" })
	end
	
	if vehicleCount >= 10 then
		table.insert(achievements, { icon = "ðŸŽï¸", text = "Car Enthusiast - 10+ vehicles" })
	elseif vehicleCount >= 5 then
		table.insert(achievements, { icon = "ðŸš—", text = "Car Collector - 5+ vehicles" })
	end
	
	-- Fame achievements
	if flags.famous or flags.celebrity then
		table.insert(achievements, { icon = "â­", text = "Famous - Became a celebrity" })
	end
	
	-- Crime achievements
	if flags.criminal_mastermind then
		table.insert(achievements, { icon = "ðŸ¦¹", text = "Criminal Mastermind" })
	end
	if flags.served_time or flags.ex_convict then
		table.insert(achievements, { icon = "â›“ï¸", text = "Ex-Con - Served prison time" })
	end
	if flags.never_caught and flags.criminal_record then
		table.insert(achievements, { icon = "ðŸ¥·", text = "Ghost - Never caught" })
	end
	
	-- Career achievements
	if career and career ~= "Unemployed" and career ~= "" then
		if flags.ceo or flags.executive then
			table.insert(achievements, { icon = "ðŸ‘”", text = "Executive - Reached the top" })
		elseif flags.retired then
			table.insert(achievements, { icon = "ðŸŽ‰", text = "Retired - Earned retirement" })
		end
	else
		table.insert(achievements, { icon = "ðŸ˜´", text = "Unemployed - Never held a job" })
	end
	
	-- Special achievements from flags
	if flags.war_hero then
		table.insert(achievements, { icon = "ðŸŽ–ï¸", text = "War Hero - Served honorably" })
	end
	if flags.olympic_gold or flags.champion then
		table.insert(achievements, { icon = "ðŸ…", text = "Champion - Won a major competition" })
	end
	if flags.viral or flags.influencer then
		table.insert(achievements, { icon = "ðŸ“±", text = "Influencer - Went viral" })
	end
	if flags.good_person or flags.philanthropist then
		table.insert(achievements, { icon = "ðŸ˜‡", text = "Good Samaritan - Helped others" })
	end
	if flags.world_traveler then
		table.insert(achievements, { icon = "âœˆï¸", text = "Globetrotter - Traveled the world" })
	end
	
	-- Default achievement if none earned
	if #achievements == 0 then
		table.insert(achievements, { icon = "ðŸŒŸ", text = "Lived a Life - Every journey counts" })
	end
	
	for i, achieve in ipairs(achievements) do
		local badge = createAchievementBadge(achieve.icon, achieve.text, i)
		badge.Parent = DeathUI.achieveFrame
	end
	
	-- Generate epitaph (EXPANDED - more variety and context-specific)
	local epitaphs = {
		"A life well lived, remembered by many.",
		"Gone but never forgotten.",
		"Their story may end, but their legacy lives on.",
		"Every moment was a gift.",
		"Beloved by those who knew them.",
		"Here lies one who made their mark on the world.",
		"They came, they lived, they mattered.",
		"In the end, it's not the years in your life that count, it's the life in your years.",
		"Rest in peace, forever in our hearts.",
		"Until we meet again.",
	}
	
	-- Context-specific epitaphs
	if money >= 10000000 then
		table.insert(epitaphs, "Died richer than most could dream.")
		table.insert(epitaphs, "Their wealth was legendary, their legacy even more so.")
	elseif money >= 1000000 then
		table.insert(epitaphs, "They say money can't buy happiness, but they sure tried.")
		table.insert(epitaphs, "Left behind a fortune and a legacy.")
	elseif money < 100 then
		table.insert(epitaphs, "Proved that money isn't everything.")
		table.insert(epitaphs, "Rich in spirit, if not in wallet.")
	end
	
	if happiness >= 90 then
		table.insert(epitaphs, "Lived life to the fullest with a smile.")
		table.insert(epitaphs, "Happiness was their greatest treasure.")
		table.insert(epitaphs, "Found joy in every day.")
	elseif happiness < 30 then
		table.insert(epitaphs, "May they find peace at last.")
		table.insert(epitaphs, "Rest now, the struggles are over.")
	end
	
	if finalAge >= 100 then
		table.insert(epitaphs, "A century of memories, a lifetime of love.")
		table.insert(epitaphs, "Proved that age is just a number.")
	elseif finalAge >= 90 then
		table.insert(epitaphs, "A long life filled with countless memories.")
		table.insert(epitaphs, "Witnessed history and made their own.")
	elseif finalAge < 20 then
		table.insert(epitaphs, "A candle that burned briefly but brightly.")
		table.insert(epitaphs, "Young in years, old in wisdom.")
	end
	
	if childCount >= 5 then
		table.insert(epitaphs, "Their greatest achievement: their family.")
		table.insert(epitaphs, "Surrounded by the love of many children.")
	elseif childCount >= 1 then
		table.insert(epitaphs, "Lives on through their children.")
	end
	
	if marriageCount >= 3 then
		table.insert(epitaphs, "Loved many, loved deeply.")
	elseif marriageCount >= 1 then
		table.insert(epitaphs, "Found true love in this lifetime.")
	end
	
	if flags.famous or flags.celebrity then
		table.insert(epitaphs, "A star that shone bright in the world.")
		table.insert(epitaphs, "Famous in life, legendary in death.")
	end
	
	if flags.criminal_record then
		table.insert(epitaphs, "Lived life by their own rules.")
		table.insert(epitaphs, "A complicated soul with a complicated past.")
	end
	
	if education == "phd" or education == "doctorate" then
		table.insert(epitaphs, "A brilliant mind, gone too soon.")
		table.insert(epitaphs, "Their knowledge lives on in their work.")
	end
	
	if propertyCount >= 3 then
		table.insert(epitaphs, "Built an empire, brick by brick.")
	end
	
	-- Random selection
	DeathUI.epitaph.Text = "\"" .. epitaphs[math.random(1, #epitaphs)] .. "\""
end

hideDeathOverlay = function()
	DeathUI.overlay.Visible = false
	DeathUI.restart.Text = "Start New Life"
end

----------------------------------------------------------------
-- EVENT CATEGORY COLORS (BitLife-style themed borders)
----------------------------------------------------------------

local CategoryColors = {
	-- Dangerous/negative events - RED
	disaster = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	danger = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	emergency = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	health = { shell = Color3.fromRGB(249, 115, 22), stroke = Color3.fromRGB(194, 65, 12), flash = C.Orange },

	-- Romance/relationships - PINK
	romance = { shell = C.Pink, stroke = Color3.fromRGB(219, 39, 119), flash = C.Pink },

	-- Career/money - BLUE  
	career = { shell = C.Blue, stroke = C.BlueDark, flash = C.Blue },

	-- Family - PURPLE
	family = { shell = C.Purple, stroke = Color3.fromRGB(126, 34, 206), flash = C.Purple },

	-- School - TEAL
	school = { shell = Color3.fromRGB(20, 184, 166), stroke = Color3.fromRGB(13, 148, 136), flash = Color3.fromRGB(20, 184, 166) },

	-- Social - GREEN
	social = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },

	-- Motorsport/Racing - ORANGE/GOLD (racing vibes!)
	motorsport = { shell = Color3.fromRGB(245, 158, 11), stroke = Color3.fromRGB(217, 119, 6), flash = Color3.fromRGB(251, 191, 36) },
	racing = { shell = Color3.fromRGB(245, 158, 11), stroke = Color3.fromRGB(217, 119, 6), flash = Color3.fromRGB(251, 191, 36) },

	-- Milestone events - GOLD
	milestone = { shell = Color3.fromRGB(251, 191, 36), stroke = Color3.fromRGB(202, 138, 4), flash = Color3.fromRGB(253, 224, 71) },
	
	-- CRITICAL FIX: Success events - GREEN (for things like prison escape success!)
	success = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },
	escape = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },
	positive = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },
	
	-- CRITICAL FIX #2: More positive categories for green borders
	promotion = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },
	graduation = { shell = Color3.fromRGB(251, 191, 36), stroke = Color3.fromRGB(202, 138, 4), flash = Color3.fromRGB(253, 224, 71) },
	achievement = { shell = Color3.fromRGB(251, 191, 36), stroke = Color3.fromRGB(202, 138, 4), flash = Color3.fromRGB(253, 224, 71) },
	lottery = { shell = Color3.fromRGB(251, 191, 36), stroke = Color3.fromRGB(202, 138, 4), flash = Color3.fromRGB(253, 224, 71) },
	inheritance = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },
	wedding = { shell = Color3.fromRGB(255, 182, 193), stroke = Color3.fromRGB(219, 112, 147), flash = Color3.fromRGB(255, 192, 203) }, -- Pink for wedding
	birth = { shell = Color3.fromRGB(135, 206, 235), stroke = Color3.fromRGB(70, 130, 180), flash = Color3.fromRGB(176, 224, 230) }, -- Light blue for birth
	
	-- CRITICAL FIX #3: Negative categories for red borders (explicit)
	failure = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	fired = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	arrested = { shell = C.Red, stroke = C.RedDark, flash = C.Red },

	-- Default - RED (BitLife style)
	default = { shell = C.Red, stroke = C.RedDark, flash = C.Blue },
}

-- Detect if event is a TRUE disaster/emergency (for visual effects)
-- NOTE: This should be VERY conservative - only actual life-threatening emergencies
-- Regular events (motorsport, career, social) should NOT trigger shake on appearance
local function isDisasterEvent(payload)
	local id = payload.id or ""
	local emoji = payload.emoji or ""
	local category = payload.category or ""
	local title = payload.title or ""

	-- Check ID prefix for explicit disaster events
	if id:match("^d_") or id:match("^disaster_") or id:match("^emergency_") then return true end

	-- Check dangerous emojis - ONLY actual disaster/death emojis
	-- Removed: ðŸš— (cars), ðŸ”« (crime), ðŸ˜¨ (general fear) - these are too broad
	local dangerEmojis = {"ðŸŒªï¸", "ðŸ”¥", "â›ˆï¸", "ðŸŒ€", "ðŸŒŠ", "â„ï¸", "ðŸŒ¡ï¸", "ðŸ’€", "â˜ ï¸", "ðŸ†˜", "ðŸ¥", "ðŸš¨"}
	for _, de in ipairs(dangerEmojis) do
		if emoji == de then return true end
	end

	-- Check category - only explicit disaster categories
	if category == "disaster" or category == "emergency" then
		return true
	end

	-- Check title keywords - only actual natural disasters and life-threatening emergencies
	local dangerWords = {"tornado", "hurricane", "earthquake", "flood", "blizzard", "tsunami", "wildfire", "heart attack", "stroke", "collapsed", "dying"}
	local lowerTitle = title:lower()
	for _, word in ipairs(dangerWords) do
		if lowerTitle:find(word) then return true end
	end

	return false
end

-- Get the appropriate color scheme for an event
local function getEventColors(payload)
	local category = payload.category or "default"

	-- Override for disaster events
	if isDisasterEvent(payload) then
		return CategoryColors.disaster
	end

	-- Check for category match
	if CategoryColors[category] then
		return CategoryColors[category]
	end

	return CategoryColors.default
end

----------------------------------------------------------------
-- EVENT FUNCTIONS
------------------------------------------------------------------

showEvent = function(payload)
	-- Validate payload first
	if not payload then
		warn("[LifeClient] âŒ showEvent called with nil payload!")
		awaitingEvent = false
		return
	end

	-- Cancel any in-progress hide animation to prevent race conditions
	if EventUI.currentHideTween then
		EventUI.currentHideTween:Cancel()
		EventUI.currentHideTween = nil
	end

	-- Wrap in pcall to catch errors and ensure awaitingEvent gets reset
	local success, errorMsg = pcall(function()
		awaitingEvent = true
		EventUI.currentEventId = payload.id
		clearChoices()

		-- Get category-based colors
		local colors = getEventColors(payload)
		local isDisaster = isDisasterEvent(payload)

		-- Apply themed shell color
		EventUI.shell.BackgroundColor3 = colors.shell
		local shellStroke = EventUI.shell:FindFirstChildOfClass("UIStroke")
		if shellStroke then
			shellStroke.Color = colors.stroke
		end

		-- header
		EventUI.header.Visible = payload.showRelationship or false
		if payload.showRelationship and payload.relationName then
			EventUI.nameLbl.Text = payload.relationName
			EventUI.relationLbl.Text  = payload.relationship or "Friend"
		end

		EventUI.emoji.Text     = payload.emoji or "ðŸ™‚"
		EventUI.title.Text     = payload.title or "Life Event"
		EventUI.body.Text      = payload.text or ""
		EventUI.question.Text  = payload.question or "What will you do?"

		local choiceHandlers = {}

		-- MOBILE FIX: Self-sizing choice buttons with minimum tap height
		-- CRITICAL FIX #803: Increased button text sizes for better readability
		local baseMinHeight = Device.IS_TINY_PHONE and 36 or (Device.IS_SMALL_PHONE and 40 or 48)
		local choiceBtnTextSize = Device.IS_TINY_PHONE and 13 or (Device.IS_SMALL_PHONE and 14 or 16)
		local choiceBtnCorner = Device.IS_TINY_PHONE and 8 or (Device.IS_SMALL_PHONE and 10 or 12)
		local choiceBtnPadH = Device.IS_TINY_PHONE and 6 or (Device.IS_SMALL_PHONE and 8 or 10)
		local choiceBtnPadV = Device.IS_TINY_PHONE and 3 or (Device.IS_SMALL_PHONE and 4 or 5)
		
		for i, choice in ipairs(payload.choices or {}) do
			local btn = Instance.new("TextButton")
			-- KEY: Let height auto-expand for long text
			btn.Size = UDim2.new(1, 0, 0, 0)
			btn.AutomaticSize = Enum.AutomaticSize.Y
			btn.BackgroundColor3 = C.Blue
			btn.Font = F.Button
			btn.TextSize = choiceBtnTextSize
			btn.TextColor3 = C.White
			btn.Text = choice.text
			btn.AutoButtonColor = false
			btn.LayoutOrder = i
			btn.ZIndex = 65
			btn.TextWrapped = true
			btn.TextXAlignment = Enum.TextXAlignment.Center
			btn.TextYAlignment = Enum.TextYAlignment.Center
			btn.Parent = EventUI.choicesSection

			corner(btn, choiceBtnCorner)
			stroke(btn, 1, 0.5, C.BlueLight)
			-- Add padding so text doesn't touch edges
			pad(btn, choiceBtnPadH, choiceBtnPadH, choiceBtnPadV, choiceBtnPadV)

			-- Enforce minimum tap height
			local sizeConstraint = Instance.new("UISizeConstraint")
			sizeConstraint.MinSize = Vector2.new(0, btnHeight(baseMinHeight))
			sizeConstraint.Parent = btn

			if choice.minigame then
				btn.Text = "ðŸŽ® " .. choice.text
			end

			-- Hover color only (no size change to prevent layout jumps)
			btn.MouseEnter:Connect(function()
				tween(btn, TweenInfo.new(0.1), { BackgroundColor3 = C.BlueDark })
			end)
			btn.MouseLeave:Connect(function()
				tween(btn, TweenInfo.new(0.1), { BackgroundColor3 = C.Blue })
			end)

			local choiceIndex = choice.index or i
			local minigameType = choice.minigame

			local function handleChoice()
				if not EventUI.currentEventId then return end

				-- CRITICAL FIX #444: Handle mafia operations with callback instead of server
				if payload.isMafiaOperation and payload.onMafiaChoice then
					hideEvent()
					-- Call the mafia choice callback with the accumulated modifiers from the choice
					payload.onMafiaChoice(choiceIndex, choice.accumulatedMods or {})
					return
				end

				if minigameType and minigamesInstance then
					pendingMinigameEventId     = EventUI.currentEventId
					pendingMinigameChoiceIndex = choiceIndex
					hideEvent()

					minigamesInstance:play(minigameType, function(won, data)
						SubmitChoice:FireServer(pendingMinigameEventId, pendingMinigameChoiceIndex)
						if MinigameResult then
							MinigameResult:FireServer(won, data)
						end
						pendingMinigameEventId     = nil
						pendingMinigameChoiceIndex = nil
					end)
				else
					SubmitChoice:FireServer(EventUI.currentEventId, choiceIndex)
					hideEvent()
				end
			end

			btn.MouseButton1Click:Connect(handleChoice)
			table.insert(choiceHandlers, handleChoice)
			table.insert(EventUI.activeChoiceButtons, btn)
		end

		-- CRITICAL FIX: No scroll adjustment needed - card auto-expands to fit all buttons (BitLife-style)

		-- Only show Surprise Me when there are 2+ choices
		surpriseBtn.Visible = (payload.choices and #payload.choices >= 2) or false

		EventUI.surpriseConnection = surpriseBtn.MouseButton1Click:Connect(function()
			if EventUI.currentEventId and #choiceHandlers > 0 then
				local handler = choiceHandlers[math.random(1, #choiceHandlers)]
				handler()
			end
		end)

		EventUI.overlay.Visible = true
		EventUI.shadowFrame.Position = UDim2.new(0.5, 0, 0.5, 40)
		EventUI.shadowFrame.BackgroundTransparency = 1
		EventUI.shell.BackgroundTransparency = 1
		EventUI.card.BackgroundTransparency = 1

		tween(EventUI.shadowFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
			Position = UDim2.fromScale(0.5, 0.5),
			BackgroundTransparency = 0.92,
		})
		tween(EventUI.shell, TweenInfo.new(0.25), { BackgroundTransparency = 0 })
		tween(EventUI.card, TweenInfo.new(0.25), { BackgroundTransparency = 0 })
	end) -- End of pcall

	-- Handle errors in showEvent
	if not success then
		warn("[LifeClient] âŒ ERROR in showEvent:", errorMsg)
		awaitingEvent = false
		EventUI.currentEventId = nil
		EventUI.overlay.Visible = false
	end
end

hideEvent = function()
	awaitingEvent  = false
	EventUI.currentEventId = nil

	-- Create the hide tween and track it
	EventUI.currentHideTween = tween(EventUI.shadowFrame, TweenInfo.new(0.2), {
		Position = UDim2.new(0.5, 0, 0.5, 40),
		BackgroundTransparency = 1,
	})
	tween(EventUI.shell, TweenInfo.new(0.2), { BackgroundTransparency = 1 })
	tween(EventUI.card, TweenInfo.new(0.2), { BackgroundTransparency = 1 })

	EventUI.currentHideTween.Completed:Connect(function()
		-- Only hide overlay if we're not currently showing a new event
		-- This prevents race condition where hide completes after new show started
		if not awaitingEvent then
			EventUI.overlay.Visible = false

			-- Reset event UI elements for next event
			EventUI.emoji.Text = "ðŸ™‚"
			EventUI.title.Text = ""
			EventUI.body.Text = ""
			EventUI.avatarEmoji.Text = "ðŸ‘¤"
			EventUI.nameLbl.Text = ""
			EventUI.relationLbl.Text = ""
			EventUI.header.Visible = false
		end

		EventUI.currentHideTween = nil
	end)
end

----------------------------------------------------------------
-- INTRO (gender + name) - Consolidated into IntroUI table to reduce local register usage
-- CRITICAL FIX #252: Using table instead of individual locals
----------------------------------------------------------------

local IntroUI = {}

IntroUI.overlay = Instance.new("Frame")
IntroUI.overlay.Size = UDim2.fromScale(1, 1)
IntroUI.overlay.BackgroundColor3 = C.Black
IntroUI.overlay.BackgroundTransparency = 0.5
IntroUI.overlay.Visible = false
IntroUI.overlay.ZIndex = 70
IntroUI.overlay.Parent = screenGui

IntroUI.content = Instance.new("Frame")
IntroUI.content.Size = UDim2.new(0.9, 0, 0, 0)
IntroUI.content.AutomaticSize = Enum.AutomaticSize.Y
IntroUI.content.AnchorPoint = Vector2.new(0.5, 0.5)
IntroUI.content.Position = UDim2.fromScale(0.5, 0.5)
IntroUI.content.BackgroundTransparency = 1
IntroUI.content.ZIndex = 71
IntroUI.content.Parent = IntroUI.overlay

IntroUI.layout = Instance.new("UIListLayout")
IntroUI.layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
IntroUI.layout.Padding = UDim.new(0, 20)
IntroUI.layout.Parent = IntroUI.content

IntroUI.genderTitle = Instance.new("TextLabel")
-- CRITICAL FIX: Moved title higher and gave it more space so it doesn't overlap buttons
IntroUI.genderTitle.Size = UDim2.new(1, 0, 0, 48)
IntroUI.genderTitle.BackgroundTransparency = 1
IntroUI.genderTitle.Font = F.Title
IntroUI.genderTitle.TextSize = 22
IntroUI.genderTitle.TextColor3 = C.Gray900  -- was yellow; now black-ish so it doesn't look neon
IntroUI.genderTitle.Text = "Start by picking a gender"
IntroUI.genderTitle.TextYAlignment = Enum.TextYAlignment.Top
IntroUI.genderTitle.LayoutOrder = 1
IntroUI.genderTitle.ZIndex = 72
IntroUI.genderTitle.Parent = IntroUI.content

IntroUI.genderBtns = Instance.new("Frame")
-- CRITICAL FIX: Increased height to fit Male, Female, Born Royal, AND Customize Character buttons
-- Mobile needs more space for touch targets
IntroUI.genderBtns.Size = UDim2.new(1, 0, 0, 280)
IntroUI.genderBtns.BackgroundTransparency = 1
IntroUI.genderBtns.LayoutOrder = 2
IntroUI.genderBtns.ZIndex = 71
IntroUI.genderBtns.Parent = IntroUI.content

IntroUI.genderBtnLayout = Instance.new("UIListLayout")
IntroUI.genderBtnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
-- CRITICAL FIX: Increased padding for better mobile touch targets
IntroUI.genderBtnLayout.Padding = UDim.new(0, 12)
IntroUI.genderBtnLayout.Parent = IntroUI.genderBtns

IntroUI.nameBtns = Instance.new("Frame")
IntroUI.nameBtns.Name = "NameBtns"
IntroUI.nameBtns.Size = UDim2.new(1, 0, 0, 200)
IntroUI.nameBtns.BackgroundTransparency = 1
IntroUI.nameBtns.Visible = false
IntroUI.nameBtns.LayoutOrder = 3
IntroUI.nameBtns.ZIndex = 71
IntroUI.nameBtns.Parent = IntroUI.content

IntroUI.nameBtnLayout = Instance.new("UIListLayout")
IntroUI.nameBtnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
IntroUI.nameBtnLayout.Padding = UDim.new(0, 12)
IntroUI.nameBtnLayout.Parent = IntroUI.nameBtns

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- GOD MODE CHARACTER CREATION CUSTOMIZATION
-- Full character customization at creation for God Mode owners
-- Wrapped in do-end block to reduce local register usage
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- God Mode customization data (needs to be accessible outside scope)
local GodModeCreateData = {
	customName = "",
	gender = "Male",
	ethnicity = "Random",
	familyWealth = "Middle Class",
	country = "United States",
	stats = { Happiness = 50, Health = 100, Smarts = 50, Looks = 50 },
	-- CRITICAL FIX #28: Track if player selected Royal birth
	isRoyalBirth = false,
	royalCountry = nil,
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX #251: Move makeSection helper OUTSIDE the do-block
-- This reduces local register usage inside the God Mode UI builder
-- Lua has a limit of 200 local registers per function/chunk
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function makeGodModeSection(parentScroll, title, order)
	local sec = Instance.new("Frame")
	sec.Name = "Section_" .. title
	sec.Size = UDim2.new(1, 0, 0, 0)
	sec.AutomaticSize = Enum.AutomaticSize.Y
	sec.BackgroundColor3 = C.White
	sec.LayoutOrder = order
	sec.ZIndex = 72
	sec.Parent = parentScroll
	corner(sec, 12)
	
	local p = Instance.new("UIPadding")
	p.PaddingLeft = UDim.new(0, 12)
	p.PaddingRight = UDim.new(0, 12)
	p.PaddingTop = UDim.new(0, 10)
	p.PaddingBottom = UDim.new(0, 10)
	p.Parent = sec
	
	local l = Instance.new("UIListLayout")
	l.Padding = UDim.new(0, 8)
	l.Parent = sec
	
	local t = Instance.new("TextLabel")
	t.Size = UDim2.new(1, 0, 0, 24)
	t.BackgroundTransparency = 1
	t.Text = title
	t.TextColor3 = C.Gray800
	t.TextSize = 16
	t.Font = F.Title
	t.TextXAlignment = Enum.TextXAlignment.Left
	t.LayoutOrder = 1
	t.ZIndex = 73
	t.Parent = sec
	
	return sec
end

-- Build God Mode UI in separate scope to reduce local registers
-- CRITICAL FIX: Use IIFEs (Immediately Invoked Function Expressions) to create actual new function scopes
-- do...end blocks don't create new function scopes for register allocation, only lexical scopes
;(function()
	-- Container now just holds the scroll - no fixed bottom area
	IntroUI.godModeContainer = Instance.new("Frame")
	IntroUI.godModeContainer.Name = "GodModeCustomize"
	IntroUI.godModeContainer.Size = UDim2.new(1, 0, 0, 0)
	IntroUI.godModeContainer.AutomaticSize = Enum.AutomaticSize.Y
	IntroUI.godModeContainer.BackgroundTransparency = 1
	IntroUI.godModeContainer.Visible = false
	IntroUI.godModeContainer.LayoutOrder = 4
	IntroUI.godModeContainer.ZIndex = 71
	IntroUI.godModeContainer.Parent = IntroUI.content

	-- Scroll area - full width, auto height
	local scroll = Instance.new("ScrollingFrame")
	scroll.Size = UDim2.new(1, 0, 0, 400) -- Fixed height for scrolling
	scroll.BackgroundTransparency = 1
	scroll.BackgroundColor3 = C.Bg
	scroll.ScrollBarThickness = 6
	scroll.ScrollBarImageColor3 = Color3.fromRGB(253, 230, 138)
	scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
	scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
	scroll.ScrollingEnabled = true
	scroll.ElasticBehavior = Enum.ElasticBehavior.Always
	scroll.Parent = IntroUI.godModeContainer
	IntroUI.godModeScroll = scroll

	local layout = Instance.new("UIListLayout")
	layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout.Padding = UDim.new(0, 8)
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Parent = scroll

	local padding = Instance.new("UIPadding")
	padding.PaddingLeft = UDim.new(0, 8)
	padding.PaddingRight = UDim.new(0, 8)
	padding.PaddingTop = UDim.new(0, 8)
	padding.PaddingBottom = UDim.new(0, 20)
	padding.Parent = scroll
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- BACK BUTTON AT TOP (LayoutOrder = 0)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local backBtn = Instance.new("TextButton")
	backBtn.Name = "BackBtn"
	backBtn.Size = UDim2.new(0.5, 0, 0, 32)
	backBtn.BackgroundColor3 = C.Gray200
	backBtn.Text = "â† Back to Gender"
	backBtn.TextColor3 = C.Gray600
	backBtn.TextSize = 13
	backBtn.Font = F.Medium
	backBtn.ZIndex = 73
	backBtn.LayoutOrder = 0
	backBtn.Parent = scroll
	corner(backBtn, 8)
	IntroUI.godModeBackBtn = backBtn
	
	backBtn.MouseButton1Click:Connect(function()
		IntroUI.godModeContainer.Visible = false
		IntroUI.content.AutomaticSize = Enum.AutomaticSize.Y
		IntroUI.content.Size = UDim2.new(0.9, 0, 0, 0)
		IntroUI.genderBtns.Visible = true
		IntroUI.nameBtns.Visible = false
		IntroUI.genderTitle.Text = "Start by picking a gender"
	end)
end)() -- End setup IIFE

-- CRITICAL FIX: Each section in its own IIFE to create actual new function scope and reset register count
-- Name section
;(function()
	local scroll = IntroUI.godModeScroll
	local nameSec = makeGodModeSection(scroll, "ðŸ‘¤ Character Name", 1)
	IntroUI.customNameInput = Instance.new("TextBox")
	IntroUI.customNameInput.Size = UDim2.new(1, 0, 0, 40)
	IntroUI.customNameInput.BackgroundColor3 = C.Gray100
	IntroUI.customNameInput.Text = ""
	IntroUI.customNameInput.PlaceholderText = "Enter custom name..."
	IntroUI.customNameInput.TextColor3 = C.Gray900
	IntroUI.customNameInput.PlaceholderColor3 = C.Gray400
	IntroUI.customNameInput.TextSize = 16
	IntroUI.customNameInput.Font = F.Medium
	IntroUI.customNameInput.ClearTextOnFocus = false
	IntroUI.customNameInput.LayoutOrder = 2
	IntroUI.customNameInput.ZIndex = 73
	IntroUI.customNameInput.Parent = nameSec
	corner(IntroUI.customNameInput, 8)
	IntroUI.customNameInput:GetPropertyChangedSignal("Text"):Connect(function()
		GodModeCreateData.customName = IntroUI.customNameInput.Text
	end)
end)()

-- Gender section
;(function()
	local scroll = IntroUI.godModeScroll
	local genderSec = makeGodModeSection(scroll, "âš§ Gender", 2)
	local gFrame = Instance.new("Frame")
	gFrame.Size = UDim2.new(1, 0, 0, 40)
	gFrame.BackgroundTransparency = 1
	gFrame.LayoutOrder = 2
	gFrame.ZIndex = 73
	gFrame.Parent = genderSec
	local gLayout = Instance.new("UIListLayout")
	gLayout.FillDirection = Enum.FillDirection.Horizontal
	gLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	gLayout.Padding = UDim.new(0, 8)
	gLayout.Parent = gFrame
	
	IntroUI.genderBtnsCustom = {}
	for _, gData in ipairs({{id="Male", icon="â™‚", color=C.Male}, {id="Female", icon="â™€", color=C.Female}}) do
		local btn = Instance.new("TextButton")
		btn.Size = UDim2.new(0, 100, 0, 36)
		btn.BackgroundColor3 = gData.id == "Male" and gData.color or C.Gray200
		btn.Text = gData.icon .. " " .. gData.id
		btn.TextColor3 = gData.id == "Male" and C.White or C.Gray600
		btn.TextSize = 14
		btn.Font = F.Medium
		btn.ZIndex = 74
		btn.Parent = gFrame
		corner(btn, 8)
		IntroUI.genderBtnsCustom[gData.id] = btn
		btn.MouseButton1Click:Connect(function()
			GodModeCreateData.gender = gData.id
			selectedGender = gData.id
			for id, b in pairs(IntroUI.genderBtnsCustom) do
				b.BackgroundColor3 = id == gData.id and (id == "Male" and C.Male or C.Female) or C.Gray200
				b.TextColor3 = id == gData.id and C.White or C.Gray600
			end
		end)
	end
end)()

-- Ethnicity section with emojis
;(function()
	local scroll = IntroUI.godModeScroll
	local ethSec = makeGodModeSection(scroll, "ðŸŒ Ethnicity / Heritage", 3)
	local ef = Instance.new("Frame")
	ef.Size = UDim2.new(1, 0, 0, 0)
	ef.AutomaticSize = Enum.AutomaticSize.Y
	ef.BackgroundTransparency = 1
	ef.LayoutOrder = 2
	ef.ZIndex = 73
	ef.Parent = ethSec
	local eg = Instance.new("UIGridLayout")
	eg.CellSize = UDim2.new(0, Device.IS_TINY_PHONE and 85 or 100, 0, 34)
	eg.CellPadding = UDim2.new(0, 4, 0, 4)
	eg.HorizontalAlignment = Enum.HorizontalAlignment.Center
	eg.Parent = ef
	
	local ethOpts = {
		{ id = "Random", label = "ðŸŽ² Random" }, { id = "Caucasian", label = "ðŸ§‘â€ðŸ¦± Caucasian" },
		{ id = "African", label = "ðŸ‘¨ðŸ¿ African" }, { id = "Asian", label = "ðŸ§‘ðŸ» Asian" },
		{ id = "Hispanic", label = "ðŸ§‘ðŸ½ Hispanic" }, { id = "Middle Eastern", label = "ðŸ§”ðŸ½ Middle Eastern" },
		{ id = "Indian", label = "ðŸ§‘ðŸ¾ South Asian" }, { id = "Pacific Islander", label = "ðŸï¸ Pacific Islander" },
		{ id = "Indigenous", label = "ðŸª¶ Indigenous" }, { id = "Mixed", label = "ðŸŒˆ Mixed" },
	}
	
	-- CRITICAL FIX #274: Helper function to create ethnicity buttons (isolates locals)
	IntroUI.ethnicityBtns = {}
	local function createEthBtn(ethId, ethLabel)
		local btn = Instance.new("TextButton")
		btn.Name = ethId
		btn.Size = UDim2.new(0, 100, 0, 34)
		btn.BackgroundColor3 = ethId == "Random" and C.Purple or C.Gray200
		btn.Text = ethLabel
		btn.TextColor3 = ethId == "Random" and C.White or C.Gray600
		btn.TextSize = Device.IS_TINY_PHONE and 10 or 11
		btn.Font = F.Medium
		btn.TextTruncate = Enum.TextTruncate.AtEnd
		btn.ZIndex = 74
		btn.Parent = ef
		corner(btn, 6)
		IntroUI.ethnicityBtns[ethId] = btn
		btn.MouseButton1Click:Connect(function()
			GodModeCreateData.ethnicity = ethId
			for id, bt in pairs(IntroUI.ethnicityBtns) do
				bt.BackgroundColor3 = id == ethId and C.Purple or C.Gray200
				bt.TextColor3 = id == ethId and C.White or C.Gray600
			end
		end)
	end
	for _, eth in ipairs(ethOpts) do
		createEthBtn(eth.id, eth.label)
	end
end)()

-- Wealth section
-- CRITICAL FIX #22: Link Royalty gamepass to Famous/Royal wealth option
;(function()
	local scroll = IntroUI.godModeScroll
	local ws = makeGodModeSection(scroll, "ðŸ’° Family Wealth", 4)
		IntroUI.wealthBtns = {}
		local wOpts = {
			{ id = "Poor", label = "ðŸšï¸ Poor Family", desc = "$0-500" },
			{ id = "Lower Middle", label = "ðŸ  Lower Middle Class", desc = "$1K-5K" },
			{ id = "Middle Class", label = "ðŸ¡ Middle Class", desc = "$5K-20K" },
			{ id = "Upper Middle", label = "ðŸ¢ Upper Middle Class", desc = "$50K-100K" },
			{ id = "Rich", label = "ðŸ° Wealthy Family", desc = "$500K-2M" },
			{ id = "Royal", label = "ðŸ‘‘ Royal Family", desc = "$10M+ (Gamepass)", requiresGamepass = "ROYALTY" },
		}
		
		-- CRITICAL FIX #415: Helper to check Royalty gamepass ownership (uses cached value)
		local function hasRoyaltyGamepass()
			-- First check cached value (set immediately on purchase)
			if hasRoyalty then
				return true
			end
			-- Then verify with server (updates cache)
			if CheckGamepass then
				local success, owns = pcall(function()
					return CheckGamepass:InvokeServer("ROYALTY")
				end)
				if success and owns == true then
					hasRoyalty = true
					return true
				end
			end
			return false
		end
		
		-- CRITICAL FIX #291: Helper function to create wealth buttons (isolates local registers)
		local function createWealthBtn(parent, wealthData, layoutOrder, checkRoyalty)
			local btn = Instance.new("TextButton")
			btn.Name = wealthData.id
			btn.Size = UDim2.new(1, 0, 0, 44)
			local isRoyal = wealthData.id == "Royal"
			local hasRoyal = isRoyal and checkRoyalty()
			local defaultColor = wealthData.id == "Middle Class" and C.Green or (isRoyal and (hasRoyal and Color3.fromRGB(255, 215, 0) or C.Gray300) or C.Gray100)
			btn.BackgroundColor3 = defaultColor
			btn.Text = ""
			btn.LayoutOrder = layoutOrder
			btn.ZIndex = 74
			btn.Parent = parent
			corner(btn, 8)
			
			local lbl = Instance.new("TextLabel")
			lbl.Size = UDim2.new(1, -16, 0, 24)
			lbl.Position = UDim2.new(0, 8, 0, 4)
			lbl.BackgroundTransparency = 1
			lbl.Text = isRoyal and (hasRoyal and "ðŸ‘‘ Royal Family" or "ðŸ”’ Royal Family") or wealthData.label
			lbl.TextColor3 = wealthData.id == "Middle Class" and C.White or (isRoyal and (hasRoyal and C.Gray900 or C.Gray500) or C.Gray800)
			lbl.TextSize = 14
			lbl.Font = F.Medium
			lbl.TextXAlignment = Enum.TextXAlignment.Left
			lbl.ZIndex = 75
			lbl.Parent = btn
			
			local desc = Instance.new("TextLabel")
			desc.Size = UDim2.new(1, -16, 0, 16)
			desc.Position = UDim2.new(0, 8, 0, 26)
			desc.BackgroundTransparency = 1
			desc.Text = isRoyal and (hasRoyal and "$10M+ â€¢ Prince/Princess" or "Requires Royalty Gamepass") or wealthData.desc
			desc.TextColor3 = wealthData.id == "Middle Class" and Color3.fromRGB(220, 252, 231) or (isRoyal and (hasRoyal and Color3.fromRGB(180, 150, 50) or C.Gray400) or C.Gray500)
			desc.TextSize = 11
			desc.Font = F.Body
			desc.TextXAlignment = Enum.TextXAlignment.Left
			desc.ZIndex = 75
			desc.Parent = btn
			
			IntroUI.wealthBtns[wealthData.id] = { btn = btn, label = lbl, desc = desc, isRoyal = isRoyal }
			
			btn.MouseButton1Click:Connect(function()
				if wealthData.requiresGamepass then
					local hasPass = checkRoyalty()
					if not hasPass then
						if PromptGamepass then
							pcall(function() PromptGamepass:FireServer("ROYALTY") end)
						end
						return
					end
				end
				GodModeCreateData.familyWealth = wealthData.id
				GodModeCreateData.isRoyalBirth = (wealthData.id == "Royal")
				for id, dt in pairs(IntroUI.wealthBtns) do
					local isSelected = id == wealthData.id
					local isRoyalBtn = dt.isRoyal
					local hasRoyalPass = isRoyalBtn and checkRoyalty()
					if isSelected then
						dt.btn.BackgroundColor3 = isRoyalBtn and Color3.fromRGB(255, 215, 0) or C.Green
						dt.label.TextColor3 = isRoyalBtn and C.Gray900 or C.White
						dt.desc.TextColor3 = isRoyalBtn and Color3.fromRGB(180, 150, 50) or Color3.fromRGB(220, 252, 231)
					else
						dt.btn.BackgroundColor3 = isRoyalBtn and (hasRoyalPass and Color3.fromRGB(255, 235, 180) or C.Gray300) or C.Gray100
						dt.label.TextColor3 = isRoyalBtn and (hasRoyalPass and C.Gray700 or C.Gray500) or C.Gray800
						dt.desc.TextColor3 = isRoyalBtn and (hasRoyalPass and C.Gray500 or C.Gray400) or C.Gray500
					end
				end
			end)
		end
		
		-- Create wealth buttons using helper function
		for i, w in ipairs(wOpts) do
			createWealthBtn(ws, w, i + 1, hasRoyaltyGamepass)
		end
end)()

-- CRITICAL FIX #273: Stats section - wrapped in IIFE to avoid register limit
;(function()
	local scroll = IntroUI.godModeScroll
	local ss = makeGodModeSection(scroll, "ðŸ“Š Starting Stats", 5)
	IntroUI.statSliders = {}
	
	-- Helper function to create each slider (isolates local variables)
	local function createStatSlider(parent, statKey, statIcon, statColor, layoutOrder)
		local row = Instance.new("Frame")
		row.Size = UDim2.new(1, 0, 0, 36)
		row.BackgroundTransparency = 1
		row.LayoutOrder = layoutOrder
		row.ZIndex = 73
		row.Parent = parent
		
		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(0, 80, 1, 0)
		label.BackgroundTransparency = 1
		label.Text = statIcon .. " " .. statKey
		label.TextColor3 = C.Gray700
		label.TextSize = 13
		label.Font = F.Medium
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.ZIndex = 74
		label.Parent = row
		
		local sliderBg = Instance.new("Frame")
		sliderBg.Size = UDim2.new(1, -130, 0, 12)
		sliderBg.Position = UDim2.new(0, 85, 0.5, 0)
		sliderBg.AnchorPoint = Vector2.new(0, 0.5)
		sliderBg.BackgroundColor3 = C.Gray200
		sliderBg.ZIndex = 74
		sliderBg.Parent = row
		corner(sliderBg, 6)
		
		local fill = Instance.new("Frame")
		fill.Size = UDim2.new(GodModeCreateData.stats[statKey] / 100, 0, 1, 0)
		fill.BackgroundColor3 = statColor
		fill.ZIndex = 75
		fill.Parent = sliderBg
		corner(fill, 6)
		
		local valueLabel = Instance.new("TextLabel")
		valueLabel.Size = UDim2.new(0, 40, 1, 0)
		valueLabel.Position = UDim2.new(1, -40, 0, 0)
		valueLabel.BackgroundTransparency = 1
		valueLabel.Text = tostring(GodModeCreateData.stats[statKey]) .. "%"
		valueLabel.TextColor3 = C.Gray700
		valueLabel.TextSize = 13
		valueLabel.Font = F.Medium
		valueLabel.TextXAlignment = Enum.TextXAlignment.Right
		valueLabel.ZIndex = 74
		valueLabel.Parent = row
		
		IntroUI.statSliders[statKey] = { fill = fill, value = valueLabel, bg = sliderBg }
		
		-- Dragging logic
		local dragging = false
		local function updateSlider(posX)
			local relX = math.clamp((posX - sliderBg.AbsolutePosition.X) / sliderBg.AbsoluteSize.X, 0, 1)
			local newVal = math.floor(relX * 100)
			GodModeCreateData.stats[statKey] = newVal
			fill.Size = UDim2.new(relX, 0, 1, 0)
			valueLabel.Text = tostring(newVal) .. "%"
		end
		
		sliderBg.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				dragging = true
				updateSlider(input.Position.X)
			end
		end)
		
		sliderBg.InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				dragging = false
			end
		end)
		
		game:GetService("UserInputService").InputChanged:Connect(function(input)
			if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
				updateSlider(input.Position.X)
			end
		end)
		
		game:GetService("UserInputService").InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				dragging = false
			end
		end)
	end
	
	-- Create sliders using helper function
	createStatSlider(ss, "Happiness", "ðŸ˜Š", C.Yellow, 2)
	createStatSlider(ss, "Health", "â¤ï¸", C.Green, 3)
	createStatSlider(ss, "Smarts", "ðŸ§ ", C.Purple, 4)
	createStatSlider(ss, "Looks", "ðŸ’„", C.Pink, 5)
end)()

-- Country section with flag emojis
;(function()
	local scroll = IntroUI.godModeScroll
	local cs = makeGodModeSection(scroll, "ðŸŒŽ Country of Birth", 6)
		local cOpts = {
			{id = "United States", flag = "ðŸ‡ºðŸ‡¸"}, {id = "United Kingdom", flag = "ðŸ‡¬ðŸ‡§"},
			{id = "Canada", flag = "ðŸ‡¨ðŸ‡¦"}, {id = "Australia", flag = "ðŸ‡¦ðŸ‡º"},
			{id = "Germany", flag = "ðŸ‡©ðŸ‡ª"}, {id = "France", flag = "ðŸ‡«ðŸ‡·"},
			{id = "Japan", flag = "ðŸ‡¯ðŸ‡µ"}, {id = "Brazil", flag = "ðŸ‡§ðŸ‡·"},
			{id = "Mexico", flag = "ðŸ‡²ðŸ‡½"}, {id = "India", flag = "ðŸ‡®ðŸ‡³"},
			{id = "China", flag = "ðŸ‡¨ðŸ‡³"}, {id = "Italy", flag = "ðŸ‡®ðŸ‡¹"},
			{id = "Spain", flag = "ðŸ‡ªðŸ‡¸"}, {id = "Russia", flag = "ðŸ‡·ðŸ‡º"},
			{id = "South Korea", flag = "ðŸ‡°ðŸ‡·"}, {id = "Nigeria", flag = "ðŸ‡³ðŸ‡¬"},
			{id = "South Africa", flag = "ðŸ‡¿ðŸ‡¦"}, {id = "Argentina", flag = "ðŸ‡¦ðŸ‡·"},
			{id = "Philippines", flag = "ðŸ‡µðŸ‡­"}, {id = "Indonesia", flag = "ðŸ‡®ðŸ‡©"},
		}
		local dd = Instance.new("TextButton")
		dd.Size = UDim2.new(1, 0, 0, 40); dd.BackgroundColor3 = C.Gray100
		dd.Text = "ðŸ‡ºðŸ‡¸ " .. GodModeCreateData.country; dd.TextColor3 = C.Gray800
		dd.TextSize = 14; dd.Font = F.Medium; dd.LayoutOrder = 2; dd.ZIndex = 74; dd.Parent = cs
		corner(dd, 8)
		IntroUI.countryDropdown = dd
		-- CRITICAL UI FIX: Country dropdown with proper scrollable list
		local exp = false
		local cl = Instance.new("ScrollingFrame")
		cl.Size = UDim2.new(1, 0, 0, 0); cl.BackgroundColor3 = C.White; cl.Visible = false
		cl.LayoutOrder = 3; cl.ZIndex = 80; cl.Parent = cs
		cl.ScrollBarThickness = 6
		cl.ScrollBarImageColor3 = C.Gray400
		cl.CanvasSize = UDim2.new(0, 0, 0, #cOpts * 32)
		cl.AutomaticCanvasSize = Enum.AutomaticSize.Y
		corner(cl, 8); stroke(cl, 1, 0.5, C.Gray300)
		-- CRITICAL FIX #290: Helper function to create country buttons (isolates locals)
		local cll = Instance.new("UIListLayout"); cll.Parent = cl
		local function createCountryBtn(countryId, countryFlag)
			local btn = Instance.new("TextButton")
			btn.Size = UDim2.new(1, -6, 0, 32)
			btn.BackgroundColor3 = C.White
			btn.Text = countryFlag .. " " .. countryId
			btn.TextColor3 = C.Gray700
			btn.TextSize = 13
			btn.Font = F.Body
			btn.ZIndex = 81
			btn.Parent = cl
			btn.MouseEnter:Connect(function() btn.BackgroundColor3 = C.Gray100 end)
			btn.MouseLeave:Connect(function() btn.BackgroundColor3 = C.White end)
			btn.MouseButton1Click:Connect(function()
				GodModeCreateData.country = countryId
				dd.Text = countryFlag .. " " .. countryId
				cl.Visible = false
				cl.Size = UDim2.new(1, 0, 0, 0)
				exp = false
			end)
		end
		for _, c in ipairs(cOpts) do
			createCountryBtn(c.id, c.flag)
		end
	dd.MouseButton1Click:Connect(function()
		exp = not exp; cl.Visible = exp
		-- CRITICAL UI FIX: Limit dropdown height to 180px for mobile
		cl.Size = exp and UDim2.new(1, 0, 0, math.min(#cOpts * 32, 180)) or UDim2.new(1, 0, 0, 0)
	end)
end)()

-- Start button section
;(function()
	local scroll = IntroUI.godModeScroll
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- START BUTTON AT BOTTOM OF SCROLL (LayoutOrder = 100)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	IntroUI.godModeStartBtn = Instance.new("TextButton")
	IntroUI.godModeStartBtn.Name = "StartBtn"
	IntroUI.godModeStartBtn.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 48 or 56)
	IntroUI.godModeStartBtn.BackgroundColor3 = Color3.fromRGB(253, 230, 138)
	IntroUI.godModeStartBtn.Text = "âš¡ START YOUR CUSTOM LIFE âš¡"
	IntroUI.godModeStartBtn.TextColor3 = C.Gray900
	IntroUI.godModeStartBtn.TextSize = Device.IS_TINY_PHONE and 16 or 18
	IntroUI.godModeStartBtn.Font = F.Title
	IntroUI.godModeStartBtn.ZIndex = 73
	IntroUI.godModeStartBtn.LayoutOrder = 100 -- Always at bottom
	IntroUI.godModeStartBtn.Parent = scroll
	corner(IntroUI.godModeStartBtn, 12)
	stroke(IntroUI.godModeStartBtn, 2, 0, Color3.fromRGB(217, 119, 6))
	
	IntroUI.godModeStartBtn.MouseButton1Click:Connect(function()
		local cName = GodModeCreateData.customName:gsub("^%s+", ""):gsub("%s+$", "")
		if cName == "" then
			local n = GodModeCreateData.gender == "Male" and NameData.currentMaleNames or NameData.currentFemaleNames
			cName = #n > 0 and n[1] or (GodModeCreateData.gender == "Male" and "John Doe" or "Jane Doe")
		end
		SetLifeInfo:FireServer(cName, GodModeCreateData.gender)
		-- CRITICAL FIX #28: Pass royal birth information to server
		local p = { 
			name = cName, 
			gender = GodModeCreateData.gender, 
			stats = GodModeCreateData.stats,
			godModeCreate = true, 
			familyWealth = GodModeCreateData.familyWealth,
			ethnicity = GodModeCreateData.ethnicity, 
			country = GodModeCreateData.country,
			-- CRITICAL: Royal birth flags
			isRoyalBirth = GodModeCreateData.isRoyalBirth,
			royalCountry = GodModeCreateData.royalCountry,
		}
		if GodModeEdit then pcall(function() GodModeEdit:InvokeServer(p) end) end
		-- CRITICAL FIX: Set both selectedGender AND currentState.Gender for avatar display
		selectedGender = GodModeCreateData.gender
		currentState.Gender = GodModeCreateData.gender
		currentState.Name = cName
		-- CRITICAL FIX #28: Set royal flag in local state
		if GodModeCreateData.isRoyalBirth then
			currentState.Flags = currentState.Flags or {}
			currentState.Flags.is_royalty = true
			currentState.Flags.royal_birth = true
		end
		introComplete = true
		IntroUI.content.AutomaticSize = Enum.AutomaticSize.Y
		IntroUI.content.Size = UDim2.new(0.9, 0, 0, 0)
		hideIntro()
		task.defer(function() if updateFromState then updateFromState() end end)
	end)
end)() -- End of Start button IIFE

-- Function to show God Mode customization
local function showGodModeIntroCustomize()
	-- Refresh God Mode status
	refreshGodModeStatus()
	
	if not hasGodMode then
		if PromptGamepass then
			PromptGamepass:FireServer("GOD_MODE")
		end
		return
	end
	
	-- Hide BOTH gender and name buttons
	IntroUI.genderBtns.Visible = false
	IntroUI.nameBtns.Visible = false
	
	-- Show God Mode container
	IntroUI.godModeContainer.Visible = true
	IntroUI.genderTitle.Text = "âš¡ Customize Your Character"
	IntroUI.genderTitle.Visible = true
	
	-- Adjust scroll height based on viewport
	if IntroUI.godModeScroll then
		local viewportHeight = workspace.CurrentCamera.ViewportSize.Y
		local scrollHeight = math.min(viewportHeight * 0.65, 450)
		IntroUI.godModeScroll.Size = UDim2.new(1, 0, 0, scrollHeight)
	end
	
	-- Reset to defaults but keep selected gender
	GodModeCreateData.gender = selectedGender or "Male"
	GodModeCreateData.customName = ""
	GodModeCreateData.ethnicity = "Random"
	GodModeCreateData.familyWealth = "Middle Class"
	GodModeCreateData.country = "United States"
	GodModeCreateData.stats = { Happiness = 50, Health = 100, Smarts = 50, Looks = 50 }
	
	-- Update UI to match data
	IntroUI.customNameInput.Text = ""
	-- Gender buttons
	for id, btn in pairs(IntroUI.genderBtnsCustom) do
		btn.BackgroundColor3 = id == GodModeCreateData.gender and (id == "Male" and C.Male or C.Female) or C.Gray200
		btn.TextColor3 = id == GodModeCreateData.gender and C.White or C.Gray600
	end
	-- Ethnicity buttons
	for id, btn in pairs(IntroUI.ethnicityBtns) do
		btn.BackgroundColor3 = id == "Random" and C.Purple or C.Gray200
		btn.TextColor3 = id == "Random" and C.White or C.Gray600
	end
	-- Wealth buttons
	for id, data in pairs(IntroUI.wealthBtns) do
		data.btn.BackgroundColor3 = id == "Middle Class" and C.Green or C.Gray100
		data.label.TextColor3 = id == "Middle Class" and C.White or C.Gray800
		data.desc.TextColor3 = id == "Middle Class" and Color3.fromRGB(220, 252, 231) or C.Gray500
	end
	-- Stats sliders
	for key, slider in pairs(IntroUI.statSliders) do
		local defaultVal = key == "Health" and 100 or 50
		slider.fill.Size = UDim2.new(defaultVal / 100, 0, 1, 0)
		slider.value.Text = tostring(defaultVal) .. "%"
	end
	-- Country dropdown
	if IntroUI.countryDropdown then
		IntroUI.countryDropdown.Text = "ðŸ‡ºðŸ‡¸ United States"
	end
end

-- CRITICAL FIX #416: Function to update wealth buttons after royalty gamepass purchase
-- Note: Uses hasRoyalty cache directly since checkRoyaltyGamepass may not be defined yet
IntroUI.updateWealthButtons = function()
	if IntroUI.wealthBtns and IntroUI.wealthBtns["Royal"] then
		local royalData = IntroUI.wealthBtns["Royal"]
		-- Use cached value first, then try to refresh if needed
		local hasRoyal = hasRoyalty
		if not hasRoyal and CheckGamepass then
			local success, owns = pcall(function()
				return CheckGamepass:InvokeServer("ROYALTY")
			end)
			if success and owns == true then
				hasRoyalty = true
				hasRoyal = true
			end
		end
		
		if hasRoyal then
			royalData.btn.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
			royalData.label.Text = "ðŸ‘‘ Royal Family"
			royalData.label.TextColor3 = Color3.fromRGB(30, 30, 30)
			royalData.desc.Text = "$10M+ â€¢ Prince/Princess"
			royalData.desc.TextColor3 = Color3.fromRGB(180, 150, 50)
		else
			royalData.btn.BackgroundColor3 = C.Gray300
			royalData.label.Text = "ðŸ”’ Royal Family"
			royalData.label.TextColor3 = C.Gray500
			royalData.desc.Text = "Requires Royalty Gamepass"
			royalData.desc.TextColor3 = C.Gray400
		end
	end
end

local NameData = {
	maleFirstNames = {
		"James", "Michael", "Daniel", "Alexander", "Liam", "Noah",
		"Jackson", "Elijah", "Logan", "Wyatt", "Kai", "Rowan",
	},
	femaleFirstNames = {
		"Emma", "Sophia", "Olivia", "Isabella", "Mia", "Charlotte",
		"Avery", "Camila", "Scarlett", "Chloe", "Hazel", "Naomi",
	},
	lastNames = {
		"Wilson", "Brown", "Johnson", "Williams", "Taylor", "Clark",
		"Walker", "King", "Adams", "Carter", "Parker", "Reed",
	},

	currentMaleNames = {},
	currentFemaleNames = {},
	nameColors = { C.Green, Color3.fromRGB(234, 179, 8), C.Orange }
}

-- Function to generate random names
local function generateRandomNames()
	NameData.currentMaleNames = {}
	NameData.currentFemaleNames = {}

	-- Shuffle and pick 3 unique male names
	local usedMale = {}
	for i = 1, 3 do
		local firstName, lastName
		repeat
			firstName = NameData.maleFirstNames[math.random(#NameData.maleFirstNames)]
			lastName = NameData.lastNames[math.random(#NameData.lastNames)]
		until not usedMale[firstName .. lastName]
		usedMale[firstName .. lastName] = true
		table.insert(NameData.currentMaleNames, firstName .. " " .. lastName)
	end

	-- Shuffle and pick 3 unique female names
	local usedFemale = {}
	for i = 1, 3 do
		local firstName, lastName
		repeat
			firstName = NameData.femaleFirstNames[math.random(#NameData.femaleFirstNames)]
			lastName = NameData.lastNames[math.random(#NameData.lastNames)]
		until not usedFemale[firstName .. lastName]
		usedFemale[firstName .. lastName] = true
		table.insert(NameData.currentFemaleNames, firstName .. " " .. lastName)
	end
end

for i = 1, 3 do
	local nameBtn = Instance.new("TextButton")
	nameBtn.Name = "NameBtn" .. i
	nameBtn.Size = UDim2.new(0.85, 0, 0, 54)
	nameBtn.BackgroundColor3 = NameData.nameColors[i]
	nameBtn.Font = F.Title
	nameBtn.TextSize = 18
	nameBtn.TextColor3 = C.White
	nameBtn.Text = ""
	nameBtn.AutoButtonColor = false
	nameBtn.LayoutOrder = i
	nameBtn.ZIndex = 72
	nameBtn.Parent = IntroUI.nameBtns
	pill(nameBtn)
	stroke(nameBtn, 2, 0.6, C.White)

	-- subtle size pulse is fine here
	nameBtn.MouseEnter:Connect(function()
		tween(nameBtn, TweenInfo.new(0.1), { Size = UDim2.new(0.88, 0, 0, 58) })
	end)
	nameBtn.MouseLeave:Connect(function()
		tween(nameBtn, TweenInfo.new(0.1), { Size = UDim2.new(0.85, 0, 0, 54) })
	end)

	nameBtn.MouseButton1Click:Connect(function()
		local chosenName = nameBtn.Text:match("^.-%s(.+)$") or nameBtn.Text
		SetLifeInfo:FireServer(chosenName, selectedGender)

		-- Store gender in currentState immediately so avatar updates correctly
		currentState.Gender = selectedGender
		currentState.Name = chosenName

		introComplete = true
		hideIntro()

		-- Update avatar immediately (defer to ensure function exists)
		task.defer(function()
			if updateFromState then
				updateFromState()
			end
		end)
	end)
end

-- REMOVED: Duplicate Customize button - now only on gender selection screen

updateNameButtons = function()
	local names = selectedGender == "Male" and NameData.currentMaleNames or NameData.currentFemaleNames
	local emoji = selectedGender == "Male" and "ðŸ‘¨" or "ðŸ‘©"
	for _, child in ipairs(IntroUI.nameBtns:GetChildren()) do
		if child:IsA("TextButton") and child.Name:match("^NameBtn") then
			local idx = tonumber(child.Name:match("%d+"))
			if idx and names[idx] then
				child.Text = emoji .. " " .. names[idx]
			end
		end
	end
end

local genderData = {
	{ gender = "Male",   icon = "â™‚", color = C.Male   },
	{ gender = "Female", icon = "â™€", color = C.Female },
}

for _, g in ipairs(genderData) do
	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(0.85, 0, 0, 58)
	btn.BackgroundColor3 = g.color
	btn.Font = F.Title
	btn.TextSize = 22
	btn.TextColor3 = C.White
	btn.Text = g.icon .. " " .. g.gender
	btn.AutoButtonColor = false
	btn.ZIndex = 72
	btn.Parent = IntroUI.genderBtns
	pill(btn)
	stroke(btn, 2, 0.5, C.White)

	btn.MouseEnter:Connect(function()
		tween(btn, TweenInfo.new(0.1), { Size = UDim2.new(0.88, 0, 0, 62) })
	end)
	btn.MouseLeave:Connect(function()
		tween(btn, TweenInfo.new(0.1), { Size = UDim2.new(0.85, 0, 0, 58) })
	end)

	btn.MouseButton1Click:Connect(function()
		selectedGender = g.gender
		IntroUI.genderTitle.Text = "Now, pick someone to become"

		-- Smooth fade transition from gender to names
		for _, genderBtn in ipairs(IntroUI.genderBtns:GetChildren()) do
			if genderBtn:IsA("TextButton") then
				tween(genderBtn, TweenInfo.new(0.15), { BackgroundTransparency = 1, TextTransparency = 1 })
			end
		end

		task.delay(0.15, function()
			IntroUI.genderBtns.Visible = false
			IntroUI.nameBtns.Visible  = true

			-- Reset gender buttons for next time
			for _, genderBtn in ipairs(IntroUI.genderBtns:GetChildren()) do
				if genderBtn:IsA("TextButton") then
					genderBtn.BackgroundTransparency = 0
					genderBtn.TextTransparency = 0
				end
			end

			updateNameButtons()

			-- Fade in name buttons
			for _, nameBtn in ipairs(IntroUI.nameBtns:GetChildren()) do
				if nameBtn:IsA("TextButton") then
					nameBtn.BackgroundTransparency = 1
					nameBtn.TextTransparency = 1
					tween(nameBtn, TweenInfo.new(0.2), { BackgroundTransparency = 0, TextTransparency = 0 })
				end
			end
		end)
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: Add "Customize Character" button to GENDER selection screen
-- This appears alongside Male/Female buttons at the initial screen
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
do
	local customizeGenderBtn = Instance.new("TextButton")
	customizeGenderBtn.Name = "CustomizeGenderBtn"
	customizeGenderBtn.Size = UDim2.new(0.85, 0, 0, 48)
	customizeGenderBtn.BackgroundColor3 = Color3.fromRGB(253, 230, 138) -- Gold
	customizeGenderBtn.Font = F.Title
	customizeGenderBtn.TextSize = 16
	customizeGenderBtn.TextColor3 = C.Gray900
	customizeGenderBtn.Text = "âš¡ Customize Character"
	customizeGenderBtn.AutoButtonColor = false
	customizeGenderBtn.LayoutOrder = 10 -- After gender buttons
	customizeGenderBtn.ZIndex = 72
	customizeGenderBtn.Parent = IntroUI.genderBtns
	pill(customizeGenderBtn)
	stroke(customizeGenderBtn, 2, 0, Color3.fromRGB(217, 119, 6))
	
	IntroUI.customizeGenderBtn = customizeGenderBtn
	
	customizeGenderBtn.MouseEnter:Connect(function()
		tween(customizeGenderBtn, TweenInfo.new(0.1), { Size = UDim2.new(0.88, 0, 0, 52) })
	end)
	customizeGenderBtn.MouseLeave:Connect(function()
		tween(customizeGenderBtn, TweenInfo.new(0.1), { Size = UDim2.new(0.85, 0, 0, 48) })
	end)
	
	customizeGenderBtn.MouseButton1Click:Connect(function()
		-- Check for God Mode ownership
		refreshGodModeStatus()
		if hasGodMode then
			showGodModeIntroCustomize()
		else
			-- Prompt to purchase
			if PromptGamepass then
				PromptGamepass:FireServer("GOD_MODE")
			end
		end
	end)
	
	-- Update button appearance based on God Mode status
	local function updateCustomizeGenderBtn()
		refreshGodModeStatus()
		if hasGodMode then
			-- CRITICAL FIX: Show unlocked gold color when gamepass owned
			customizeGenderBtn.Text = "âš¡ Customize Character"
			customizeGenderBtn.BackgroundColor3 = Color3.fromRGB(253, 230, 138)
			customizeGenderBtn.TextColor3 = C.Gray900
		else
			-- CRITICAL FIX: Show ðŸ”’ locked style (was ðŸ”“ which looks unlocked)
			customizeGenderBtn.Text = "ðŸ”’ Customize (God Mode)"
			customizeGenderBtn.BackgroundColor3 = C.Gray300
			customizeGenderBtn.TextColor3 = C.Gray600
		end
	end
	
	-- CRITICAL FIX: Store the update function globally so it can be called on gamepass purchase
	IntroUI.updateCustomizeGenderBtn = updateCustomizeGenderBtn
	
	-- Update on show
	task.defer(updateCustomizeGenderBtn)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX #103: Add "Born Royal" button to GENDER selection screen
-- This allows Royalty gamepass owners to be born as royalty WITHOUT needing God Mode
-- CRITICAL FIX: Split into multiple do-blocks to stay under 200 register limit
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Royal birth shared state (module level to avoid register issues)
IntroUI.RoyalBirthData = {
	gender = "Male",
	name = "",
	ethnicity = "Random",
	overlay = nil,
}

IntroUI.RoyalCountries = {
	{ id = "uk", name = "United Kingdom", emoji = "ðŸ‡¬ðŸ‡§" },
	{ id = "spain", name = "Spain", emoji = "ðŸ‡ªðŸ‡¸" },
	{ id = "sweden", name = "Sweden", emoji = "ðŸ‡¸ðŸ‡ª" },
	{ id = "japan", name = "Japan", emoji = "ðŸ‡¯ðŸ‡µ" },
	{ id = "monaco", name = "Monaco", emoji = "ðŸ‡²ðŸ‡¨" },
	{ id = "saudi", name = "Saudi Arabia", emoji = "ðŸ‡¸ðŸ‡¦" },
	{ id = "thailand", name = "Thailand", emoji = "ðŸ‡¹ðŸ‡­" },
	{ id = "morocco", name = "Morocco", emoji = "ðŸ‡²ðŸ‡¦" },
	{ id = "jordan", name = "Jordan", emoji = "ðŸ‡¯ðŸ‡´" },
	{ id = "belgium", name = "Belgium", emoji = "ðŸ‡§ðŸ‡ª" },
	{ id = "netherlands", name = "Netherlands", emoji = "ðŸ‡³ðŸ‡±" },
	{ id = "norway", name = "Norway", emoji = "ðŸ‡³ðŸ‡´" },
	{ id = "denmark", name = "Denmark", emoji = "ðŸ‡©ðŸ‡°" },
}

IntroUI.EthnicityOptions = {
	{ id = "Random", label = "ðŸŽ² Random" },
	{ id = "Caucasian", label = "ðŸ§‘â€ðŸ¦± Caucasian" },
	{ id = "African", label = "ðŸ‘¨ðŸ¿ African" },
	{ id = "Asian", label = "ðŸ§‘ðŸ» Asian" },
	{ id = "Hispanic", label = "ðŸ§‘ðŸ½ Hispanic" },
	{ id = "Middle Eastern", label = "ðŸ§”ðŸ½ Middle Eastern" },
	{ id = "Mixed", label = "ðŸŒˆ Mixed" },
}

-- Helper to check Royalty gamepass ownership (module level)
-- CRITICAL FIX #413: Use cached hasRoyalty for immediate response after purchase
local function checkRoyaltyGamepass()
	-- First check cached value (set immediately on purchase)
	if hasRoyalty then
		return true
	end
	-- Then verify with server (updates cache)
	if CheckGamepass then
		local success, owns = pcall(function()
			return CheckGamepass:InvokeServer("ROYALTY")
		end)
		if success and owns == true then
			hasRoyalty = true
			return true
		end
	end
	return false
end

-- Forward declare Royal UI functions at module level
IntroUI.showRoyalCountrySelection = nil
IntroUI.showRoyalGenderSelection = nil

-- Royal button setup block
do
	local royaltyBtn = Instance.new("TextButton")
	royaltyBtn.Name = "RoyaltyGenderBtn"
	royaltyBtn.Size = UDim2.new(0.85, 0, 0, 48)
	royaltyBtn.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
	royaltyBtn.Font = F.Title
	royaltyBtn.TextSize = 16
	royaltyBtn.TextColor3 = C.Gray900
	royaltyBtn.Text = "ðŸ‘‘ Born Royal"
	royaltyBtn.AutoButtonColor = false
	royaltyBtn.LayoutOrder = 9
	royaltyBtn.ZIndex = 72
	royaltyBtn.Parent = IntroUI.genderBtns
	pill(royaltyBtn)
	stroke(royaltyBtn, 2, 0, Color3.fromRGB(180, 140, 0))
	
	IntroUI.royaltyGenderBtn = royaltyBtn
	
	royaltyBtn.MouseEnter:Connect(function()
		tween(royaltyBtn, TweenInfo.new(0.1), { Size = UDim2.new(0.88, 0, 0, 52) })
	end)
	royaltyBtn.MouseLeave:Connect(function()
		tween(royaltyBtn, TweenInfo.new(0.1), { Size = UDim2.new(0.85, 0, 0, 48) })
	end)
	
	royaltyBtn.MouseButton1Click:Connect(function()
		if checkRoyaltyGamepass() then
			if IntroUI.showRoyalCountrySelection then
				IntroUI.showRoyalCountrySelection()
			end
		else
			-- CRITICAL FIX: Use FireServer not InvokeServer (PromptGamepass is RemoteEvent)
			if PromptGamepass then
				pcall(function() PromptGamepass:FireServer("ROYALTY") end)
			end
		end
	end)
	
	IntroUI.updateRoyaltyGenderBtn = function()
		local hasRoyal = checkRoyaltyGamepass()
		if hasRoyal then
			-- CRITICAL FIX: Show unlocked gold color when gamepass owned
			royaltyBtn.Text = "ðŸ‘‘ Born Royal"
			royaltyBtn.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
			royaltyBtn.TextColor3 = C.Gray900
			stroke(royaltyBtn, 2, 0, Color3.fromRGB(180, 140, 0))
		else
			-- CRITICAL FIX: Show ðŸ”’ locked style like God Mode button
			royaltyBtn.Text = "ðŸ”’ Born Royal"
			royaltyBtn.BackgroundColor3 = C.Gray300
			royaltyBtn.TextColor3 = C.Gray600
			stroke(royaltyBtn, 1, 0.5, C.Gray400)
		end
	end
	
	task.defer(IntroUI.updateRoyaltyGenderBtn)
end

-- Royal Country Selection function block
do
	IntroUI.showRoyalCountrySelection = function()
		if IntroUI.RoyalBirthData.overlay then return end
		
		-- Reset royal birth data
		IntroUI.RoyalBirthData.gender = "Male"
		IntroUI.RoyalBirthData.name = ""
		IntroUI.RoyalBirthData.ethnicity = "Random"
		
		-- Create overlay
		local overlay = Instance.new("Frame")
		overlay.Name = "RoyalCountryOverlay"
		overlay.Size = UDim2.fromScale(1, 1)
		overlay.BackgroundColor3 = C.Black
		overlay.BackgroundTransparency = 0.4
		overlay.ZIndex = 80
		overlay.Parent = screenGui
		IntroUI.RoyalBirthData.overlay = overlay
		
		-- Card with slide animation
		local card = Instance.new("Frame")
		card.Name = "Card"
		card.Size = UDim2.new(0.9, 0, 0, 0)
		card.AutomaticSize = Enum.AutomaticSize.Y
		card.AnchorPoint = Vector2.new(0.5, 0.5)
		card.Position = UDim2.fromScale(-0.5, 0.5) -- Start off-screen left
		card.BackgroundColor3 = C.White
		card.ZIndex = 81
		card.Parent = overlay
		
		-- Slide in animation
		tween(card, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
			Position = UDim2.fromScale(0.5, 0.5)
		})
		corner(card, 16)
		pad(card, 16, 16, 16, 16)
		
		local layout = Instance.new("UIListLayout")
		layout.Padding = UDim.new(0, 8)
		layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		layout.Parent = card
		
		-- Title
		local title = Instance.new("TextLabel")
		title.Size = UDim2.new(1, 0, 0, 40)
		title.BackgroundTransparency = 1
		title.Text = "ðŸ‘‘ Choose Your Kingdom"
		title.TextColor3 = C.Gray900
		title.TextSize = 20
		title.Font = F.Title
		title.ZIndex = 82
		title.Parent = card
		
		-- Subtitle
		local subtitle = Instance.new("TextLabel")
		subtitle.Size = UDim2.new(1, 0, 0, 28)
		subtitle.BackgroundTransparency = 1
		subtitle.Text = "Select a royal family to be born into"
		subtitle.TextColor3 = C.Gray500
		subtitle.TextSize = 14
		subtitle.Font = F.Body
		subtitle.ZIndex = 82
		subtitle.Parent = card
		
		-- Scroll frame for countries
		local scroll = Instance.new("ScrollingFrame")
		scroll.Size = UDim2.new(1, 0, 0, 280)
		scroll.BackgroundTransparency = 1
		scroll.ScrollBarThickness = 4
		scroll.ScrollBarImageColor3 = Color3.fromRGB(255, 215, 0)
		scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
		scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
		scroll.ZIndex = 82
		scroll.Parent = card
		
		local scrollLayout = Instance.new("UIListLayout")
		scrollLayout.Padding = UDim.new(0, 6)
		scrollLayout.Parent = scroll
		
		for _, country in ipairs(IntroUI.RoyalCountries) do
			local countryBtn = Instance.new("TextButton")
			countryBtn.Size = UDim2.new(1, 0, 0, 44)
			countryBtn.BackgroundColor3 = Color3.fromRGB(255, 248, 220)
			countryBtn.Text = country.emoji .. " " .. country.name
			countryBtn.TextColor3 = C.Gray800
			countryBtn.TextSize = 15
			countryBtn.Font = F.Medium
			countryBtn.ZIndex = 83
			countryBtn.Parent = scroll
			corner(countryBtn, 8)
			stroke(countryBtn, 1, 0.8, Color3.fromRGB(255, 215, 0))
			
			countryBtn.MouseEnter:Connect(function()
				tween(countryBtn, TweenInfo.new(0.1), { BackgroundColor3 = Color3.fromRGB(255, 215, 0) })
			end)
			countryBtn.MouseLeave:Connect(function()
				tween(countryBtn, TweenInfo.new(0.1), { BackgroundColor3 = Color3.fromRGB(255, 248, 220) })
			end)
			
			countryBtn.MouseButton1Click:Connect(function()
				-- Slide out animation then show customization
				tween(card, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
					Position = UDim2.fromScale(-0.5, 0.5)
				})
				task.delay(0.25, function()
					if IntroUI.RoyalBirthData.overlay then
						IntroUI.RoyalBirthData.overlay:Destroy()
						IntroUI.RoyalBirthData.overlay = nil
					end
					if IntroUI.showRoyalGenderSelection then
						IntroUI.showRoyalGenderSelection(country)
					end
				end)
			end)
		end
		
		-- Random button
		local randomBtn = Instance.new("TextButton")
		randomBtn.Size = UDim2.new(1, 0, 0, 44)
		randomBtn.BackgroundColor3 = Color3.fromRGB(168, 85, 247) -- Purple
		randomBtn.Text = "ðŸŽ² Random Kingdom"
		randomBtn.TextColor3 = C.White
		randomBtn.TextSize = 15
		randomBtn.Font = F.Title
		randomBtn.ZIndex = 82
		randomBtn.Parent = card
		corner(randomBtn, 8)
		
		randomBtn.MouseButton1Click:Connect(function()
			local randomCountry = IntroUI.RoyalCountries[math.random(1, #IntroUI.RoyalCountries)]
			
			-- Slide out animation then show customization
			tween(card, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
				Position = UDim2.fromScale(-0.5, 0.5)
			})
			task.delay(0.25, function()
				if IntroUI.RoyalBirthData.overlay then
					IntroUI.RoyalBirthData.overlay:Destroy()
					IntroUI.RoyalBirthData.overlay = nil
				end
				if IntroUI.showRoyalGenderSelection then
					IntroUI.showRoyalGenderSelection(randomCountry)
				end
			end)
		end)
		
		-- Cancel button
		local cancelBtn = Instance.new("TextButton")
		cancelBtn.Size = UDim2.new(0.5, 0, 0, 36)
		cancelBtn.BackgroundColor3 = C.Gray200
		cancelBtn.Text = "â† Back"
		cancelBtn.TextColor3 = C.Gray600
		cancelBtn.TextSize = 14
		cancelBtn.Font = F.Medium
		cancelBtn.ZIndex = 82
		cancelBtn.Parent = card
		corner(cancelBtn, 8)
		
		cancelBtn.MouseButton1Click:Connect(function()
			-- Slide out animation then close
			tween(card, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
				Position = UDim2.fromScale(-0.5, 0.5)
			})
			task.delay(0.2, function()
				if IntroUI.RoyalBirthData.overlay then
					IntroUI.RoyalBirthData.overlay:Destroy()
					IntroUI.RoyalBirthData.overlay = nil
				end
			end)
		end)
	end
end

-- Royal Gender/Customization Selection function block
do
	IntroUI.showRoyalGenderSelection = function(country)
		-- Create overlay for customization
		local customOverlay = Instance.new("Frame")
		customOverlay.Name = "RoyalCustomizeOverlay"
		customOverlay.Size = UDim2.fromScale(1, 1)
		customOverlay.BackgroundColor3 = C.Black
		customOverlay.BackgroundTransparency = 0.4
		customOverlay.ZIndex = 80
		customOverlay.Parent = screenGui
		
		-- Main scrollable card
		local card = Instance.new("Frame")
		card.Name = "Card"
		card.Size = UDim2.new(0.92, 0, 0.8, 0)
		card.AnchorPoint = Vector2.new(0.5, 0.5)
		card.Position = UDim2.fromScale(1.5, 0.5) -- Start off-screen for slide
		card.BackgroundColor3 = C.White
		card.ZIndex = 81
		card.Parent = customOverlay
		corner(card, 16)
		
		-- Slide in animation
		tween(card, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
			Position = UDim2.fromScale(0.5, 0.5)
		})
		
		-- Scroll frame
		local scroll = Instance.new("ScrollingFrame")
		scroll.Size = UDim2.new(1, 0, 1, 0)
		scroll.BackgroundTransparency = 1
		scroll.ScrollBarThickness = 4
		scroll.ScrollBarImageColor3 = Color3.fromRGB(255, 215, 0)
		scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
		scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
		scroll.ZIndex = 82
		scroll.Parent = card
		
		local scrollPad = Instance.new("UIPadding")
		scrollPad.PaddingLeft = UDim.new(0, 16)
		scrollPad.PaddingRight = UDim.new(0, 16)
		scrollPad.PaddingTop = UDim.new(0, 16)
		scrollPad.PaddingBottom = UDim.new(0, 16)
		scrollPad.Parent = scroll
		
		local layout = Instance.new("UIListLayout")
		layout.Padding = UDim.new(0, 12)
		layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		layout.Parent = scroll
		
		-- Header
		local header = Instance.new("TextLabel")
		header.Size = UDim2.new(1, 0, 0, 44)
		header.BackgroundTransparency = 1
		header.Text = country.emoji .. " Royal Birth: " .. country.name
		header.TextColor3 = Color3.fromRGB(180, 140, 0)
		header.TextSize = 18
		header.Font = F.Title
		header.ZIndex = 83
		header.Parent = scroll
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- GENDER SELECTION
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		local genderSec = Instance.new("Frame")
		genderSec.Size = UDim2.new(1, 0, 0, 0)
		genderSec.AutomaticSize = Enum.AutomaticSize.Y
		genderSec.BackgroundColor3 = Color3.fromRGB(255, 248, 220)
		genderSec.ZIndex = 82
		genderSec.Parent = scroll
		corner(genderSec, 12)
		pad(genderSec, 12, 12, 12, 12)
		
		local genderLayout = Instance.new("UIListLayout")
		genderLayout.Padding = UDim.new(0, 8)
		genderLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		genderLayout.Parent = genderSec
		
		local genderTitle = Instance.new("TextLabel")
		genderTitle.Size = UDim2.new(1, 0, 0, 24)
		genderTitle.BackgroundTransparency = 1
		genderTitle.Text = "ðŸ‘‘ Choose Your Royal Title"
		genderTitle.TextColor3 = C.Gray800
		genderTitle.TextSize = 15
		genderTitle.Font = F.Title
		genderTitle.ZIndex = 83
		genderTitle.Parent = genderSec
		
		local genderBtnFrame = Instance.new("Frame")
		genderBtnFrame.Size = UDim2.new(1, 0, 0, 48)
		genderBtnFrame.BackgroundTransparency = 1
		genderBtnFrame.ZIndex = 83
		genderBtnFrame.Parent = genderSec
		
		local genderBtnLayout = Instance.new("UIListLayout")
		genderBtnLayout.FillDirection = Enum.FillDirection.Horizontal
		genderBtnLayout.Padding = UDim.new(0, 10)
		genderBtnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		genderBtnLayout.Parent = genderBtnFrame
		
		IntroUI.RoyalBirthData.gender = "Male"
		
		local princeBtn = Instance.new("TextButton")
		princeBtn.Size = UDim2.new(0, 120, 0, 48)
		princeBtn.BackgroundColor3 = C.Male
		princeBtn.Text = "ðŸ‘‘ Prince"
		princeBtn.TextColor3 = C.White
		princeBtn.TextSize = 15
		princeBtn.Font = F.Title
		princeBtn.ZIndex = 84
		princeBtn.Parent = genderBtnFrame
		corner(princeBtn, 10)
		stroke(princeBtn, 2, 0, Color3.fromRGB(30, 100, 180))
		
		local princessBtn = Instance.new("TextButton")
		princessBtn.Size = UDim2.new(0, 120, 0, 48)
		princessBtn.BackgroundColor3 = C.Gray200
		princessBtn.Text = "ðŸ‘¸ Princess"
		princessBtn.TextColor3 = C.Gray600
		princessBtn.TextSize = 15
		princessBtn.Font = F.Title
		princessBtn.ZIndex = 84
		princessBtn.Parent = genderBtnFrame
		corner(princessBtn, 10)
		
		princeBtn.MouseButton1Click:Connect(function()
			IntroUI.RoyalBirthData.gender = "Male"
			princeBtn.BackgroundColor3 = C.Male
			princeBtn.TextColor3 = C.White
			stroke(princeBtn, 2, 0, Color3.fromRGB(30, 100, 180))
			princessBtn.BackgroundColor3 = C.Gray200
			princessBtn.TextColor3 = C.Gray600
			local s = princessBtn:FindFirstChildOfClass("UIStroke")
			if s then s:Destroy() end
		end)
		
		princessBtn.MouseButton1Click:Connect(function()
			IntroUI.RoyalBirthData.gender = "Female"
			princessBtn.BackgroundColor3 = C.Female
			princessBtn.TextColor3 = C.White
			stroke(princessBtn, 2, 0, Color3.fromRGB(180, 50, 120))
			princeBtn.BackgroundColor3 = C.Gray200
			princeBtn.TextColor3 = C.Gray600
			local s = princeBtn:FindFirstChildOfClass("UIStroke")
			if s then s:Destroy() end
		end)
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- NAME INPUT
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		local nameSec = Instance.new("Frame")
		nameSec.Size = UDim2.new(1, 0, 0, 0)
		nameSec.AutomaticSize = Enum.AutomaticSize.Y
		nameSec.BackgroundColor3 = C.White
		nameSec.ZIndex = 82
		nameSec.Parent = scroll
		corner(nameSec, 12)
		stroke(nameSec, 1, 0.5, C.Gray200)
		pad(nameSec, 12, 12, 12, 12)
		
		local nameLayout = Instance.new("UIListLayout")
		nameLayout.Padding = UDim.new(0, 6)
		nameLayout.Parent = nameSec
		
		local nameTitle = Instance.new("TextLabel")
		nameTitle.Size = UDim2.new(1, 0, 0, 22)
		nameTitle.BackgroundTransparency = 1
		nameTitle.Text = "ðŸ‘¤ Royal Name (Optional)"
		nameTitle.TextColor3 = C.Gray800
		nameTitle.TextSize = 14
		nameTitle.Font = F.Title
		nameTitle.TextXAlignment = Enum.TextXAlignment.Left
		nameTitle.ZIndex = 83
		nameTitle.Parent = nameSec
		
		local nameInput = Instance.new("TextBox")
		nameInput.Size = UDim2.new(1, 0, 0, 40)
		nameInput.BackgroundColor3 = C.Gray100
		nameInput.Text = ""
		nameInput.PlaceholderText = "Leave blank for random royal name..."
		nameInput.TextColor3 = C.Gray900
		nameInput.PlaceholderColor3 = C.Gray400
		nameInput.TextSize = 14
		nameInput.Font = F.Medium
		nameInput.ClearTextOnFocus = false
		nameInput.ZIndex = 83
		nameInput.Parent = nameSec
		corner(nameInput, 8)
		
		nameInput:GetPropertyChangedSignal("Text"):Connect(function()
			IntroUI.RoyalBirthData.name = nameInput.Text
		end)
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- ETHNICITY SELECTION
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		local ethSec = Instance.new("Frame")
		ethSec.Size = UDim2.new(1, 0, 0, 0)
		ethSec.AutomaticSize = Enum.AutomaticSize.Y
		ethSec.BackgroundColor3 = C.White
		ethSec.ZIndex = 82
		ethSec.Parent = scroll
		corner(ethSec, 12)
		stroke(ethSec, 1, 0.5, C.Gray200)
		pad(ethSec, 12, 12, 12, 12)
		
		local ethLayout = Instance.new("UIListLayout")
		ethLayout.Padding = UDim.new(0, 6)
		ethLayout.Parent = ethSec
		
		local ethTitle = Instance.new("TextLabel")
		ethTitle.Size = UDim2.new(1, 0, 0, 22)
		ethTitle.BackgroundTransparency = 1
		ethTitle.Text = "ðŸŒ Ethnicity"
		ethTitle.TextColor3 = C.Gray800
		ethTitle.TextSize = 14
		ethTitle.Font = F.Title
		ethTitle.TextXAlignment = Enum.TextXAlignment.Left
		ethTitle.ZIndex = 83
		ethTitle.Parent = ethSec
		
		local ethGrid = Instance.new("Frame")
		ethGrid.Size = UDim2.new(1, 0, 0, 0)
		ethGrid.AutomaticSize = Enum.AutomaticSize.Y
		ethGrid.BackgroundTransparency = 1
		ethGrid.ZIndex = 83
		ethGrid.Parent = ethSec
		
		local ethGridLayout = Instance.new("UIGridLayout")
		ethGridLayout.CellSize = UDim2.new(0, 90, 0, 32)
		ethGridLayout.CellPadding = UDim2.new(0, 6, 0, 6)
		ethGridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		ethGridLayout.Parent = ethGrid
		
		local ethBtns = {}
		for _, eth in ipairs(IntroUI.EthnicityOptions) do
			local btn = Instance.new("TextButton")
			btn.Name = eth.id
			btn.Size = UDim2.new(0, 90, 0, 32)
			btn.BackgroundColor3 = eth.id == "Random" and C.Purple or C.Gray200
			btn.Text = eth.label
			btn.TextColor3 = eth.id == "Random" and C.White or C.Gray600
			btn.TextSize = 10
			btn.Font = F.Medium
			btn.TextTruncate = Enum.TextTruncate.AtEnd
			btn.ZIndex = 84
			btn.Parent = ethGrid
			corner(btn, 6)
			ethBtns[eth.id] = btn
			
			btn.MouseButton1Click:Connect(function()
				IntroUI.RoyalBirthData.ethnicity = eth.id
				for id, b in pairs(ethBtns) do
					b.BackgroundColor3 = id == eth.id and C.Purple or C.Gray200
					b.TextColor3 = id == eth.id and C.White or C.Gray600
				end
			end)
		end
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- ACTION BUTTONS
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		local btnFrame = Instance.new("Frame")
		btnFrame.Size = UDim2.new(1, 0, 0, 52)
		btnFrame.BackgroundTransparency = 1
		btnFrame.ZIndex = 82
		btnFrame.Parent = scroll
		
		local btnLayout = Instance.new("UIListLayout")
		btnLayout.FillDirection = Enum.FillDirection.Horizontal
		btnLayout.Padding = UDim.new(0, 10)
		btnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		btnLayout.Parent = btnFrame
		
		local backBtn = Instance.new("TextButton")
		backBtn.Size = UDim2.new(0, 90, 0, 46)
		backBtn.BackgroundColor3 = C.Gray200
		backBtn.Text = "â† Back"
		backBtn.TextColor3 = C.Gray600
		backBtn.TextSize = 14
		backBtn.Font = F.Medium
		backBtn.ZIndex = 83
		backBtn.Parent = btnFrame
		corner(backBtn, 10)
		
		local startBtn = Instance.new("TextButton")
		startBtn.Size = UDim2.new(0, 160, 0, 46)
		startBtn.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
		startBtn.Text = "ðŸ‘‘ Begin Royal Life"
		startBtn.TextColor3 = C.Gray900
		startBtn.TextSize = 15
		startBtn.Font = F.Title
		startBtn.ZIndex = 83
		startBtn.Parent = btnFrame
		corner(startBtn, 10)
		stroke(startBtn, 2, 0, Color3.fromRGB(180, 140, 0))
		
		-- Back button - slide back to kingdom selection
		backBtn.MouseButton1Click:Connect(function()
			tween(card, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
				Position = UDim2.fromScale(1.5, 0.5)
			})
			task.delay(0.25, function()
				customOverlay:Destroy()
				IntroUI.showRoyalCountrySelection()
			end)
		end)
		
		-- Start Royal Life
		startBtn.MouseButton1Click:Connect(function()
			-- Get final name
			local finalName = IntroUI.RoyalBirthData.name:gsub("^%s+", ""):gsub("%s+$", "")
			if finalName == "" then
				local maleNames = {"William", "Charles", "Henry", "Edward", "George", "Philip", "James", "Alexander"}
				local femaleNames = {"Elizabeth", "Victoria", "Charlotte", "Catherine", "Diana", "Margaret", "Anne", "Alexandra"}
				local names = IntroUI.RoyalBirthData.gender == "Male" and maleNames or femaleNames
				finalName = names[math.random(1, #names)]
			end
			
			-- Animate out
			tween(card, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
				Position = UDim2.fromScale(0.5, 1.5)
			})
			
			task.delay(0.2, function()
				customOverlay:Destroy()
				
				-- CRITICAL FIX: Set selectedGender
				selectedGender = IntroUI.RoyalBirthData.gender
				
				-- CRITICAL FIX: Set currentState properly
				currentState.Gender = IntroUI.RoyalBirthData.gender
				currentState.Name = finalName
				currentState.Flags = currentState.Flags or {}
				currentState.Flags.is_royalty = true
				currentState.Flags.royal_birth = true
				currentState.Flags.royal_country = country.id
				currentState.Flags.royal_country_name = country.name
				
				-- CRITICAL FIX: Send proper format to server
				if SetLifeInfo then
					pcall(function()
						SetLifeInfo:FireServer(finalName, IntroUI.RoyalBirthData.gender)
					end)
				end
				
				-- Send detailed royal info if GodModeEdit available
				if GodModeEdit then
					pcall(function()
						GodModeEdit:InvokeServer({
							name = finalName,
							gender = IntroUI.RoyalBirthData.gender,
							isRoyalBirth = true,
							royalCountry = country.id,
							royalCountryName = country.name,
							ethnicity = IntroUI.RoyalBirthData.ethnicity,
							familyWealth = "Royal",
						})
					end)
				end
				
				-- CRITICAL FIX: Complete intro properly
				introComplete = true
				hideIntro()
				
				task.defer(function()
					if updateFromState then updateFromState() end
				end)
			end)
		end)
	end
end

showIntro = function()
	if introComplete then return end

	-- Generate fresh random names each time intro is shown
	generateRandomNames()

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Reset ALL intro UI states for clean new life experience
	-- This ensures God Mode customization UI is hidden when starting fresh
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	IntroUI.overlay.Visible = true
	IntroUI.overlay.BackgroundTransparency = 0.5
	IntroUI.content.Position = UDim2.fromScale(0.5, 0.5)
	
	-- CRITICAL FIX: Reset God Mode container and all customization state
	if IntroUI.godModeContainer then
		IntroUI.godModeContainer.Visible = false
	end
	
	-- CRITICAL FIX: Restore content to auto-size mode
	IntroUI.content.AutomaticSize = Enum.AutomaticSize.Y
	IntroUI.content.Size = UDim2.new(0.9, 0, 0, 0)
	
	-- Reset God Mode data for new life
	if GodModeCreateData then
		GodModeCreateData.customName = ""
		GodModeCreateData.gender = "Male"
		GodModeCreateData.ethnicity = "Random"
		GodModeCreateData.familyWealth = "Middle Class"
		GodModeCreateData.country = "United States"
		-- CRITICAL FIX: Reset stats to defaults
		GodModeCreateData.stats = { Happiness = 50, Health = 100, Smarts = 50, Looks = 50 }
		-- CRITICAL FIX #28: Reset royal birth flags
		GodModeCreateData.isRoyalBirth = false
		GodModeCreateData.royalCountry = nil
	end
	
	-- CRITICAL FIX: Reset God Mode UI elements to default states
	if IntroUI.customNameInput then
		IntroUI.customNameInput.Text = ""
	end
	if IntroUI.countryDropdown then
		IntroUI.countryDropdown.Text = "ðŸ‡ºðŸ‡¸ United States"
	end

	showBlur()
	IntroUI.genderTitle.Text = "Start by picking a gender"
	IntroUI.genderBtns.Visible = true
	IntroUI.nameBtns.Visible = false

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #643-645: Reset gender button transparency after death/new life
	-- The buttons may have been faded out in a previous animation and need to be
	-- fully visible again for the new life selection screen
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	for _, child in ipairs(IntroUI.genderBtns:GetChildren()) do
		if child:IsA("TextButton") then
			child.BackgroundTransparency = 0
			child.TextTransparency = 0
			child.Visible = true
			-- CRITICAL FIX #644: Reset button size in case it was mid-animation
			if child.Name ~= "CustomizeGenderBtn" and child.Name ~= "RoyaltyGenderBtn" then
				child.Size = UDim2.new(0.85, 0, 0, 58)
			end
		end
	end
	
	-- CRITICAL FIX #645: Also reset name buttons in case they were in a bad state
	for _, child in ipairs(IntroUI.nameBtns:GetChildren()) do
		if child:IsA("TextButton") then
			child.BackgroundTransparency = 0
			child.TextTransparency = 0
			child.Visible = true
			child.Size = UDim2.new(0.85, 0, 0, 54)
		end
	end

	-- CRITICAL FIX #104: Update Royalty button appearance on intro show
	if IntroUI.updateRoyaltyGenderBtn then
		IntroUI.updateRoyaltyGenderBtn()
	end
	
	-- CRITICAL FIX #432: Update God Mode button appearance on intro show
	-- This was MISSING - causing God Mode button to stay grey even after purchase!
	if IntroUI.updateCustomizeGenderBtn then
		IntroUI.updateCustomizeGenderBtn()
	end

	-- Fade in animation
	IntroUI.content.Position = UDim2.new(0.5, 0, 0.55, 0)
	tween(IntroUI.content, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Position = UDim2.fromScale(0.5, 0.5)
	})
end

hideIntro = function()
	-- CRITICAL FIX: Restore content to auto-size mode before hiding
	IntroUI.content.AutomaticSize = Enum.AutomaticSize.Y
	IntroUI.content.Size = UDim2.new(0.9, 0, 0, 0)
	IntroUI.godModeContainer.Visible = false
	
	-- Smooth fade out animation
	local fadeTime = 0.25

	tween(IntroUI.content, TweenInfo.new(fadeTime, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
		Position = UDim2.new(0.5, 0, 0.45, 0)
	})
	tween(IntroUI.overlay, TweenInfo.new(fadeTime), {
		BackgroundTransparency = 1
	})

	hideBlur()

	task.delay(fadeTime, function()
		IntroUI.overlay.Visible = false
		if not hasShownAgeHint then
			task.delay(0.3, showTutorial)
		end
	end)
end

----------------------------------------------------------------
-- UPDATE UI FROM STATE
----------------------------------------------------------------

function updateFromState()
	if not currentState then return end

	nameLabel.Text = currentState.Name or "New Life"
	ageYearLabel.Text = string.format(
		"Age %d â€¢ %d",
		currentState.Age or 0,
		getCurrentYear(currentState.Age)
	)
	moneyLabel.Text = formatMoney(currentState.Money or 0)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Gender AND Ethnicity-aware avatar emoji selection
	-- Uses skin tone modifiers based on player's ethnicity from God Mode
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local gender = currentState.Gender or selectedGender or "Male"
	local isFemale = (gender:lower() == "female")
	
	-- Get ethnicity from player flags for skin-tone modifiers
	local ethnicity = ""
	if currentState.Flags and currentState.Flags.ethnicity then
		ethnicity = currentState.Flags.ethnicity
	end
	
	-- Skin tone modifiers based on ethnicity
	-- CRITICAL FIX: Proper skin tone assignments
	local skinTone = "" -- Default (yellow/no modifier)
	if ethnicity == "Caucasian" then
		skinTone = "ðŸ¼" -- Medium-light skin (NOT yellow)
	elseif ethnicity == "African" then
		skinTone = "ðŸ¿" -- Dark skin
	elseif ethnicity == "Hispanic" then
		skinTone = "ðŸ½" -- Medium skin
	elseif ethnicity == "Middle Eastern" then
		skinTone = "ðŸ½" -- Medium skin
	elseif ethnicity == "Asian" then
		skinTone = "ðŸ»" -- Light skin (East Asian)
	elseif ethnicity == "Indian" then
		skinTone = "ðŸ¾" -- Medium-dark skin (South Asian)
	elseif ethnicity == "Pacific Islander" then
		skinTone = "ðŸ½" -- Medium skin
	elseif ethnicity == "Indigenous" then
		skinTone = "ðŸ½" -- Medium skin
	elseif ethnicity == "Mixed" then
		skinTone = "ðŸ¼" -- Medium-light skin
	end
	-- Random = no modifier (yellow default)
	
	-- CRITICAL FIX: Avatar emoji based on age, gender, AND ethnicity
	local age = currentState.Age or 0
	if age < 2 then
		-- Baby
		avatarEmoji.Text = isFemale and "ðŸ‘¶" .. skinTone .. "ðŸŽ€" or "ðŸ‘¶" .. skinTone
	elseif age < 5 then
		-- Toddler
		avatarEmoji.Text = isFemale and "ðŸ‘§" .. skinTone or "ðŸ‘¦" .. skinTone
	elseif age < 13 then
		-- Child
		avatarEmoji.Text = isFemale and "ðŸ‘§" .. skinTone or "ðŸ‘¦" .. skinTone
	elseif age < 20 then
		-- Teen
		avatarEmoji.Text = isFemale and "ðŸ‘©" .. skinTone or "ðŸ‘¨" .. skinTone
	elseif age < 40 then
		-- Young Adult
		avatarEmoji.Text = isFemale and "ðŸ‘©" .. skinTone or "ðŸ‘¨" .. skinTone
	elseif age < 60 then
		-- Middle Aged Adult
		avatarEmoji.Text = isFemale and "ðŸ‘©" .. skinTone or "ðŸ‘¨" .. skinTone
	elseif age < 75 then
		-- Senior
		avatarEmoji.Text = isFemale and "ðŸ‘µ" .. skinTone or "ðŸ‘´" .. skinTone
	else
		-- Elderly
		avatarEmoji.Text = isFemale and "ðŸ‘µ" .. skinTone or "ðŸ‘´" .. skinTone
	end

	for key, card in pairs(statCards) do
		local val = currentState[key] or (currentState.Stats and currentState.Stats[key]) or 50
		card.percentLabel.Text = val .. "%"
		tween(card.barFill, TweenInfo.new(0.3), {
			Size = UDim2.new(math.clamp(val/100, 0, 1), 0, 1, 0),
		})
	end

	refreshGodModeStatus()
	updateGodModeButtonAppearance()
end

----------------------------------------------------------------
-- REMOTE HANDLERS
----------------------------------------------------------------

-- Track previous state for change detection
local previousState = {}
local firstSync = true

SyncState.OnClientEvent:Connect(function(state, lastFeedText, resultData)
	if not state then return end

	-- Only log significant state changes, not every sync (reduces spam)
	local ageChanged = currentState and currentState.Age ~= state.Age
	local moneyChanged = currentState and currentState.Money ~= state.Money

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- STEP 1: DETECT IF THIS IS A NEW LIFE (BEFORE updating currentState)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local isNewLife = false

	-- Method 1: Explicit "new life" message from server (resetPlayerLife sends this)
	if lastFeedText == "A new life begins..." then
		isNewLife = true
	end

	-- Method 2: Old state had a name, new state doesn't -> this is a restart
	if not isNewLife and currentState and currentState.Name and (not state.Name or state.Name == "") then
		isNewLife = true
	end

	-- Method 3: First sync with no name = new life
	if firstSync then
		firstSync = false
		if not state.Name or state.Name == "" then
			isNewLife = true
		end
	end

	-- Method 4: Age is 0 and no name = definitely new life
	if (state.Age == 0 or state.Age == nil) and (not state.Name or state.Name == "") then
		isNewLife = true
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- STEP 2: HANDLE NEW LIFE RESET
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	if isNewLife then

		-- Reset all intro/game flags
		introComplete = false
		selectedGender = nil
		awaitingEvent = false
		hasShownAgeHint = false

		-- Clear pending minigame state
		pendingMinigameEventId = nil
		pendingMinigameChoiceIndex = nil

		-- Clear feed entries
		feedEntryCount = 0
		for _, child in ipairs(feedScroll:GetChildren()) do
			if child:IsA("Frame") then
				child:Destroy()
			end
		end

		-- Reset previous state tracking
		previousState = {}

		-- Update currentState with new state (include all fields from server)
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX #20: Explicitly set CurrentJob to nil for new life
		-- This ensures no stale job data from previous life is carried over
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		currentState = {
			Name = nil,
			Age = state.Age or 0,
			Money = state.Money or 0,
			Happiness = state.Happiness or 50,
			Health = state.Health or 100,
			Smarts = state.Smarts or 50,
			Looks = state.Looks or 50,
			Gender = nil,
			-- CRITICAL: Include Assets and other fields from server state
			Assets = state.Assets or { Properties = {}, Vehicles = {}, Items = {} },
			Relationships = state.Relationships or {},
			Flags = state.Flags or {},
			-- CRITICAL FIX: Explicitly set job to nil for new life (prevents stale job showing)
			CurrentJob = nil,
			CareerInfo = nil,
			Career = nil,
			Education = state.Education or "none",
			EducationData = state.EducationData,
			-- CRITICAL: Include MobState for Mafia screen
			MobState = state.MobState or { inMob = false },
			-- CRITICAL FIX #429: Include GamepassOwnership
			GamepassOwnership = state.GamepassOwnership or {},
			-- CRITICAL: Prison state should be reset for new life
			InJail = false,
			JailYearsLeft = 0,
		}
		
		-- CRITICAL FIX #430: Initialize gamepass caches from server state
		-- This ensures gamepasses are recognized even on new life
		if state.GamepassOwnership then
			if state.GamepassOwnership.godMode then hasGodMode = true end
			if state.GamepassOwnership.royalty then hasRoyalty = true end
			if state.GamepassOwnership.mafia then hasMafia = true end
			if state.GamepassOwnership.celebrity then hasCelebrity = true end
			if state.GamepassOwnership.timeMachine then hasTimeMachine = true end
		end
		-- Also check Flags as fallback
		if state.Flags then
			if state.Flags.god_mode_gamepass then hasGodMode = true end
			if state.Flags.royalty_gamepass then hasRoyalty = true end
			if state.Flags.mafia_gamepass then hasMafia = true end
			if state.Flags.celebrity_gamepass then hasCelebrity = true end
			if state.Flags.time_machine_gamepass then hasTimeMachine = true end
		end

		-- Reset header UI
		nameLabel.Text = "New Life"
		ageYearLabel.Text = string.format("Age %d â€¢ %d", state.Age or 0, getCurrentYear(state.Age))
		moneyLabel.Text = formatMoney(state.Money or 0)
		avatarEmoji.Text = "ðŸ‘¶"

		-- Reset stats UI
		for key, card in pairs(statCards) do
			local val = state[key] or (state.Stats and state.Stats[key]) or 50
			card.percentLabel.Text = val .. "%"
			card.barFill.Size = UDim2.new(math.clamp(val/100, 0, 1), 0, 1, 0)
		end

		-- Hide any lingering modals
		if hideResultPopup then 
			pcall(hideResultPopup) 
		end
		if hideEvent then 
			pcall(hideEvent) 
		end
		hideTutorial()
		hideDeathOverlay()

		-- Update all screen instances with the new state (even during reset)
		-- This ensures screens have proper initial state
		if ScreenInstances.occupation and ScreenInstances.occupation.updateState then
			ScreenInstances.occupation:updateState(currentState)
		end
		if ScreenInstances.assets and ScreenInstances.assets.updateState then
			ScreenInstances.assets:updateState(currentState)
		end
		if ScreenInstances.relationships and ScreenInstances.relationships.updateState then
			ScreenInstances.relationships:updateState(currentState)
		end
		if ScreenInstances.activities and ScreenInstances.activities.updateState then
			ScreenInstances.activities:updateState(currentState)
		end
		if ScreenInstances.mafia and ScreenInstances.mafia.updateState then
			ScreenInstances.mafia:updateState(currentState)
		end
		-- CRITICAL FIX: Update storypaths screen state
		if ScreenInstances.storypaths and ScreenInstances.storypaths.updateState then
			ScreenInstances.storypaths:updateState(currentState)
		end

		-- SHOW INTRO MODAL
		showIntro()
		
		-- CRITICAL FIX #434: Update gamepass buttons after new life starts
		-- The gamepass caches were just updated from server state, so update UI
		task.defer(function()
			if IntroUI and IntroUI.updateCustomizeGenderBtn then
				IntroUI.updateCustomizeGenderBtn()
			end
			if IntroUI and IntroUI.updateRoyaltyGenderBtn then
				IntroUI.updateRoyaltyGenderBtn()
			end
		end)

		-- Early return - don't process as normal sync
		return
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- STEP 3: NORMAL (NON-RESET) SYNC HANDLING
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	-- Calculate deltas for result popup
	local deltas = {}
	if previousState.Happiness and state.Happiness then
		deltas.happiness = state.Happiness - previousState.Happiness
	end
	if previousState.Health and state.Health then
		deltas.health = state.Health - previousState.Health
	end
	if previousState.Smarts and state.Smarts then
		deltas.smarts = state.Smarts - previousState.Smarts
	end
	if previousState.Looks and state.Looks then
		deltas.looks = state.Looks - previousState.Looks
	end
	if previousState.Money and state.Money then
		deltas.money = state.Money - previousState.Money
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #18: Proper state update that handles nil values
	-- The issue was: pairs() doesn't iterate over nil values, so CurrentJob = nil
	-- from server wouldn't clear the client's cached CurrentJob, causing stale job display!
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	-- Update values from server state
	for k, v in pairs(state) do
		currentState[k] = v
		previousState[k] = v
	end
	if state.Stats then
		for k, v in pairs(state.Stats) do
			currentState[k] = v
			previousState[k] = v
		end
	end

	-- Also copy Age directly if it's in the state
	if state.Age then
		currentState.Age = state.Age
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #19: Explicitly handle fields that CAN be nil but need to be cleared
	-- This is essential for fields like CurrentJob that disappear when unemployed
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	-- Job state - MUST explicitly clear if server doesn't send it
	-- (since pairs() won't iterate over nil keys)
	if state.CurrentJob == nil then
		currentState.CurrentJob = nil
		previousState.CurrentJob = nil
	end
	
	-- Also check if CurrentJob was explicitly sent as empty/invalid
	if currentState.CurrentJob and type(currentState.CurrentJob) == "table" then
		-- Validate the job has required fields, otherwise clear it
		if not currentState.CurrentJob.id and not currentState.CurrentJob.title and not currentState.CurrentJob.name then
			currentState.CurrentJob = nil
			previousState.CurrentJob = nil
		end
	end
	
	-- Career track can also be nil
	if state.Career then
		currentState.Career = state.Career
		previousState.Career = state.Career
	end
	
	-- CareerInfo should be updated properly
	if state.CareerInfo then
		currentState.CareerInfo = state.CareerInfo
		previousState.CareerInfo = state.CareerInfo
	end
	
	-- Education status
	if state.Education then
		currentState.Education = state.Education
	end
	if state.EducationData then
		currentState.EducationData = state.EducationData
	end
	
	-- Prison status
	currentState.InJail = state.InJail or false
	currentState.JailYearsLeft = state.JailYearsLeft or 0
	
	-- CRITICAL FIX #431: Update gamepass caches from server state on every sync
	-- ONLY upgrade to true, never downgrade (server might have stale data)
	if state.GamepassOwnership then
		if state.GamepassOwnership.godMode then hasGodMode = true end
		if state.GamepassOwnership.royalty then hasRoyalty = true end
		if state.GamepassOwnership.mafia then hasMafia = true end
		if state.GamepassOwnership.celebrity then hasCelebrity = true end
		if state.GamepassOwnership.timeMachine then hasTimeMachine = true end
	end
	if state.Flags then
		if state.Flags.god_mode_gamepass then hasGodMode = true end
		if state.Flags.royalty_gamepass then hasRoyalty = true end
		if state.Flags.mafia_gamepass then hasMafia = true end
		if state.Flags.celebrity_gamepass then hasCelebrity = true end
		if state.Flags.time_machine_gamepass then hasTimeMachine = true end
	end

	-- Update all screen instances with latest state
	if ScreenInstances.occupation and ScreenInstances.occupation.updateState then
		ScreenInstances.occupation:updateState(currentState)
	end
	if ScreenInstances.assets and ScreenInstances.assets.updateState then
		ScreenInstances.assets:updateState(currentState)
	end
	if ScreenInstances.relationships and ScreenInstances.relationships.updateState then
		ScreenInstances.relationships:updateState(currentState)
	end
	if ScreenInstances.activities and ScreenInstances.activities.updateState then
		ScreenInstances.activities:updateState(currentState)
	end
	if ScreenInstances.mafia and ScreenInstances.mafia.updateState then
		ScreenInstances.mafia:updateState(currentState)
	end
	-- CRITICAL FIX #435: Ensure storypaths gets proper updateState call
	if ScreenInstances.storypaths then
		if ScreenInstances.storypaths.updateState then
			ScreenInstances.storypaths:updateState(currentState)
		elseif ScreenInstances.storypaths.visible then
			ScreenInstances.storypaths:updateUI()
		end
	end

	-- CRITICAL FIX: Check for death FIRST before showing any popups
	-- This prevents the DOUBLE DEATH SCREEN bug where both result popup and death overlay show
	local isDead = (resultData and resultData.fatal) or (currentState.Health and currentState.Health <= 0)
	
	-- Show result popup if we have result data from server (but NOT if player is dead!)
	if resultData and resultData.showPopup and not isDead then
		showResultPopup({
			emoji = resultData.emoji or "ðŸ“‹",
			title = resultData.title or "Result",
			body = resultData.body or lastFeedText or "Life continues...",
			happiness = resultData.happiness or deltas.happiness,
			health = resultData.health or deltas.health,
			smarts = resultData.smarts or deltas.smarts,
			looks = resultData.looks or deltas.looks,
			money = resultData.money or deltas.money,
			wasSuccess = resultData.wasSuccess, -- IMPORTANT: Pass through success flag for minigames
		})
	elseif deltas.health and deltas.health < -15 and not isDead then
		-- Auto-shake for MAJOR negative health (15+ drop)
		shakeScreen(10, 0.35)
		flashScreen(C.Red, 0.5, 0.35)
	elseif deltas.health and deltas.health < -5 then
		-- Smaller health drop - just flash, no shake
		flashScreen(C.Red, 0.7, 0.25)
	-- CRITICAL FIX: Only flash green for UNEXPECTED money gains (windfalls, lottery, etc.)
	-- Regular salary shouldn't cause a flash - it's expected and boring
	-- Threshold raised to $100,000 to make flashes feel special and rare
	elseif deltas.money and deltas.money > 100000 then
		-- Flash green for massive money windfall (lottery, inheritance, etc.)
		flashScreen(C.Green, 0.7, 0.3)
	-- CRITICAL FIX: Only flash red for big LOSSES, not normal expenses
	elseif deltas.money and deltas.money < -50000 then
		-- Flash red for major money losses (lawsuit, major purchase shouldn't flash)
		flashScreen(C.Red, 0.7, 0.25)
	end

	-- Check for death (from result data or health hitting 0)
	if resultData and resultData.fatal then
		local causeText = resultData.cause or resultData.body or lastFeedText or "You passed away."
		showDeathOverlay(causeText, state.Age)
	elseif currentState.Health and currentState.Health <= 0 then
		showDeathOverlay("Health depleted.", state.Age)
	else
		hideDeathOverlay()
	end

	-- Update UI from state
	updateFromState()

	-- Add feed entry
	if lastFeedText and lastFeedText ~= "" and not (resultData and resultData.showPopup) then
		addFeedEntry(lastFeedText)
	end

	-- Check if intro should be shown (shouldn't normally happen here, but safety check)
	if not introComplete and (not currentState.Name or currentState.Name == "") then
		showIntro()
	elseif currentState.Name and IntroUI.overlay.Visible then
		hideIntro()
	end
end)

-- New: ShowResult remote for explicit result popups
local ShowResult = remotesFolder:FindFirstChild("ShowResult")
if ShowResult then
	ShowResult.OnClientEvent:Connect(function(data)
		showResultPopup({
			emoji = data.emoji or "ðŸ“‹",
			title = data.title or "Result",
			body = data.body or "Something happened...",
			happiness = data.happiness,
			health = data.health,
			smarts = data.smarts,
			looks = data.looks,
			money = data.money,
		}, function()
			-- Callback when popup closed
			if data.feedText then
				addFeedEntry(data.feedText)
			end
		end)
	end)
end

PresentEvent.OnClientEvent:Connect(function(eventData, ageFeedText)
	-- Validate event data
	if not eventData then
		warn("[LifeClient] âŒ PresentEvent received with nil eventData!")
		return
	end

	hideTutorial()
	if ageFeedText then
		addFeedEntry(ageFeedText)
	end

	-- Flash effect when event appears
	flashScreen(C.Blue, 0.85, 0.2)

	showEvent({
		id               = eventData.id,
		text             = eventData.text,
		choices          = eventData.choices,
		emoji            = eventData.emoji or "ðŸ™‚",
		title            = eventData.title or "Life Event",
		showRelationship = eventData.showRelationship or false,
		relationName     = eventData.relationName,
		relationship     = eventData.relationship,
		question         = eventData.question,
	})
end)

----------------------------------------------------------------
-- MINIGAME START HANDLER (Server triggers minigame)
----------------------------------------------------------------

if MinigameStart then
	MinigameStart.OnClientEvent:Connect(function(config)
if EventUI.overlay.Visible then
			hideEvent()
		end

		pendingMinigameEventId = config.eventId
		pendingMinigameChoiceIndex = config.choiceIndex

		if minigamesInstance and minigamesInstance.play then
			minigamesInstance:play(config.id, function(won, data)

				-- Send result back to server
				if MinigameResult then
					MinigameResult:FireServer(won, {
						eventId = config.eventId,
						choiceIndex = config.choiceIndex,
						score = data and data.score or 0,
					})
				end

				-- Clear pending
				pendingMinigameEventId = nil
				pendingMinigameChoiceIndex = nil

				-- Visual feedback
				if won then
					flashScreen(C.Green, 0.7, 0.3)
				else
					flashScreen(C.Red, 0.6, 0.3)
					shakeScreen(6, 0.2)
				end
			end)
		else
			-- No minigame module - just auto-complete as failure
			warn("[LifeClient] âš ï¸ No minigame module available, auto-failing")
			if MinigameResult then
				MinigameResult:FireServer(false, {
					eventId = config.eventId,
					choiceIndex = config.choiceIndex,
				})
			end
			pendingMinigameEventId = nil
			pendingMinigameChoiceIndex = nil
		end
	end)
end

----------------------------------------------------------------
-- AGE BUTTON LOGIC
----------------------------------------------------------------

local function pulseAge()
	local ti = TweenInfo.new(0.08, Enum.EasingStyle.Quad)
	tween(ageButton, ti, { Size = UDim2.new(1, -2, 1, -2) }).Completed:Wait()
	tween(ageButton, ti, { Size = UDim2.new(1, -6, 1, -6) })
end

ageButton.MouseButton1Click:Connect(function()
	-- Safety check: if awaitingEvent is true but the event overlay is NOT visible,
	-- something went wrong - reset the flag
	if awaitingEvent and not EventUI.overlay.Visible then
		awaitingEvent = false
		EventUI.currentEventId = nil
	end

	-- Block age up if waiting for event choice
	if awaitingEvent then
		return
	end

	-- Block if no name set yet (intro not complete)
	if not currentState.Name then
		return
	end

	hideTutorial()
	pulseAge()
	RequestAgeUp:FireServer()
end)

ageButton.MouseEnter:Connect(function()
	tween(ageOuterRing, TweenInfo.new(0.15), { Size = UDim2.new(1, 12, 1, 12) })
end)
ageButton.MouseLeave:Connect(function()
	tween(ageOuterRing, TweenInfo.new(0.15), { Size = UDim2.new(1, 8, 1, 8) })
end)

----------------------------------------------------------------
-- SCREEN MODULE INIT
----------------------------------------------------------------

local function safeNew(mod, name, ...)
	if mod and mod.new then
		local s, r = pcall(mod.new, ...)
		if s and r then return r end
	end
	return nil
end

ScreenInstances.occupation   = safeNew(OccupationScreen,    "OccupationScreen",    screenGui, blurOverlay, showBlur, hideBlur, currentState)
ScreenInstances.assets       = safeNew(AssetsScreen,        "AssetsScreen",        screenGui, blurOverlay, showBlur, hideBlur, currentState)
ScreenInstances.relationships= safeNew(RelationshipsScreen, "RelationshipsScreen", screenGui, blurOverlay, showBlur, hideBlur, currentState)
ScreenInstances.activities   = safeNew(ActivitiesScreen,    "ActivitiesScreen",    screenGui, blurOverlay, showBlur, hideBlur, currentState)
ScreenInstances.storypaths   = safeNew(StoryPathsScreen,    "StoryPathsScreen",    screenGui, currentState)

-- CRITICAL FIX #443: Create MafiaScreen with onShowEventCard callback
-- This allows mafia operations to close the MafiaScreen and show an event card in main UI
local function onMafiaShowEventCard(eventCard, onChoiceCallback)
	-- Hide the MafiaScreen first
	if ScreenInstances.mafia and ScreenInstances.mafia.hide then
		ScreenInstances.mafia:hide()
	end
	hideBlur()
	
	-- Show the event card on the main UI
	if showEvent then
		showEvent({
			id = eventCard.id or "mafia_operation",
			title = eventCard.title or "ðŸ”« Operation",
			emoji = eventCard.emoji or "ðŸ”«",
			text = eventCard.text or "A risky operation...",
			question = eventCard.question or "What do you do?",
			choices = eventCard.choices or {{text = "Continue", index = 1}},
			isMafiaOperation = true,
			onMafiaChoice = onChoiceCallback,
		})
	end
end
ScreenInstances.mafia        = safeNew(MafiaScreen,         "MafiaScreen",         screenGui, blurOverlay, showBlur, hideBlur, currentState, onMafiaShowEventCard)

if MinigamesModule then
	local ok, mg = pcall(function() return MinigamesModule.new(screenGui) end)
	if ok and mg then 
		minigamesInstance = mg
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX: Enable rare auto Purge event (0.5% chance every 90 seconds)
		-- The Purge is an ultra-rare survival event that can happen at any time!
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		if mg.enableRareAutoPurge then
			mg:enableRareAutoPurge({
				chance = 0.005,      -- 0.5% chance
				interval = 90,       -- Check every 90 seconds (1.5 min)
				totalScenarios = 10, -- 10 survival scenarios
				onComplete = function(won, stats)
					print("[LifeClient] ðŸ˜ˆ Purge event completed! Won:", won)
					-- Purge outcomes affect player stats
					if currentState then
						local statDelta = won and { Health = 5, Happiness = 10 } or { Health = -20, Happiness = -15 }
						for stat, delta in pairs(statDelta) do
							if currentState[stat] then
								currentState[stat] = math.clamp(currentState[stat] + delta, 0, 100)
							end
						end
						-- Add feed message
						local feedMsg = won 
							and "ðŸ˜ˆ You survived The Purge! (+Health, +Happiness)"
							or "ðŸ’€ You died in The Purge... (Lost Health & Happiness)"
						currentState.Feed = currentState.Feed or {}
						table.insert(currentState.Feed, feedMsg)
						refreshInfo()
					end
				end,
			})
		end
	end
end

----------------------------------------------------------------
-- INITIAL STATE
----------------------------------------------------------------

ageBtnContainer.Visible = false

task.delay(0.5, function()
	ageBtnContainer.Visible = true
	if not currentState.Name then
		showIntro()
	end
end)

----------------------------------------------------------------
-- STUCK STATE WATCHDOG
-- Periodically check if awaitingEvent is stuck and auto-recover
----------------------------------------------------------------

local lastAwaitingEventTime = nil
local STUCK_THRESHOLD = 30 -- seconds before considering it stuck

task.spawn(function()
	while true do
		task.wait(5) -- Check every 5 seconds

		if awaitingEvent then
			if not lastAwaitingEventTime then
				lastAwaitingEventTime = tick()
			elseif tick() - lastAwaitingEventTime > STUCK_THRESHOLD then
				-- Check if the event overlay is actually visible
				if not EventUI.overlay.Visible then
					awaitingEvent = false
					EventUI.currentEventId = nil
					lastAwaitingEventTime = nil
				end
			end
		else
			lastAwaitingEventTime = nil
		end
	end
end)

print("[LifeClient] âœ… Loaded in " .. string.format("%.1fs", tick() - startTime))
