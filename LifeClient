-- StarterPlayerScripts / LifeClient (LocalScript)
-- BitLife-style UI: POLISHED AAA-quality recreation
-- Fixed: Header avoids Roblox logo, stats don't conflict with Age button
-- Professional modals, smooth animations, premium feel

local startTime = tick()

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService      = game:GetService("TweenService")
local MarketplaceService = game:GetService("MarketplaceService")

local player = Players.LocalPlayer

----------------------------------------------------------------
-- SCREEN MODULES (with error handling) - PARALLEL LOADING
----------------------------------------------------------------

local ScreensFolder = ReplicatedStorage:WaitForChild("Screens", 3) -- Reduced timeout

local OccupationScreen, AssetsScreen, RelationshipsScreen, ActivitiesScreen, StoryPathsScreen, MafiaScreen, ProgressScreen
local MinigamesModule

if ScreensFolder then
	print("[LifeClient] ğŸ“‚ Found ScreensFolder, loading screen modules...")
	
	-- Load modules with detailed error logging
	local function safeRequire(name)
		print("[LifeClient] ğŸ”„ Loading screen module:", name)
		local child = ScreensFolder:FindFirstChild(name)
		if child then
			print("[LifeClient] âœ“ Found module:", name)
			local s, r = pcall(require, child)
			if s then
				if r then
					print("[LifeClient] âœ… Successfully required:", name)
					-- CRITICAL DEBUG: Check what we actually got back
					print("[LifeClient] ğŸ” Module type:", type(r))
					if type(r) == "table" then
						print("[LifeClient] ğŸ” Has .new?", r.new ~= nil)
						if r.new then
							print("[LifeClient] ğŸ” .new type:", type(r.new))
						end
					end
					return r
				else
					warn("[LifeClient] âŒ Module", name, "returned nil from require")
				end
			else
				warn("[LifeClient] âŒ Failed to require", name, ":", tostring(r))
			end
		else
			-- Don't warn for optional modules like MafiaScreen
			if name ~= "MafiaScreen" then
				warn("[LifeClient] âŒ Module not found in Screens folder:", name)
			end
		end
		return nil
	end

	-- Sequential loading with logging (for debugging)
	OccupationScreen    = safeRequire("OccupationScreen")
	AssetsScreen        = safeRequire("AssetsScreen")
	RelationshipsScreen = safeRequire("RelationshipsScreen")
	ActivitiesScreen    = safeRequire("ActivitiesScreen")
	StoryPathsScreen    = safeRequire("StoryPathsScreen")
	MafiaScreen         = safeRequire("MafiaScreen")
	ProgressScreen      = safeRequire("ProgressScreen")
	
	print("[LifeClient] ğŸ“‚ Screen modules loaded. AssetsScreen is:", AssetsScreen and "OK" or "NIL")
else
	warn("[LifeClient] âŒ ScreensFolder not found! Screens will not work!")
end

-- Minigames module (directly in ReplicatedStorage) - wait for it!
local function safeRequireRS(name)
	-- Try immediate find first, then wait if not found
	local child = ReplicatedStorage:FindFirstChild(name)
	if not child then
		child = ReplicatedStorage:WaitForChild(name, 5)
	end
	if child then
		local s, r = pcall(require, child)
		if s then 
			print("[LifeClient] âœ… Successfully loaded module:", name)
			return r 
		else
			warn("[LifeClient] âŒ Failed to require module:", name, "-", tostring(r))
		end
	else
		warn("[LifeClient] âš ï¸ Module not found in ReplicatedStorage:", name)
	end
	return nil
end
MinigamesModule = safeRequireRS("Minigames")

-- CRITICAL FIX: Print debug info about MinigamesModule loading status
if MinigamesModule then
	print("[LifeClient] ğŸ® MinigamesModule loaded successfully. Type:", type(MinigamesModule))
	if MinigamesModule.new then
		print("[LifeClient] ğŸ® MinigamesModule.new function is available")
	else
		warn("[LifeClient] âŒ MinigamesModule.new function is MISSING!")
	end
else
	warn("[LifeClient] âš ï¸ MinigamesModule is nil - minigames will NOT work!")
	warn("[LifeClient] âš ï¸ Please ensure 'Minigames' ModuleScript is in ReplicatedStorage")
end

----------------------------------------------------------------
-- REMOTES (robust - wait for server to create them)
----------------------------------------------------------------

-- Wait for the remotes folder (server creates it on startup)
local remotesFolder = nil
local function waitForRemotes()
	-- Try LifeRemotes first
	remotesFolder = ReplicatedStorage:WaitForChild("LifeRemotes", 10)
	if not remotesFolder then
		-- Fallback to "Life" folder
		remotesFolder = ReplicatedStorage:WaitForChild("Life", 5)
	end
	if not remotesFolder then
		warn("[LifeClient] Could not find remotes folder! Server may not have initialized.")
		return false
	end
	return true
end

-- Wait for remotes before continuing
if not waitForRemotes() then
	-- Create a placeholder folder to prevent nil errors
	-- The game won't work properly, but at least it won't crash
	warn("[LifeClient] Creating placeholder remotes folder - game will not function correctly!")
	remotesFolder = Instance.new("Folder")
	remotesFolder.Name = "LifeRemotesPlaceholder"
	remotesFolder.Parent = ReplicatedStorage
end

-- Use FindFirstChild first, then WaitForChild as fallback
local function getRemote(name, timeout)
	if not remotesFolder then
		warn("[LifeClient] Remotes folder is nil when getting:", name)
		return nil
	end
	local remote = remotesFolder:FindFirstChild(name)
	if not remote then
		remote = remotesFolder:WaitForChild(name, timeout or 5)
	end
	return remote
end

local RequestAgeUp     = getRemote("RequestAgeUp")
local PresentEvent     = getRemote("PresentEvent")
local SubmitChoice     = getRemote("SubmitChoice")
local SyncState        = getRemote("SyncState")
local SetLifeInfo      = getRemote("SetLifeInfo")
local MinigameResult   = getRemote("MinigameResult", 2)
local MinigameStart    = getRemote("MinigameStart", 2)
local CheckGamepass    = getRemote("CheckGamepass", 2)
local PromptGamepass   = getRemote("PromptGamepass", 2)
local GodModeEdit      = getRemote("GodModeEdit", 2)

----------------------------------------------------------------
-- STATE
----------------------------------------------------------------

-- Base birth year for all characters (consistent year calculation)
local BIRTH_YEAR = 2025

local currentState = {
	Name = nil, Age = 0, Money = 0,
	Happiness = 50, Health = 100, Smarts = 50, Looks = 50,
	Education = "None", Experience = 0, CurrentJob = nil, InJail = false,
	-- CRITICAL: Initialize Assets structure to prevent nil errors
	Assets = { Properties = {}, Vehicles = {}, Items = {}, Crypto = {} },
	Relationships = {},
	Flags = {},
}

local awaitingEvent          = false
local hasShownAgeHint        = false
local introComplete          = false
local selectedGender         = nil

local ScreenInstances = {
	occupation = nil,
	assets = nil,
	relationships = nil,
	activities = nil,
	storypaths = nil,
	mafia = nil,
}
local minigamesInstance
local pendingMinigameEventId     = nil
local pendingMinigameChoiceIndex = nil
-- CRITICAL FIX #421: Cache ALL gamepass statuses to prevent reset on purchase
-- These are set to true immediately when purchased and NEVER set back to false
local hasGodMode = false
local hasRoyalty = false
local hasMafia = false
local hasCelebrity = false
local hasTimeMachine = false
local godModeOverlay = nil
local godModeButton = nil
local destroyGodModeModal
local showGodModeModal
local updateGodModeButtonAppearance

-- CRITICAL FIX #419: These refresh functions must NEVER downgrade true to false!
-- When a gamepass is purchased, we set hasGodMode = true immediately.
-- But the server might still return false due to caching delays.
-- So we ONLY update if the server says true (upgrading false to true).
-- We NEVER set hasGodMode = false if it's already true!
local function refreshGodModeStatus()
	-- If already true, don't even check - can't lose a purchased gamepass
	if hasGodMode then
		return true
	end
	if not CheckGamepass then
		return hasGodMode
	end
	local success, owns = pcall(function()
		return CheckGamepass:InvokeServer("GOD_MODE")
	end)
	if success and owns == true then
		hasGodMode = true  -- ONLY upgrade to true, never downgrade
	end
	return hasGodMode
end

-- CRITICAL FIX #420: Same logic for Royalty - NEVER downgrade true to false!
local function refreshRoyaltyStatus()
	-- If already true, don't even check - can't lose a purchased gamepass
	if hasRoyalty then
		return true
	end
	if not CheckGamepass then
		return hasRoyalty
	end
	local success, owns = pcall(function()
		return CheckGamepass:InvokeServer("ROYALTY")
	end)
	if success and owns == true then
		hasRoyalty = true  -- ONLY upgrade to true, never downgrade
	end
	return hasRoyalty
end

refreshGodModeStatus()
refreshRoyaltyStatus()

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: Listen for gamepass purchases to update UI smoothly
-- When user buys a gamepass, update all related buttons immediately
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local GAMEPASS_IDS = {
	ROYALTY = 1626378001,
	GOD_MODE = 1628050729,
	MAFIA = 1626238769,
	CELEBRITY = 1626461980,
	TIME_MACHINE = 1630681215,
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX #509: DIRECT CLIENT-SIDE GAMEPASS PROMPT FUNCTION!
-- This bypasses the server's cooldown system entirely for user-initiated clicks!
-- User complaint: "clicking gamepass button doesn't popup again after first try"
-- Solution: Call MarketplaceService directly from client - no server cooldown!
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function promptGamepassDirect(gamepassKey)
	local gamepassId = GAMEPASS_IDS[gamepassKey]
	if not gamepassId then
		warn("[LifeClient] Unknown gamepass key:", gamepassKey)
		return false
	end
	
	-- Check if already owned (from cache)
	if gamepassKey == "GOD_MODE" and hasGodMode then
		print("[LifeClient] Already owns GOD_MODE")
		return false
	elseif gamepassKey == "ROYALTY" and hasRoyalty then
		print("[LifeClient] Already owns ROYALTY")
		return false
	elseif gamepassKey == "MAFIA" and hasMafia then
		print("[LifeClient] Already owns MAFIA")
		return false
	elseif gamepassKey == "CELEBRITY" and hasCelebrity then
		print("[LifeClient] Already owns CELEBRITY")
		return false
	elseif gamepassKey == "TIME_MACHINE" and hasTimeMachine then
		print("[LifeClient] Already owns TIME_MACHINE")
		return false
	end
	
	-- CRITICAL: Call MarketplaceService DIRECTLY from client!
	-- This bypasses the server's cooldown system entirely!
	local success, err = pcall(function()
		MarketplaceService:PromptGamePassPurchase(player, gamepassId)
	end)
	
	if success then
		print("[LifeClient] âœ… Prompted", gamepassKey, "purchase (ID:", gamepassId, ")")
	else
		warn("[LifeClient] Failed to prompt", gamepassKey, "purchase:", err)
	end
	
	-- Also notify server (for tracking purposes, but don't wait for response)
	task.spawn(function()
		if PromptGamepass then
			pcall(function() PromptGamepass:FireServer(gamepassKey, true) end)
		end
	end)
	
	return success
end

local function onGamepassPurchaseFinished(plr, gamePassId, wasPurchased)
	if plr ~= player or not wasPurchased then return end
	
	print("[LifeClient] Gamepass purchase finished:", gamePassId, wasPurchased)
	
	-- CRITICAL FIX #422: Force set gamepass ownership immediately based on purchase
	-- This bypasses any caching delays from the server
	-- These values are NEVER set back to false once true!
	if gamePassId == GAMEPASS_IDS.GOD_MODE then
		hasGodMode = true
		print("[LifeClient] God Mode gamepass purchased - immediately enabling!")
	elseif gamePassId == GAMEPASS_IDS.ROYALTY then
		hasRoyalty = true
		print("[LifeClient] Royalty gamepass purchased - immediately enabling!")
	elseif gamePassId == GAMEPASS_IDS.MAFIA then
		hasMafia = true
		print("[LifeClient] Mafia gamepass purchased - immediately enabling!")
	elseif gamePassId == GAMEPASS_IDS.CELEBRITY then
		hasCelebrity = true
		print("[LifeClient] Celebrity gamepass purchased - immediately enabling!")
	elseif gamePassId == GAMEPASS_IDS.TIME_MACHINE then
		hasTimeMachine = true
		print("[LifeClient] Time Machine gamepass purchased - immediately enabling!")
	end
	
	-- CRITICAL FIX #405: Multiple retries to handle Roblox API delays
	-- The ownership might not be immediately reflected in MarketplaceService
	local function updateAllGamepassUI()
		refreshGodModeStatus()
		refreshRoyaltyStatus()  -- CRITICAL FIX #414: Also refresh royalty status
		
		-- Update God Mode button
		if IntroUI and IntroUI.updateCustomizeGenderBtn then
			IntroUI.updateCustomizeGenderBtn()
		end
		
		-- Update Royalty button
		if IntroUI and IntroUI.updateRoyaltyGenderBtn then
			IntroUI.updateRoyaltyGenderBtn()
		end
		
		-- CRITICAL FIX #417: Update God Mode wealth buttons if royalty purchased
		if IntroUI and IntroUI.updateWealthButtons then
			IntroUI.updateWealthButtons()
		end
		
		-- CRITICAL FIX #365: Update Time Machine UI if death overlay is showing
		if DeathUI and DeathUI.updateTimeMachineUI then
			DeathUI.updateTimeMachineUI()
		end
		
		-- CRITICAL FIX #406: Update God Mode in-game button if it exists
		if updateGodModeButtonAppearance then
			pcall(updateGodModeButtonAppearance)
		end
		
		-- Update main UI
		if updateFromState then
			pcall(updateFromState)
		end
	end
	
	-- Immediate update
	task.defer(updateAllGamepassUI)
	
	-- CRITICAL FIX #407: Retry after short delays to catch API propagation
	task.delay(0.5, updateAllGamepassUI)
	task.delay(1.5, updateAllGamepassUI)
end

MarketplaceService.PromptGamePassPurchaseFinished:Connect(onGamepassPurchaseFinished)

-- CRITICAL FIX #367: Listen for server-side gamepass purchase notification
-- This fires AFTER the purchase is verified and state is updated
local GamepassPurchased = remotesFolder and remotesFolder:FindFirstChild("GamepassPurchased")
if GamepassPurchased then
	GamepassPurchased.OnClientEvent:Connect(function(gamepassKey)
		print("[LifeClient] Server confirmed gamepass purchased:", gamepassKey)
		
		-- CRITICAL FIX #423: Immediately set gamepass flags based on server confirmation
		-- These are PERMANENT - never set back to false!
		if gamepassKey == "GOD_MODE" then
			hasGodMode = true
		elseif gamepassKey == "ROYALTY" then
			hasRoyalty = true
		elseif gamepassKey == "MAFIA" then
			hasMafia = true
		elseif gamepassKey == "CELEBRITY" then
			hasCelebrity = true
		elseif gamepassKey == "TIME_MACHINE" then
			hasTimeMachine = true
		end
		
		-- CRITICAL FIX #409: Update client state GamepassOwnership immediately
		if currentState then
			currentState.GamepassOwnership = currentState.GamepassOwnership or {}
			if gamepassKey == "GOD_MODE" then
				currentState.GamepassOwnership.godMode = true
				currentState.Flags = currentState.Flags or {}
				currentState.Flags.god_mode_gamepass = true
			elseif gamepassKey == "ROYALTY" then
				currentState.GamepassOwnership.royalty = true
				currentState.Flags = currentState.Flags or {}
				currentState.Flags.royalty_gamepass = true
			elseif gamepassKey == "MAFIA" then
				currentState.GamepassOwnership.mafia = true
				currentState.Flags = currentState.Flags or {}
				currentState.Flags.mafia_gamepass = true
			elseif gamepassKey == "CELEBRITY" then
				currentState.GamepassOwnership.celebrity = true
				currentState.Flags = currentState.Flags or {}
				currentState.Flags.celebrity_gamepass = true
			elseif gamepassKey == "TIME_MACHINE" then
				currentState.GamepassOwnership.timeMachine = true
				currentState.Flags = currentState.Flags or {}
				currentState.Flags.time_machine_gamepass = true
			end
		end
		
		-- Refresh server check as well
		refreshGodModeStatus()
		
		task.defer(function()
			-- Update intro UI buttons
			if IntroUI and IntroUI.updateCustomizeGenderBtn then
				IntroUI.updateCustomizeGenderBtn()
			end
			if IntroUI and IntroUI.updateRoyaltyGenderBtn then
				IntroUI.updateRoyaltyGenderBtn()
			end
			
			-- CRITICAL FIX #418: Update God Mode wealth buttons if royalty purchased
			if IntroUI and IntroUI.updateWealthButtons then
				IntroUI.updateWealthButtons()
			end
			
			-- Update Time Machine
			if DeathUI and DeathUI.updateTimeMachineUI then
				DeathUI.updateTimeMachineUI()
			end
			
			-- CRITICAL FIX #410: Update God Mode button appearance
			if updateGodModeButtonAppearance then
				pcall(updateGodModeButtonAppearance)
			end
			
			-- Force refresh the main UI
			if updateFromState then
				updateFromState()
			end
		end)
	end)
end

-- CRITICAL FIX #369: Listen for Developer Product purchase completion
-- When a time machine product is purchased, the ProcessReceipt handles it on server
-- The server will send a SyncState update which triggers hideDeathOverlay
MarketplaceService.PromptProductPurchaseFinished:Connect(function(userId, productId, wasPurchased)
	if userId ~= player.UserId or not wasPurchased then return end
	
	print("[LifeClient] Developer Product purchased:", productId)
	
	-- Time Machine product IDs
	local TIME_PRODUCTS = {
		[3477466389] = 5,   -- 5 years
		[3477466522] = 10,  -- 10 years
		[3477466619] = 20,  -- 20 years
		[3477466778] = -1,  -- Baby
	}
	
	if TIME_PRODUCTS[productId] then
		print("[LifeClient] Time Machine product purchased, waiting for server to process...")
		-- Server's ProcessReceipt will handle the time travel and send SyncState
		-- The SyncState handler will update the UI and hide death overlay
	end
end)

-- Forward declarations
local showEvent, hideEvent
local showIntro, hideIntro
local showTutorial, hideTutorial
local showDeathOverlay, hideDeathOverlay
local updateNameButtons
local updateFromState

-- Helper: Calculate current year from age
local function getCurrentYear(age)
	return BIRTH_YEAR + (age or 0)
end

----------------------------------------------------------------
-- COLORS (Premium BitLife Palette)
----------------------------------------------------------------

local C = {
	-- Primary Blues
	Blue      = Color3.fromRGB(37, 99, 235),
	BlueDark  = Color3.fromRGB(29, 78, 216),
	BlueLight = Color3.fromRGB(96, 165, 250),
	BluePale  = Color3.fromRGB(219, 234, 254),

	-- Greens
	Green      = Color3.fromRGB(34, 197, 94),
	GreenDark  = Color3.fromRGB(22, 163, 74),
	GreenRing  = Color3.fromRGB(21, 128, 61),
	GreenPale  = Color3.fromRGB(220, 252, 231),

	-- Accents
	Red      = Color3.fromRGB(239, 68, 68),
	RedDark  = Color3.fromRGB(220, 38, 38),
	RedPale  = Color3.fromRGB(254, 226, 226),
	Orange   = Color3.fromRGB(249, 115, 22),
	Pink     = Color3.fromRGB(244, 114, 182),
	PinkDark = Color3.fromRGB(219, 39, 119),
	PinkPale = Color3.fromRGB(252, 231, 243),
	Purple   = Color3.fromRGB(168, 85, 247),
	Yellow   = Color3.fromRGB(253, 224, 71),
	Amber    = Color3.fromRGB(245, 158, 11),

	-- Gender
	Male   = Color3.fromRGB(56, 189, 248),
	Female = Color3.fromRGB(244, 114, 182),

	-- Neutrals
	White    = Color3.fromRGB(255, 255, 255),
	OffWhite = Color3.fromRGB(250, 250, 250),
	Gray50   = Color3.fromRGB(249, 250, 251),
	Gray100  = Color3.fromRGB(243, 244, 246),
	Gray200  = Color3.fromRGB(229, 231, 235),
	Gray300  = Color3.fromRGB(209, 213, 219),
	Gray400  = Color3.fromRGB(156, 163, 175),
	Gray500  = Color3.fromRGB(107, 114, 128),
	Gray600  = Color3.fromRGB(75, 85, 99),
	Gray700  = Color3.fromRGB(55, 65, 81),
	Gray800  = Color3.fromRGB(31, 41, 55),
	Gray900  = Color3.fromRGB(17, 24, 39),

	-- Nav
	NavBlue = Color3.fromRGB(30, 58, 138),
	NavDark = Color3.fromRGB(23, 37, 84),

	-- Overlay
	Black = Color3.fromRGB(0, 0, 0),
	
	-- Background
	Bg = Color3.fromRGB(249, 250, 251), -- Same as Gray50
}

-- CRITICAL FIX #951: Fonts must ALWAYS have valid values to prevent nil errors
-- "Unable to assign property Font. EnumItem, number, or string expected, got nil"
local DEFAULT_FONT = Enum.Font.SourceSans

local F = {
	Title  = Enum.Font.GothamBold or Enum.Font.SourceSansBold or DEFAULT_FONT,
	Body   = Enum.Font.Gotham or Enum.Font.SourceSans or DEFAULT_FONT,
	Medium = Enum.Font.GothamMedium or Enum.Font.SourceSans or DEFAULT_FONT,
	Button = Enum.Font.GothamBold or Enum.Font.SourceSansBold or DEFAULT_FONT,
	Bold   = Enum.Font.GothamBold or Enum.Font.SourceSansBold or DEFAULT_FONT,
}

-- Safety: Ensure all font values are valid Enum.Font (double-check everything)
for key, value in pairs(F) do
	if type(value) ~= "userdata" then
		warn("[LifeClient] Font", key, "was invalid, using default")
		F[key] = DEFAULT_FONT
	end
end

-- Triple safety: Explicit checks for commonly used fonts
if not F.Title then F.Title = DEFAULT_FONT end
if not F.Body then F.Body = DEFAULT_FONT end
if not F.Medium then F.Medium = DEFAULT_FONT end
if not F.Button then F.Button = DEFAULT_FONT end
if not F.Bold then F.Bold = DEFAULT_FONT end

local function ensureSharedUITheme()
	local sharedUI = safeRequireRS("UIComponents")
	if not sharedUI then
		return
	end

	sharedUI.Colors = sharedUI.Colors or {}
	for name, value in pairs(C) do
		if sharedUI.Colors[name] == nil then
			sharedUI.Colors[name] = value
		end
	end

	-- Additional palette entries used by the standalone screens
	local extraColors = {
		Bg        = Color3.fromRGB(246, 248, 252),
		Teal      = Color3.fromRGB(20, 184, 166),
		TealDark  = Color3.fromRGB(13, 148, 136),
		TealPale  = Color3.fromRGB(204, 251, 241),
		Cyan      = Color3.fromRGB(14, 165, 233),
		CyanDark  = Color3.fromRGB(21, 94, 117),
		CyanPale  = Color3.fromRGB(224, 242, 254),
		Gold      = Color3.fromRGB(251, 191, 36),
		GoldDark  = Color3.fromRGB(217, 119, 6),
		GoldPale  = Color3.fromRGB(254, 243, 199),
		AmberDark = Color3.fromRGB(217, 119, 6),
		AmberPale = Color3.fromRGB(254, 243, 199),
		PurplePale= Color3.fromRGB(243, 232, 255),
		Gray950   = Color3.fromRGB(2, 6, 23),
	}
	for name, value in pairs(extraColors) do
		if sharedUI.Colors[name] == nil then
			sharedUI.Colors[name] = value
		end
	end

	-- CRITICAL FIX #951: Ensure fonts are ALWAYS valid
	sharedUI.Fonts = sharedUI.Fonts or {}
	for name, font in pairs(F) do
		if sharedUI.Fonts[name] == nil or type(sharedUI.Fonts[name]) ~= "userdata" then
			sharedUI.Fonts[name] = font
		end
	end
	
	-- Extra safety: verify all fonts are valid Enum.Font values
	local DEFAULT_FONT = Enum.Font.SourceSans
	for name, font in pairs(sharedUI.Fonts) do
		if type(font) ~= "userdata" then
			sharedUI.Fonts[name] = DEFAULT_FONT
		end
	end

	if not sharedUI.formatMoney then
		function sharedUI.formatMoney(amount)
			if not amount then return "$0" end
			if amount >= 1_000_000 then
				return string.format("$%.1fM", amount / 1_000_000)
			elseif amount >= 1_000 then
				return string.format("$%.1fK", amount / 1_000)
			else
				return "$" .. tostring(math.floor(amount + 0.5))
			end
		end
	end
end

ensureSharedUITheme()

----------------------------------------------------------------
-- HELPERS
----------------------------------------------------------------

local function corner(p, r)
	local c = Instance.new("UICorner")
	c.CornerRadius = UDim.new(0, r)
	c.Parent = p
	return c
end

local function pill(p)
	local c = Instance.new("UICorner")
	c.CornerRadius = UDim.new(0.5, 0)
	c.Parent = p
	return c
end

local function stroke(p, t, tr, col)
	local s = Instance.new("UIStroke")
	s.Thickness = t
	s.Transparency = tr or 0
	s.Color = col or C.White
	s.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	s.Parent = p
	return s
end

local function pad(p, l, r, t, b)
	local pd = Instance.new("UIPadding")
	pd.PaddingLeft   = UDim.new(0, l or 0)
	pd.PaddingRight  = UDim.new(0, r or 0)
	pd.PaddingTop    = UDim.new(0, t or 0)
	pd.PaddingBottom = UDim.new(0, b or 0)
	pd.Parent = p
	return pd
end

UI = UI or safeRequireRS("UIComponents") or {}
UI.corner = UI.corner or corner
UI.pill = UI.pill or pill
UI.stroke = UI.stroke or stroke
UI.pad = UI.pad or pad

local function tween(o, i, p)
	local t = TweenService:Create(o, i, p)
	t:Play()
	return t
end

local function formatMoney(n)
	if not n then return "$0" end
	if n >= 1000000 then
		return string.format("$%.1fM", n/1000000)
	elseif n >= 1000 then
		return string.format("$%.1fK", n/1000)
	else
		return "$"..math.floor(n)
	end
end

local function createShadow(parent, offset, blur, color, transparency)
	local shadow = Instance.new("ImageLabel")
	shadow.Name = "Shadow"
	shadow.Size = UDim2.new(1, blur*2, 1, blur*2)
	shadow.Position = UDim2.new(0, -blur + (offset or 0), 0, -blur + (offset or 4))
	shadow.BackgroundTransparency = 1
	shadow.Image = "rbxassetid://5554236805"
	shadow.ImageColor3 = color or C.Black
	shadow.ImageTransparency = transparency or 0.85
	shadow.ScaleType = Enum.ScaleType.Slice
	shadow.SliceCenter = Rect.new(23, 23, 277, 277)
	shadow.ZIndex = parent.ZIndex - 1
	shadow.Parent = parent
	return shadow
end

----------------------------------------------------------------
-- MOBILE RESPONSIVE SYSTEM
-- Detects device type and provides responsive sizing helpers
-- OPTIMIZED for tiny phones like iPhone 6 (375x667)
----------------------------------------------------------------

local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera

-- Device detection - consolidated into single table to reduce local register usage
-- (Luau has a 200 local register limit per function scope)
-- CRITICAL FIX: Improved mobile detection to prevent false positives on PC
local GuiService = game:GetService("GuiService")
local RunService = game:GetService("RunService")

-- More robust mobile detection:
-- 1. Must have touch AND no keyboard (or mouse as primary)
-- 2. Must NOT be in Studio (Studio always counts as PC)
-- 3. Must NOT be console/ten-foot interface
local function detectMobile()
	-- Never consider Studio as mobile
	if RunService:IsStudio() then
		return false
	end
	-- Console is not mobile
	if GuiService:IsTenFootInterface() then
		return false
	end
	-- Mobile = touch enabled AND (no keyboard OR no mouse)
	-- This prevents touch-screen PCs from being detected as mobile
	local hasTouch = UserInputService.TouchEnabled
	local hasKeyboard = UserInputService.KeyboardEnabled
	local hasMouse = UserInputService.MouseEnabled
	-- PC with touch screen has all three - NOT mobile
	-- Mobile has touch but typically no mouse
	return hasTouch and not hasMouse
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: ROBUST VIEWPORT STABILIZATION SYSTEM
-- User complaint: "THE LIFECLIENT ISNT LOADING NOW CORRECTLY LIKE NORMALLY"
-- "ITS LOADING ITS SIZING WEIRD IDK SOMETIMES"
-- 
-- The viewport can report incorrect sizes initially on some devices/connections
-- This enhanced system waits for viewport to STABILIZE (same size 3 consecutive checks)
-- before initializing UI, preventing sizing issues
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local viewportStabilized = false
local viewportStabilizeAttempts = 0

local function waitForValidViewport()
	local attempts = 0
	local lastSize = Vector2.new(0, 0)
	local stableCount = 0
	local maxAttempts = 60 -- 3 seconds max wait
	
	print("[LifeClient] ğŸ”„ Waiting for viewport to stabilize...")
	
	-- Wait until viewport is valid AND stable (same size for 3 consecutive checks)
	while attempts < maxAttempts do
		attempts = attempts + 1
		local current = Camera.ViewportSize
		
		-- Check if valid (not loading state)
		if current.X >= 100 and current.Y >= 100 then
			-- Check if stable (same as last check within 5px tolerance)
			if math.abs(current.X - lastSize.X) < 5 and math.abs(current.Y - lastSize.Y) < 5 then
				stableCount = stableCount + 1
				if stableCount >= 3 then
					-- Viewport is valid and stable!
					viewportStabilized = true
					viewportStabilizeAttempts = attempts
					print(string.format("[LifeClient] âœ… Viewport stabilized in %d attempts: %dx%d", attempts, math.floor(current.X), math.floor(current.Y)))
					return current
				end
			else
				-- Size changed, reset stable counter
				stableCount = 0
			end
			lastSize = current
		else
			-- Invalid size, reset counters
			stableCount = 0
			lastSize = Vector2.new(0, 0)
		end
		
		task.wait(0.05) -- Check every 50ms
	end
	
	-- Fallback: Use whatever viewport we have now, or sensible default
	local fallback = Camera.ViewportSize
	if fallback.X < 100 or fallback.Y < 100 then
		warn("[LifeClient] âš ï¸ Viewport invalid after timeout, using iPhone 12 defaults")
		fallback = Vector2.new(390, 844)
	else
		warn(string.format("[LifeClient] âš ï¸ Viewport may be unstable, using current: %dx%d", math.floor(fallback.X), math.floor(fallback.Y)))
	end
	
	viewportStabilized = true
	viewportStabilizeAttempts = attempts
	return fallback
end

local initialViewport = waitForValidViewport()

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- DEVICE DETECTION & RESPONSIVE SYSTEM
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local Device = {
	ViewportSize = initialViewport,
	IS_MOBILE = detectMobile(),
	IS_TABLET = false,
	IS_SMALL_PHONE = false,
	IS_TINY_PHONE = false,
}

-- Calculate device type flags
local function updateDeviceFlags()
	local vp = Device.ViewportSize
	Device.IS_MOBILE = detectMobile()
	Device.IS_TABLET = Device.IS_MOBILE and (vp.X >= 768 or vp.Y >= 768)
	Device.IS_SMALL_PHONE = Device.IS_MOBILE and not Device.IS_TABLET and (vp.X < 450 or vp.Y < 750)
	Device.IS_TINY_PHONE = Device.IS_MOBILE and not Device.IS_TABLET and (vp.X <= 380 or vp.Y <= 680)
end

updateDeviceFlags() -- Initial calculation

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- VIEWPORT CHANGE TRACKING
-- Monitors viewport changes after initial stabilization and updates Device flags
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local viewportChangeCallbacks = {}
local lastViewportSize = initialViewport
local viewportCheckCount = 0

local function updateViewport(source)
	local newViewport = Camera.ViewportSize
	viewportCheckCount = viewportCheckCount + 1
	
	-- CRITICAL: Skip if viewport is invalid (loading state)
	if newViewport.X < 100 or newViewport.Y < 100 then
		return false
	end
	
	-- Only process if viewport actually changed significantly (>10px difference)
	local sizeChanged = math.abs(newViewport.X - lastViewportSize.X) > 10 or 
	                    math.abs(newViewport.Y - lastViewportSize.Y) > 10
	
	-- Update Device values
	Device.ViewportSize = newViewport
	updateDeviceFlags() -- Use the centralized function
	
	-- If significant change, log and notify callbacks
	if sizeChanged then
		print(string.format("[LifeClient] ğŸ“ Viewport changed (%s): %dx%d â†’ %dx%d", 
			source or "unknown",
			math.floor(lastViewportSize.X), math.floor(lastViewportSize.Y),
			math.floor(newViewport.X), math.floor(newViewport.Y)))
		
		lastViewportSize = newViewport
		for _, callback in ipairs(viewportChangeCallbacks) do
			pcall(callback, newViewport)
		end
		return true
	end
	
	return false
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- POST-LOAD VIEWPORT STABILIZATION CHECKS
-- Even after initial stabilization, viewport can change as Roblox fully loads
-- These delayed checks ensure UI stays correct
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
task.delay(0.3, function()
	updateViewport("delayed_check_300ms")
end)
task.delay(0.7, function()
	updateViewport("delayed_check_700ms")
end)
task.delay(1.5, function()
	updateViewport("delayed_check_1500ms")
end)
task.delay(3.0, function()
	-- Final check - if viewport changed significantly, force UI refresh
	if updateViewport("delayed_check_3000ms") then
		print("[LifeClient] âš ï¸ Late viewport change detected - UI may need refresh")
	end
end)

-- Connect to viewport change signal
Camera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
	updateViewport("signal")
end)

-- Responsive sizing helpers - MORE AGGRESSIVE for tiny phones
local function getScale()
	-- Base scale on smaller dimension for consistent mobile experience
	local minDim = math.min(Device.ViewportSize.X, Device.ViewportSize.Y)
	if minDim <= 320 then return 0.50 end  -- Extremely tiny (iPhone SE 1st gen)
	if minDim <= 375 then return 0.58 end  -- Tiny phone (iPhone 6/7/8, SE)
	if minDim <= 400 then return 0.68 end  -- Small phone
	if minDim <= 450 then return 0.78 end  -- Medium-small phone
	if minDim <= 550 then return 0.88 end  -- Medium phone
	if minDim < 768 then return 0.95 end   -- Large phone / small tablet
	return 1.0  -- Tablet / Desktop
end

-- Scale pixel values for mobile
local function px(baseValue)
	return math.floor(baseValue * getScale())
end

-- Get responsive text size - with better minimums for tiny screens
-- CRITICAL FIX: User complaint "FAILED TO SET UITEXTSIZECONSTRAINTS"
-- This error occurs when TextSize is set too small relative to UITextSizeConstraint
-- The UIComponents module (external) uses constraints with MinTextSize/MaxTextSize
-- If TextSize is below MinTextSize, Roblox throws this error
-- Solution: Enforce a STRICT minimum of 10px to prevent any constraint issues
local function textSize(baseSize)
	-- Safety: ensure baseSize is a valid number
	if type(baseSize) ~= "number" or baseSize ~= baseSize then -- NaN check
		baseSize = 14 -- Default fallback
	end
	
	local scale = getScale()
	local scaled = math.floor(baseSize * scale)
	
	-- CRITICAL FIX: STRICT minimum of 10px to prevent UITextSizeConstraint errors
	-- UITextSizeConstraint's MinTextSize is typically 8-12px in UIComponents
	-- By never going below 10, we ensure MaxTextSize is never < MinTextSize
	local strictMinSize = 10 -- NEVER go below 10px regardless of device
	local preferredMin = Device.IS_TINY_PHONE and 10 or 11
	local minSize = math.max(strictMinSize, preferredMin)
	
	if scaled < minSize then 
		scaled = minSize 
	end
	
	-- Also cap maximum to prevent overflow issues
	if scaled > 100 then
		scaled = 100
	end
	
	return scaled
end

-- CRITICAL FIX: Safe text size setter function
-- Wraps TextSize assignment in pcall to prevent UITextSizeConstraint errors from crashing
-- Use this for any dynamically calculated text sizes
local function safeSetTextSize(textElement, size)
	if not textElement then return end
	
	-- Ensure size is valid
	local safeSize = size
	if type(size) ~= "number" or size ~= size or size < 10 then
		safeSize = 14 -- Default safe size
	elseif size > 100 then
		safeSize = 100
	end
	
	-- Try to set text size, catch any constraint errors
	local success, err = pcall(function()
		textElement.TextSize = safeSize
	end)
	
	if not success then
		-- If failed, try with a larger safe size
		pcall(function()
			textElement.TextSize = 14
		end)
		-- Suppress the warning to avoid spamming console
		-- warn("[LifeClient] TextSize assignment failed, used fallback:", err)
	end
end

-- Get responsive padding - more compact on tiny phones
local function padSize(base)
	if Device.IS_TINY_PHONE then
		return math.max(2, math.floor(base * 0.5))
	end
	return math.max(4, math.floor(base * getScale()))
end

-- Minimum tap target size (44px per Apple/Google guidelines, but 40 OK on tiny)
local MIN_TAP_TARGET = Device.IS_TINY_PHONE and 40 or 44

-- Get touch-friendly button height
local function btnHeight(baseHeight)
	local scaled = math.floor(baseHeight * getScale())
	local minTarget = Device.IS_TINY_PHONE and 38 or MIN_TAP_TARGET
	if Device.IS_MOBILE and scaled < minTarget then
		return minTarget
	end
	return scaled
end

-- Get responsive modal width (percentage of screen with max)
local function modalWidth(maxWidth)
	if Device.IS_TINY_PHONE then
		return Device.ViewportSize.X - 12  -- 6px margin each side on tiny phones
	elseif Device.IS_SMALL_PHONE then
		return Device.ViewportSize.X - 16  -- 8px margin each side
	end
	return math.min(Device.ViewportSize.X * 0.92, maxWidth or 400)
end

-- Get responsive card width
local function cardWidth(maxWidth)
	if Device.IS_TINY_PHONE then
		return Device.ViewportSize.X - 12  -- 6px margin each side
	elseif Device.IS_SMALL_PHONE then
		return Device.ViewportSize.X - 16  -- 8px margin each side
	elseif Device.IS_MOBILE then
		return math.min(Device.ViewportSize.X - 24, maxWidth or 350)
	end
	return maxWidth or 350
end

----------------------------------------------------------------
-- SCREEN GUI
----------------------------------------------------------------

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: Verify viewport is stable before creating UI
-- User complaint: "THE LIFECLIENT ISNT LOADING NOW CORRECTLY LIKE NORMALLY"
-- This ensures we don't create UI with wrong sizes
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if not viewportStabilized then
	warn("[LifeClient] âš ï¸ Viewport not yet stable, waiting...")
	local waitStart = tick()
	while not viewportStabilized and (tick() - waitStart) < 5 do
		task.wait(0.1)
	end
end

-- Final viewport sanity check
local currentVP = Camera.ViewportSize
if currentVP.X < 100 or currentVP.Y < 100 then
	warn("[LifeClient] âš ï¸ Viewport still invalid, forcing update...")
	Device.ViewportSize = Vector2.new(390, 844) -- Safe default
	updateDeviceFlags()
else
	Device.ViewportSize = currentVP
	updateDeviceFlags()
end

print(string.format("[LifeClient] ğŸ“± Final Device config: %dx%d | Mobile=%s | Tablet=%s | SmallPhone=%s | TinyPhone=%s",
	math.floor(Device.ViewportSize.X),
	math.floor(Device.ViewportSize.Y),
	tostring(Device.IS_MOBILE),
	tostring(Device.IS_TABLET),
	tostring(Device.IS_SMALL_PHONE),
	tostring(Device.IS_TINY_PHONE)
))

-- CRITICAL FIX: Add timeout and retry for PlayerGui to prevent UI from being "completely broken"
local playerGui = nil
local MAX_RETRIES = 5
for attempt = 1, MAX_RETRIES do
	playerGui = player:WaitForChild("PlayerGui", 5)
	if playerGui then
		break
	end
	warn("[LifeClient] âš ï¸ PlayerGui not found, attempt", attempt, "of", MAX_RETRIES)
	task.wait(1)
end

if not playerGui then
	error("[LifeClient] âŒ CRITICAL: PlayerGui not found after", MAX_RETRIES, "attempts! UI cannot initialize.")
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "BitLifeUI"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

local blurOverlay = Instance.new("Frame")
blurOverlay.Name = "BlurOverlay"
blurOverlay.Size = UDim2.fromScale(1, 1)
blurOverlay.BackgroundColor3 = C.Black
blurOverlay.BackgroundTransparency = 1
blurOverlay.ZIndex = 50
blurOverlay.Parent = screenGui

local function showBlur()
	tween(blurOverlay, TweenInfo.new(0.25), { BackgroundTransparency = 0.6 })
end

local function hideBlur()
	tween(blurOverlay, TweenInfo.new(0.25), { BackgroundTransparency = 1 })
end

----------------------------------------------------------------
-- MAIN CONTAINER
----------------------------------------------------------------

local mainContainer = Instance.new("Frame")
mainContainer.Name = "MainContainer"
mainContainer.Size = UDim2.fromScale(1, 1)
mainContainer.BackgroundColor3 = C.Gray100
mainContainer.BorderSizePixel = 0
mainContainer.ZIndex = 1
mainContainer.Parent = screenGui

----------------------------------------------------------------
-- SCREEN SHAKE EFFECT (for negative outcomes like BitLife)
----------------------------------------------------------------

local shakeActive = false

local function shakeScreen(intensity, duration)
	if shakeActive then return end
	shakeActive = true

	local originalPos = mainContainer.Position
	local elapsed = 0
	local shakeIntensity = intensity or 8

	task.spawn(function()
		while elapsed < (duration or 0.4) do
			local offsetX = math.random(-shakeIntensity, shakeIntensity)
			local offsetY = math.random(-shakeIntensity, shakeIntensity)
			mainContainer.Position = UDim2.new(
				originalPos.X.Scale, originalPos.X.Offset + offsetX,
				originalPos.Y.Scale, originalPos.Y.Offset + offsetY
			)
			task.wait(0.02)
			elapsed = elapsed + 0.02
			shakeIntensity = math.max(1, shakeIntensity - 0.5)
		end
		mainContainer.Position = originalPos
		shakeActive = false
	end)
end

----------------------------------------------------------------
-- FLASH OVERLAY (red for damage, green for good)
----------------------------------------------------------------

local flashOverlay = Instance.new("Frame")
flashOverlay.Size = UDim2.fromScale(1, 1)
flashOverlay.BackgroundColor3 = C.Red
flashOverlay.BackgroundTransparency = 1
flashOverlay.ZIndex = 100
flashOverlay.Name = "FlashOverlay"
flashOverlay.Parent = screenGui

local function flashScreen(color, intensity, duration)
	flashOverlay.BackgroundColor3 = color or C.Red
	flashOverlay.BackgroundTransparency = intensity or 0.7
	tween(flashOverlay, TweenInfo.new(duration or 0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		BackgroundTransparency = 1
	})
end

----------------------------------------------------------------
-- RESULT POPUP (BitLife-style card matching event modal)
----------------------------------------------------------------

local ResultUI = {
	overlay = nil,
	shadow = nil,
	shell = nil,
	card = nil,
	emoji = nil,
	title = nil,
	body = nil,
	okButton = nil,
	statsPreview = nil,
}
local resultVisible = false
local resultCallback = nil

-- Forward declare hideResultPopup
local hideResultPopup

local function createResultPopup()
	-- Overlay
	ResultUI.overlay = Instance.new("Frame")
	ResultUI.overlay.Name = "ResultOverlay"
	ResultUI.overlay.Size = UDim2.fromScale(1, 1)
	ResultUI.overlay.BackgroundColor3 = C.Black
	ResultUI.overlay.BackgroundTransparency = 0.45
	ResultUI.overlay.Visible = false
	ResultUI.overlay.ZIndex = 80
	ResultUI.overlay.Parent = screenGui

	-- TINY PHONE FIX: More compact popup width
	local popupWidth = modalWidth(320)
	
	-- CRITICAL FIX: Calculate max popup height to prevent going off screen
	local screenHeight = Device.ViewportSize.Y
	local topReserved = Device.IS_TINY_PHONE and 60 or (Device.IS_SMALL_PHONE and 70 or 80)
	local bottomReserved = Device.IS_TINY_PHONE and 40 or (Device.IS_SMALL_PHONE and 50 or 60)
	local maxPopupHeight = screenHeight - topReserved - bottomReserved
	
	-- Shadow frame (matches event modal) - thinner borders on tiny phones
	ResultUI.shadow = Instance.new("Frame")
	ResultUI.shadow.Size = UDim2.new(0, popupWidth, 0, 0)
	ResultUI.shadow.AutomaticSize = Enum.AutomaticSize.Y
	ResultUI.shadow.AnchorPoint = Vector2.new(0.5, 0.5)
	ResultUI.shadow.Position = UDim2.fromScale(0.5, 0.5)
	ResultUI.shadow.BackgroundColor3 = C.Black
	ResultUI.shadow.BackgroundTransparency = 0.92
	ResultUI.shadow.ZIndex = 81
	ResultUI.shadow.ClipsDescendants = true
	ResultUI.shadow.Parent = ResultUI.overlay
	corner(ResultUI.shadow, Device.IS_TINY_PHONE and 14 or px(28))
	
	-- Add max height constraint to prevent modal from going off screen
	local resultSizeConstraint = Instance.new("UISizeConstraint")
	resultSizeConstraint.MaxSize = Vector2.new(popupWidth, maxPopupHeight)
	resultSizeConstraint.Parent = ResultUI.shadow

	-- Green/Red shell - thinner on tiny phones
	local shellMargin = Device.IS_TINY_PHONE and 2 or 6
	ResultUI.shell = Instance.new("Frame")
	ResultUI.shell.Name = "ResultShell"
	ResultUI.shell.Size = UDim2.new(1, -shellMargin, 1, -shellMargin)
	ResultUI.shell.Position = UDim2.new(0, shellMargin/2, 0, shellMargin/2)
	ResultUI.shell.BackgroundColor3 = C.Green
	ResultUI.shell.ZIndex = 82
	ResultUI.shell.Parent = ResultUI.shadow
	corner(ResultUI.shell, Device.IS_TINY_PHONE and 12 or px(26))
	stroke(ResultUI.shell, Device.IS_TINY_PHONE and 1 or 2, 0.4, C.GreenDark)
	if not Device.IS_TINY_PHONE then
		createShadow(ResultUI.shell, 4, px(16), C.Black, 0.9)
	end

	-- Inner white card - thinner on tiny phones
	local cardMargin = Device.IS_TINY_PHONE and 4 or 10
	ResultUI.card = Instance.new("Frame")
	ResultUI.card.Name = "ResultCard"
	ResultUI.card.Size = UDim2.new(1, -cardMargin, 1, -cardMargin)
	ResultUI.card.Position = UDim2.new(0, cardMargin/2, 0, cardMargin/2)
	ResultUI.card.BackgroundColor3 = C.White
	ResultUI.card.ZIndex = 83
	ResultUI.card.ClipsDescendants = true
	ResultUI.card.Parent = ResultUI.shell
	corner(ResultUI.card, Device.IS_TINY_PHONE and 10 or px(22))

	local cardLayout = Instance.new("UIListLayout")
	cardLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	cardLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	cardLayout.SortOrder = Enum.SortOrder.LayoutOrder
	cardLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 4 or padSize(10))
	cardLayout.Parent = ResultUI.card
	local cardPad = Device.IS_TINY_PHONE and 6 or padSize(16)
	pad(ResultUI.card, cardPad, cardPad, cardPad, cardPad)

	-- Emoji - TINY PHONE FIX: MUCH smaller emoji to save space
	local emojiSize = Device.IS_TINY_PHONE and 28 or px(52)
	ResultUI.emoji = Instance.new("TextLabel")
	ResultUI.emoji.Size = UDim2.new(0, emojiSize, 0, emojiSize)
	ResultUI.emoji.BackgroundTransparency = 1
	ResultUI.emoji.Font = F.Body
	ResultUI.emoji.TextSize = Device.IS_TINY_PHONE and 22 or textSize(40)
	ResultUI.emoji.Text = "âœ¨"
	ResultUI.emoji.LayoutOrder = 1
	ResultUI.emoji.ZIndex = 84
	ResultUI.emoji.Parent = ResultUI.card

	-- Title - CRITICAL UI FIX: Smaller title on tiny phones
	ResultUI.title = Instance.new("TextLabel")
	ResultUI.title.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 22 or px(32))
	ResultUI.title.BackgroundTransparency = 1
	ResultUI.title.Font = F.Title
	ResultUI.title.TextSize = Device.IS_TINY_PHONE and 16 or textSize(24)
	ResultUI.title.TextColor3 = C.Gray900
	ResultUI.title.Text = "Result"
	ResultUI.title.TextWrapped = true
	ResultUI.title.LayoutOrder = 2
	ResultUI.title.ZIndex = 84
	ResultUI.title.Parent = ResultUI.card

	-- Body - CRITICAL UI FIX: Smaller text on tiny phones
	ResultUI.body = Instance.new("TextLabel")
	ResultUI.body.Size = UDim2.new(1, 0, 0, 0)
	ResultUI.body.AutomaticSize = Enum.AutomaticSize.Y
	ResultUI.body.BackgroundTransparency = 1
	ResultUI.body.Font = F.Body
	ResultUI.body.TextSize = Device.IS_TINY_PHONE and 13 or textSize(18)
	ResultUI.body.TextColor3 = C.Gray600
	ResultUI.body.TextWrapped = true
	ResultUI.body.TextXAlignment = Enum.TextXAlignment.Center
	ResultUI.body.LineHeight = Device.IS_TINY_PHONE and 1.25 or 1.4
	ResultUI.body.RichText = true
	ResultUI.body.Text = ""
	ResultUI.body.LayoutOrder = 3
	ResultUI.body.ZIndex = 84
	ResultUI.body.Parent = ResultUI.card

	-- Stats container - tighter on tiny phones
	ResultUI.statsPreview = Instance.new("Frame")
	ResultUI.statsPreview.Name = "StatsPreview"
	ResultUI.statsPreview.Size = UDim2.new(1, 0, 0, 0)
	ResultUI.statsPreview.AutomaticSize = Enum.AutomaticSize.Y
	ResultUI.statsPreview.BackgroundTransparency = 1
	ResultUI.statsPreview.LayoutOrder = 4
	ResultUI.statsPreview.ZIndex = 84
	ResultUI.statsPreview.Parent = ResultUI.card

	local statsLayout = Instance.new("UIListLayout")
	statsLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 2 or padSize(4))
	statsLayout.Parent = ResultUI.statsPreview

	-- OK Button - CRITICAL UI FIX: Smaller button on tiny phones
	local okBtnHeight = Device.IS_TINY_PHONE and 32 or btnHeight(40)
	ResultUI.okButton = Instance.new("TextButton")
	ResultUI.okButton.Size = UDim2.new(1, 0, 0, okBtnHeight)
	ResultUI.okButton.BackgroundColor3 = C.Green
	ResultUI.okButton.Font = F.Button
	ResultUI.okButton.TextSize = Device.IS_TINY_PHONE and 12 or textSize(14)
	ResultUI.okButton.TextColor3 = C.White
	ResultUI.okButton.Text = "Continue"
	ResultUI.okButton.AutoButtonColor = false
	ResultUI.okButton.LayoutOrder = 99
	ResultUI.okButton.ZIndex = 84
	ResultUI.okButton.Parent = ResultUI.card
	corner(ResultUI.okButton, Device.IS_TINY_PHONE and 8 or px(10))

	ResultUI.okButton.MouseEnter:Connect(function()
		tween(ResultUI.okButton, TweenInfo.new(0.1), { BackgroundColor3 = C.GreenDark })
	end)
	ResultUI.okButton.MouseLeave:Connect(function()
		tween(ResultUI.okButton, TweenInfo.new(0.1), { BackgroundColor3 = C.Green })
	end)

	ResultUI.okButton.MouseButton1Click:Connect(function()
		hideResultPopup()
		if resultCallback then
			resultCallback()
			resultCallback = nil
		end
	end)
end

hideResultPopup = function()
	if not ResultUI.overlay then return end
	resultVisible = false

	tween(ResultUI.shadow, TweenInfo.new(0.2), {
		Position = UDim2.new(0.5, 0, 0.5, 40),
		BackgroundTransparency = 1,
	})
	tween(ResultUI.shell, TweenInfo.new(0.2), { BackgroundTransparency = 1 })
	tween(ResultUI.card, TweenInfo.new(0.2), { BackgroundTransparency = 1 })

	task.delay(0.2, function()
		if ResultUI.overlay then
			ResultUI.overlay.Visible = false
		end
	end)
end

local function showResultPopup(data, callback)
	if not ResultUI.overlay then createResultPopup() end

	resultCallback = callback

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: PROPER isPositive detection for card border color
	-- User complaint: "bad cards have green border not red"
	-- Previous logic: isPositive = happiness >= 0 AND health >= 0 (defaults to TRUE!)
	-- NEW logic: Check ALL stat deltas and explicit flags properly
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	local isPositive
	if data.wasSuccess ~= nil then
		-- PRIORITY 1: Explicit success/fail flag from server (minigames, crimes)
		isPositive = data.wasSuccess
	elseif data.wasCaught ~= nil and data.wasCaught == true then
		-- PRIORITY 2: If caught (crime/activity), it's NEGATIVE
		isPositive = false
	elseif data.isNegative ~= nil then
		-- PRIORITY 3: Explicit negative flag
		isPositive = not data.isNegative
	else
		-- PRIORITY 4: Calculate based on actual stat changes
		-- If ANY major negative impact, treat as negative outcome
		local hasPositive = false
		local hasNegative = false
		
		-- Check all stat deltas
		local happiness = data.happiness or 0
		local health = data.health or 0
		local smarts = data.smarts or 0
		local looks = data.looks or 0
		local money = data.money or 0
		
		-- Negative indicators (significant losses)
		if happiness < -5 then hasNegative = true end
		if health < 0 then hasNegative = true end  -- ANY health loss is bad
		if money < -1000 then hasNegative = true end -- Significant money loss
		if looks < -5 then hasNegative = true end
		
		-- Positive indicators
		if happiness > 5 then hasPositive = true end
		if health > 0 then hasPositive = true end
		if money > 500 then hasPositive = true end
		if smarts > 3 then hasPositive = true end
		if looks > 3 then hasPositive = true end
		
		-- Determine outcome color
		if hasNegative and not hasPositive then
			isPositive = false
		elseif hasPositive and not hasNegative then
			isPositive = true
		elseif hasNegative and hasPositive then
			-- Mixed outcome - use net effect
			local netEffect = happiness + health + smarts + looks + (money / 1000)
			isPositive = netEffect >= 0
		else
			-- No significant changes either way - neutral (default to positive-ish)
			-- But check title/emoji for hints
			local title = data.title or ""
			local body = data.body or ""
			local titleLower = string.lower(title)
			local bodyLower = string.lower(body)
			
			-- Check for negative keywords
			if string.find(titleLower, "caught") or string.find(titleLower, "arrested") 
				or string.find(titleLower, "jail") or string.find(titleLower, "prison")
				or string.find(titleLower, "failed") or string.find(titleLower, "disaster")
				or string.find(titleLower, "death") or string.find(titleLower, "died")
				or string.find(bodyLower, "caught") or string.find(bodyLower, "arrested")
				or string.find(bodyLower, "sentenced") or string.find(bodyLower, "prison") then
				isPositive = false
			else
				isPositive = true
			end
		end
	end

	local shellColor = isPositive and C.Green or C.Red
	local shellStrokeColor = isPositive and C.GreenDark or C.RedDark

	ResultUI.shell.BackgroundColor3 = shellColor
	local shellStroke = ResultUI.shell:FindFirstChildOfClass("UIStroke")
	if shellStroke then shellStroke.Color = shellStrokeColor end
	ResultUI.okButton.BackgroundColor3 = shellColor

	ResultUI.emoji.Text = data.emoji or (isPositive and "âœ¨" or "ğŸ˜¢")
	ResultUI.title.Text = data.title or "What Happened"
	-- CRITICAL UI FIX: More descriptive default body text
	local bodyText = data.body or "Something happened, but the details are unclear."
	if bodyText == "" then
		bodyText = isPositive and "Things worked out in your favor!" or "That didn't go as planned..."
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: GUARANTEED OK BUTTON VISIBILITY!
	-- User bug: "I can't see the OK button" for driving test result
	-- Problem: Long text + stats pushed OK button off screen
	-- Solution: Calculate available space, reserve space for button, scale content
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local screenHeight = screenGui.AbsoluteSize.Y
	local topReserved = 60  -- Top of screen reserved
	local bottomReserved = 40  -- Bottom reserved
	local maxAvailableHeight = screenHeight - topReserved - bottomReserved
	
	-- Reserve space for fixed elements (emoji, title, button, padding, margins)
	local emojiHeight = Device.IS_TINY_PHONE and 28 or 52
	local titleHeight = Device.IS_TINY_PHONE and 22 or 32
	local okBtnHeight = Device.IS_TINY_PHONE and 32 or 40
	local paddingAndMargins = Device.IS_TINY_PHONE and 60 or 100  -- All padding, margins, layout gaps
	local reservedHeight = emojiHeight + titleHeight + okBtnHeight + paddingAndMargins
	
	-- Calculate max space for body text + stats
	local maxContentHeight = maxAvailableHeight - reservedHeight
	
	-- Count stats to estimate their height
	local statCount = 0
	if data.happiness and data.happiness ~= 0 then statCount = statCount + 1 end
	if data.health and data.health ~= 0 then statCount = statCount + 1 end
	if data.smarts and data.smarts ~= 0 then statCount = statCount + 1 end
	if data.looks and data.looks ~= 0 then statCount = statCount + 1 end
	if data.money and data.money ~= 0 then statCount = statCount + 1 end
	
	local statsHeight = statCount * (Device.IS_TINY_PHONE and 20 or 24)
	local maxBodyHeight = maxContentHeight - statsHeight - 20  -- 20 for stats padding
	
	-- Dynamic text sizing for long result text
	local textLen = #bodyText
	local baseResultTextSize = Device.IS_TINY_PHONE and 14 or textSize(18)
	local adjustedResultTextSize = baseResultTextSize
	local adjustedResultLineHeight = Device.IS_TINY_PHONE and 1.2 or 1.3
	
	-- Estimate lines of text and adjust sizing
	local charsPerLine = Device.IS_TINY_PHONE and 35 or 45
	local estimatedLines = math.ceil(textLen / charsPerLine)
	local lineHeight = adjustedResultTextSize * adjustedResultLineHeight
	local estimatedTextHeight = estimatedLines * lineHeight
	
	-- If text would overflow, progressively shrink
	if estimatedTextHeight > maxBodyHeight then
		-- Calculate scale factor needed
		local scaleFactor = maxBodyHeight / estimatedTextHeight
		scaleFactor = math.max(0.6, scaleFactor)  -- Don't go below 60%
		
		adjustedResultTextSize = math.max(10, math.floor(baseResultTextSize * scaleFactor))
		adjustedResultLineHeight = math.max(1.05, adjustedResultLineHeight * 0.9)
		
		-- If still too long after scaling, truncate the text
		local newEstimatedLines = maxBodyHeight / (adjustedResultTextSize * adjustedResultLineHeight)
		local maxChars = math.floor(newEstimatedLines * charsPerLine)
		
		if textLen > maxChars + 20 then
			-- Truncate with ellipsis
			bodyText = string.sub(bodyText, 1, maxChars) .. "..."
		end
	elseif textLen > 200 then
		-- Moderate length - slightly smaller
		adjustedResultTextSize = Device.IS_TINY_PHONE and 13 or 16
		adjustedResultLineHeight = 1.15
	elseif textLen > 120 then
		-- Slightly smaller for medium text
		adjustedResultTextSize = Device.IS_TINY_PHONE and 14 or 17
		adjustedResultLineHeight = 1.2
	end
	
	-- CRITICAL FIX: Use safe text size setter to prevent UITextSizeConstraint errors
	safeSetTextSize(ResultUI.body, adjustedResultTextSize)
	ResultUI.body.LineHeight = adjustedResultLineHeight
	ResultUI.body.Text = bodyText
	
	-- CRITICAL: Add max height constraint to body to GUARANTEE button visibility
	local bodySizeConstraint = ResultUI.body:FindFirstChildOfClass("UISizeConstraint")
	if not bodySizeConstraint then
		bodySizeConstraint = Instance.new("UISizeConstraint")
		bodySizeConstraint.Parent = ResultUI.body
	end
	bodySizeConstraint.MaxSize = Vector2.new(math.huge, math.max(50, maxBodyHeight))

	-- Clear old stat previews
	for _, child in ipairs(ResultUI.statsPreview:GetChildren()) do
		if child:IsA("Frame") then child:Destroy() end
	end

	-- Add stat changes (compact style)
	-- CRITICAL FIX: Smaller stat rows on mobile to ensure button visibility
	local statRowHeight = Device.IS_TINY_PHONE and 18 or (Device.IS_SMALL_PHONE and 20 or 24)
	local statTextSize = Device.IS_TINY_PHONE and 11 or (Device.IS_SMALL_PHONE and 12 or 14)
	
	local statChanges = {
		{ key = "Happiness", icon = "ğŸ˜€", delta = data.happiness },
		{ key = "Health", icon = "â¤ï¸", delta = data.health },
		{ key = "Smarts", icon = "ğŸ§ ", delta = data.smarts },
		{ key = "Looks", icon = "ğŸ’„", delta = data.looks },
	}

	for _, stat in ipairs(statChanges) do
		if stat.delta and stat.delta ~= 0 then
			local row = Instance.new("Frame")
			row.Size = UDim2.new(1, 0, 0, statRowHeight)
			row.BackgroundTransparency = 1
			row.ZIndex = 85
			row.Parent = ResultUI.statsPreview

			local lbl = Instance.new("TextLabel")
			lbl.Size = UDim2.new(0.5, 0, 1, 0)
			lbl.BackgroundTransparency = 1
			lbl.Font = F.Medium
			lbl.TextSize = statTextSize
			lbl.TextColor3 = C.Gray600
			lbl.TextXAlignment = Enum.TextXAlignment.Left
			lbl.Text = stat.icon .. " " .. stat.key
			lbl.ZIndex = 86
			lbl.Parent = row

			local val = Instance.new("TextLabel")
			val.Size = UDim2.new(0.5, 0, 1, 0)
			val.Position = UDim2.new(0.5, 0, 0, 0)
			val.BackgroundTransparency = 1
			val.Font = F.Title
			val.TextSize = statTextSize
			val.TextColor3 = stat.delta > 0 and C.Green or C.Red
			val.TextXAlignment = Enum.TextXAlignment.Right
			val.Text = (stat.delta > 0 and "+" or "") .. stat.delta
			val.ZIndex = 86
			val.Parent = row
		end
	end

	-- Money change (uses same compact sizing as stat rows)
	if data.money and data.money ~= 0 then
		local row = Instance.new("Frame")
		row.Size = UDim2.new(1, 0, 0, statRowHeight)
		row.BackgroundTransparency = 1
		row.ZIndex = 85
		row.Parent = ResultUI.statsPreview

		local lbl = Instance.new("TextLabel")
		lbl.Size = UDim2.new(0.5, 0, 1, 0)
		lbl.BackgroundTransparency = 1
		lbl.Font = F.Medium
		lbl.TextSize = statTextSize
		lbl.TextColor3 = C.Gray600
		lbl.TextXAlignment = Enum.TextXAlignment.Left
		lbl.Text = "ğŸ’µ Money"
		lbl.ZIndex = 86
		lbl.Parent = row

		local val = Instance.new("TextLabel")
		val.Size = UDim2.new(0.5, 0, 1, 0)
		val.Position = UDim2.new(0.5, 0, 0, 0)
		val.BackgroundTransparency = 1
		val.Font = F.Title
		val.TextSize = statTextSize
		val.TextColor3 = data.money > 0 and C.Green or C.Red
		val.TextXAlignment = Enum.TextXAlignment.Right
		val.Text = (data.money > 0 and "+" or "") .. formatMoney(data.money)
		val.ZIndex = 86
		val.Parent = row
	end

	-- Show with animation
	ResultUI.overlay.Visible = true
	ResultUI.shadow.Position = UDim2.new(0.5, 0, 0.5, 40)
	ResultUI.shadow.BackgroundTransparency = 1
	ResultUI.shell.BackgroundTransparency = 1
	ResultUI.card.BackgroundTransparency = 1
	
	tween(ResultUI.shadow, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Position = UDim2.fromScale(0.5, 0.5),
		BackgroundTransparency = 0.92,
	})
	tween(ResultUI.shell, TweenInfo.new(0.25), { BackgroundTransparency = 0 })
	tween(ResultUI.card, TweenInfo.new(0.25), { BackgroundTransparency = 0 })

	-- CRITICAL FIX: Visual feedback - BitLife style shake for negative outcomes
	-- More aggressive triggering for immersive gameplay feel
	local shouldShake = false
	local shouldFlash = false
	local shakeIntensity = 6
	
	-- Check for any negative outcomes
	if data.health and data.health < 0 then
		-- ANY health loss triggers shake
		shouldShake = true
		if data.health < -10 then
			-- Major health loss - bigger shake and flash
			shakeIntensity = 12
			shouldFlash = true
		elseif data.health < -5 then
			shakeIntensity = 8
			shouldFlash = true
		end
	end
	
	if data.happiness and data.happiness < -10 then
		-- Significant happiness loss - shake
		shouldShake = true
		shakeIntensity = math.max(shakeIntensity, 6)
	end
	
	if data.money and data.money < -1000 then
		-- Money loss > $1000 - subtle shake
		shouldShake = true
		if data.money < -10000 then
			shakeIntensity = math.max(shakeIntensity, 10)
		end
	end
	
	if data.wasSuccess == false then
		-- Explicit failure (minigame failed, driving test failed, etc)
		shouldShake = true
		shouldFlash = true
		shakeIntensity = math.max(shakeIntensity, 8)
	end
	
	-- Apply effects
	if shouldShake then
		shakeScreen(shakeIntensity, 0.25)
	end
	if shouldFlash then
		flashScreen(C.Red, 0.6, 0.3)
	end

	resultVisible = true
end

----------------------------------------------------------------
-- HEADER BAR (Offset to avoid Roblox logo)
----------------------------------------------------------------

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: Larger header for better visibility
-- User feedback: "THE JUST TOP LEFT JUST EVERYTHING SO LIKE SMALL"
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local HeaderUI = {}
HeaderUI.height = Device.IS_TINY_PHONE and 54 or (Device.IS_SMALL_PHONE and 62 or px(76))
HeaderUI.topOffset = Device.IS_TINY_PHONE and 30 or px(42)  -- Slight adjustment for larger header

;(function() -- CRITICAL FIX #253: IIFE for header construction (do-blocks don't reduce register count)
local headerBar = Instance.new("Frame")
headerBar.Name = "Header"
headerBar.Size = UDim2.new(1, -padSize(12), 0, HeaderUI.height)
headerBar.Position = UDim2.new(0, padSize(6), 0, HeaderUI.topOffset)
headerBar.BackgroundColor3 = C.White
headerBar.ZIndex = 5
headerBar.Parent = mainContainer
corner(headerBar, Device.IS_TINY_PHONE and 12 or px(18))
HeaderUI.bar = headerBar

-- subtle shadow - skip on tiny phones for cleaner look
local headerShadow = Instance.new("Frame")
headerShadow.Size = UDim2.new(1, 4, 0, HeaderUI.height + 4)
headerShadow.Position = UDim2.new(0, padSize(4), 0, HeaderUI.topOffset + 2)
headerShadow.BackgroundColor3 = C.Black
headerShadow.BackgroundTransparency = Device.IS_TINY_PHONE and 0.98 or 0.95
headerShadow.ZIndex = 4
headerShadow.Parent = mainContainer
corner(headerShadow, Device.IS_TINY_PHONE and 14 or px(20))

-- CRITICAL FIX: Larger avatar for better visibility
local avatarSize = Device.IS_TINY_PHONE and 38 or (Device.IS_SMALL_PHONE and 44 or px(56))
local avatarCircle = Instance.new("Frame")
avatarCircle.Size = UDim2.new(0, avatarSize, 0, avatarSize)
avatarCircle.Position = UDim2.new(0, Device.IS_TINY_PHONE and 8 or padSize(14), 0.5, -avatarSize/2)
avatarCircle.BackgroundColor3 = C.BluePale
avatarCircle.ZIndex = 6
avatarCircle.Parent = HeaderUI.bar
corner(avatarCircle, avatarSize/2)
stroke(avatarCircle, Device.IS_TINY_PHONE and 1 or 2, 0.5, C.BlueLight)

HeaderUI.avatarEmoji = Instance.new("TextLabel")
HeaderUI.avatarEmoji.Size = UDim2.fromScale(1, 1)
HeaderUI.avatarEmoji.BackgroundTransparency = 1
HeaderUI.avatarEmoji.Font = F.Body
HeaderUI.avatarEmoji.TextSize = Device.IS_TINY_PHONE and 18 or textSize(26)
HeaderUI.avatarEmoji.Text = "ğŸ‘¶"
HeaderUI.avatarEmoji.ZIndex = 7
HeaderUI.avatarEmoji.Parent = avatarCircle

-- TINY PHONE FIX: Tighter name container
local nameOffset = avatarSize + (Device.IS_TINY_PHONE and 12 or padSize(24))
local nameContainer = Instance.new("Frame")
nameContainer.Size = UDim2.new(0.5, -nameOffset, 1, 0)
nameContainer.Position = UDim2.new(0, nameOffset, 0, 0)
nameContainer.BackgroundTransparency = 1
nameContainer.ZIndex = 6
nameContainer.Parent = HeaderUI.bar

HeaderUI.nameLabel = Instance.new("TextLabel")
HeaderUI.nameLabel.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 16 or px(24))
HeaderUI.nameLabel.Position = UDim2.new(0, 0, 0.5, Device.IS_TINY_PHONE and -10 or px(-14))
HeaderUI.nameLabel.BackgroundTransparency = 1
HeaderUI.nameLabel.Font = F.Title
HeaderUI.nameLabel.TextSize = Device.IS_TINY_PHONE and 13 or textSize(17)
HeaderUI.nameLabel.TextColor3 = C.Gray900
HeaderUI.nameLabel.TextXAlignment = Enum.TextXAlignment.Left
HeaderUI.nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
HeaderUI.nameLabel.Text = "New Life"
HeaderUI.nameLabel.ZIndex = 7
HeaderUI.nameLabel.Parent = nameContainer

HeaderUI.ageYearLabel = Instance.new("TextLabel")
HeaderUI.ageYearLabel.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 12 or px(16))
HeaderUI.ageYearLabel.Position = UDim2.new(0, 0, 0.5, Device.IS_TINY_PHONE and 4 or padSize(8))
HeaderUI.ageYearLabel.BackgroundTransparency = 1
HeaderUI.ageYearLabel.Font = F.Body
HeaderUI.ageYearLabel.TextSize = Device.IS_TINY_PHONE and 10 or textSize(12)
HeaderUI.ageYearLabel.TextColor3 = C.Gray500
HeaderUI.ageYearLabel.TextXAlignment = Enum.TextXAlignment.Left
HeaderUI.ageYearLabel.Text = "Age 0 â€¢ 2025"
HeaderUI.ageYearLabel.ZIndex = 7
HeaderUI.ageYearLabel.Parent = nameContainer

-- TINY PHONE FIX: Smaller money display
local moneyWidth = Device.IS_TINY_PHONE and 70 or (Device.IS_SMALL_PHONE and 85 or px(110))
local moneyHeight = Device.IS_TINY_PHONE and 32 or btnHeight(44)
local moneyContainer = Instance.new("Frame")
moneyContainer.Size = UDim2.new(0, moneyWidth, 0, moneyHeight)
moneyContainer.AnchorPoint = Vector2.new(1, 0.5)
moneyContainer.Position = UDim2.new(1, Device.IS_TINY_PHONE and -6 or -padSize(12), 0.5, 0)
moneyContainer.BackgroundColor3 = C.GreenPale
moneyContainer.ZIndex = 6
moneyContainer.Parent = HeaderUI.bar
corner(moneyContainer, Device.IS_TINY_PHONE and 8 or px(14))
stroke(moneyContainer, Device.IS_TINY_PHONE and 1 or 2, 0.6, C.Green)

local moneyIcon = Instance.new("TextLabel")
moneyIcon.Size = UDim2.new(0, Device.IS_TINY_PHONE and 20 or px(30), 1, 0)
moneyIcon.BackgroundTransparency = 1
moneyIcon.Font = F.Body
moneyIcon.TextSize = Device.IS_TINY_PHONE and 14 or textSize(20)
moneyIcon.Text = "ğŸ’µ"
moneyIcon.ZIndex = 7
moneyIcon.Parent = moneyContainer

HeaderUI.moneyLabel = Instance.new("TextLabel")
HeaderUI.moneyLabel.Size = UDim2.new(1, Device.IS_TINY_PHONE and -22 or -px(34), 1, 0)
HeaderUI.moneyLabel.Position = UDim2.new(0, Device.IS_TINY_PHONE and 20 or px(30), 0, 0)
HeaderUI.moneyLabel.BackgroundTransparency = 1
HeaderUI.moneyLabel.Font = F.Title
HeaderUI.moneyLabel.TextSize = textSize(15)
HeaderUI.moneyLabel.TextColor3 = C.GreenDark
HeaderUI.moneyLabel.TextXAlignment = Enum.TextXAlignment.Left
HeaderUI.moneyLabel.Text = "$0"
HeaderUI.moneyLabel.ZIndex = 7
HeaderUI.moneyLabel.Parent = moneyContainer
end)() -- CRITICAL FIX #253: End header construction IIFE

-- CRITICAL FIX #253: Aliases removed - use HeaderUI.avatarEmoji, HeaderUI.nameLabel, etc.
-- These are set below after the do-block for backward compatibility
local avatarEmoji, nameLabel, ageYearLabel, moneyLabel, headerBar
avatarEmoji = HeaderUI.avatarEmoji
nameLabel = HeaderUI.nameLabel
ageYearLabel = HeaderUI.ageYearLabel
moneyLabel = HeaderUI.moneyLabel
headerBar = HeaderUI.bar

----------------------------------------------------------------
-- LIFE FEED AREA - TINY PHONE FIX: More compact layout
----------------------------------------------------------------

-- Calculate feed container position based on header
local feedTop = HeaderUI.topOffset + HeaderUI.height + (Device.IS_TINY_PHONE and 4 or padSize(8))
-- Nav height varies by device - smaller on tiny phones
local navHeight = Device.IS_TINY_PHONE and 50 or (Device.IS_SMALL_PHONE and 55 or px(65))
local feedBottomOffset = navHeight + (Device.IS_TINY_PHONE and 140 or px(200)) -- Nav + stats + premium row + age button

local feedContainer = Instance.new("Frame")
feedContainer.Name = "FeedContainer"
feedContainer.Size = UDim2.new(1, -padSize(12), 1, -feedTop - feedBottomOffset)
feedContainer.Position = UDim2.new(0, padSize(6), 0, feedTop)
feedContainer.BackgroundColor3 = C.White
feedContainer.ZIndex = 3
feedContainer.Parent = mainContainer
corner(feedContainer, Device.IS_TINY_PHONE and 10 or px(16))
local feedPad = Device.IS_TINY_PHONE and 8 or padSize(14)
pad(feedContainer, feedPad, feedPad, Device.IS_TINY_PHONE and 6 or padSize(12), Device.IS_TINY_PHONE and 6 or padSize(12))

local feedScroll = Instance.new("ScrollingFrame")
feedScroll.Size = UDim2.fromScale(1, 1)
feedScroll.BackgroundTransparency = 1
feedScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
feedScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
feedScroll.ScrollBarThickness = Device.IS_MOBILE and 6 or 3  -- MOBILE FIX: Thicker scrollbar for touch
feedScroll.ScrollBarImageColor3 = C.Gray300
feedScroll.ScrollingDirection = Enum.ScrollingDirection.Y
feedScroll.Parent = feedContainer

local feedLayout = Instance.new("UIListLayout")
feedLayout.Padding = UDim.new(0, padSize(8))
feedLayout.SortOrder = Enum.SortOrder.LayoutOrder
feedLayout.Parent = feedScroll

local feedEntryCount = 0

local function addFeedEntry(text)
	if not text or text == "" then return end
	feedEntryCount += 1

	local entry = Instance.new("Frame")
	entry.Size = UDim2.new(1, 0, 0, 0)
	entry.AutomaticSize = Enum.AutomaticSize.Y
	entry.BackgroundColor3 = C.Gray50
	entry.LayoutOrder = feedEntryCount
	entry.Parent = feedScroll
	corner(entry, 10)
	pad(entry, 12, 12, 10, 10)

	local isAge = text:match("years old")

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 0, 0)
	label.AutomaticSize = Enum.AutomaticSize.Y
	label.BackgroundTransparency = 1
	label.Font = isAge and F.Title or F.Body
	label.TextSize = isAge and 14 or 13
	label.TextColor3 = isAge and C.Blue or C.Gray700
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.TextWrapped = true
	label.Text = text
	label.Parent = entry

	entry.BackgroundTransparency = 1
	label.TextTransparency = 1
	tween(entry, TweenInfo.new(0.2), { BackgroundTransparency = 0 })
	tween(label, TweenInfo.new(0.2), { TextTransparency = 0 })

	task.defer(function()
		feedScroll.CanvasPosition = Vector2.new(
			0,
			math.max(0, feedScroll.AbsoluteCanvasSize.Y - feedScroll.AbsoluteWindowSize.Y)
		)
	end)
end

----------------------------------------------------------------
-- BOTTOM SECTION: Stats + Nav + Age Button - TINY PHONE FIX
----------------------------------------------------------------

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: Stats row positioning - sits directly above age button
-- User feedback: "THE HAPPYNESS HEALTH, LOOKS, SMARTS STATS BAR IS FLOATING UP"
-- Solution: Calculate exact position based on where age button top is
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Match the nav bar and age button calculations exactly
local calcNavHeight = Device.IS_TINY_PHONE and 55 or (Device.IS_SMALL_PHONE and 65 or px(85))
local calcAgeBtnSize = Device.IS_TINY_PHONE and 54 or (Device.IS_SMALL_PHONE and 65 or px(90))
local calcAgeBtnOffset = Device.IS_TINY_PHONE and 6 or padSize(10)

-- Age button center is at: navHeight/2 + offset from bottom
-- Age button TOP is at: navHeight/2 + offset + ageBtnSize/2
-- Stats row should sit right above it with small gap (4-6px)
local ageBtnTopFromBottom = (calcNavHeight / 2) + calcAgeBtnOffset + (calcAgeBtnSize / 2)
local statsGapFromAgeBtn = Device.IS_TINY_PHONE and 4 or 6

local statsRowHeight = Device.IS_TINY_PHONE and 42 or (Device.IS_SMALL_PHONE and 50 or 58)
local statsRowBottom = ageBtnTopFromBottom + statsGapFromAgeBtn
local statsGap = Device.IS_TINY_PHONE and 32 or (Device.IS_SMALL_PHONE and 40 or 55)

local statsRow = Instance.new("Frame")
statsRow.Name = "StatsRow"
statsRow.Size = UDim2.new(1, -12, 0, statsRowHeight)
statsRow.AnchorPoint = Vector2.new(0.5, 1)
statsRow.Position = UDim2.new(0.5, 0, 1, -statsRowBottom)
statsRow.BackgroundColor3 = C.White
statsRow.ZIndex = 8
statsRow.Parent = mainContainer
corner(statsRow, Device.IS_TINY_PHONE and 10 or 14)
stroke(statsRow, 1, 0.85, C.Gray200)

-- left stats
local statsLeft = Instance.new("Frame")
statsLeft.Name = "StatsLeft"
statsLeft.Size = UDim2.new(0.5, -statsGap, 1, 0)
statsLeft.Position = UDim2.new(0, 0, 0, 0)
statsLeft.BackgroundTransparency = 1
statsLeft.ZIndex = 9
statsLeft.Parent = statsRow
pad(statsLeft, Device.IS_TINY_PHONE and 4 or 8, Device.IS_TINY_PHONE and 4 or 8, Device.IS_TINY_PHONE and 4 or 6, Device.IS_TINY_PHONE and 4 or 6)

local statsLeftLayout = Instance.new("UIListLayout")
statsLeftLayout.FillDirection = Enum.FillDirection.Horizontal
statsLeftLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
statsLeftLayout.VerticalAlignment = Enum.VerticalAlignment.Center
statsLeftLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 3 or 6)
statsLeftLayout.Parent = statsLeft

-- right stats
local statsRight = Instance.new("Frame")
statsRight.Name = "StatsRight"
statsRight.Size = UDim2.new(0.5, -statsGap, 1, 0)
statsRight.Position = UDim2.new(0.5, statsGap, 0, 0)
statsRight.BackgroundTransparency = 1
statsRight.ZIndex = 9
statsRight.Parent = statsRow
pad(statsRight, Device.IS_TINY_PHONE and 4 or 8, Device.IS_TINY_PHONE and 4 or 8, Device.IS_TINY_PHONE and 4 or 6, Device.IS_TINY_PHONE and 4 or 6)

local statsRightLayout = Instance.new("UIListLayout")
statsRightLayout.FillDirection = Enum.FillDirection.Horizontal
statsRightLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
statsRightLayout.VerticalAlignment = Enum.VerticalAlignment.Center
statsRightLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 3 or 6)
statsRightLayout.Parent = statsRight

local statCards = {}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: Larger stat cards for better visibility
-- User feedback: "THE JUST TOP LEFT JUST EVERYTHING SO LIKE SMALL"
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local statCardWidth = Device.IS_TINY_PHONE and 62 or (Device.IS_SMALL_PHONE and 70 or 86)
local statCardHeight = Device.IS_TINY_PHONE and 34 or (Device.IS_SMALL_PHONE and 40 or 48)

local function createStatCard(info, parent, order)
	local statCard = Instance.new("Frame")
	statCard.Name = "Stat_" .. info.key
	statCard.Size = UDim2.new(0, statCardWidth, 0, statCardHeight)
	statCard.BackgroundColor3 = C.Gray50
	statCard.LayoutOrder = order
	statCard.ZIndex = 10
	statCard.Parent = parent
	corner(statCard, Device.IS_TINY_PHONE and 6 or 10)

	-- CRITICAL FIX: Larger icons and text for stat cards
	local iconLbl = Instance.new("TextLabel")
	iconLbl.Size = UDim2.new(0, Device.IS_TINY_PHONE and 18 or (Device.IS_SMALL_PHONE and 22 or 26), 0, Device.IS_TINY_PHONE and 18 or (Device.IS_SMALL_PHONE and 22 or 26))
	iconLbl.Position = UDim2.new(0, Device.IS_TINY_PHONE and 3 or 5, 0, Device.IS_TINY_PHONE and 3 or 4)
	iconLbl.BackgroundTransparency = 1
	iconLbl.Font = F.Body
	iconLbl.TextSize = Device.IS_TINY_PHONE and 13 or (Device.IS_SMALL_PHONE and 16 or 18)
	iconLbl.Text = info.icon
	iconLbl.ZIndex = 11
	iconLbl.Parent = statCard

	local percentLbl = Instance.new("TextLabel")
	percentLbl.Name = "Percent"
	percentLbl.Size = UDim2.new(0, Device.IS_TINY_PHONE and 32 or (Device.IS_SMALL_PHONE and 40 or 48), 0, Device.IS_TINY_PHONE and 14 or (Device.IS_SMALL_PHONE and 18 or 22))
	percentLbl.Position = UDim2.new(0, Device.IS_TINY_PHONE and 22 or (Device.IS_SMALL_PHONE and 28 or 32), 0, Device.IS_TINY_PHONE and 3 or 5)
	percentLbl.BackgroundTransparency = 1
	percentLbl.Font = F.Title
	percentLbl.TextSize = Device.IS_TINY_PHONE and 11 or (Device.IS_SMALL_PHONE and 13 or 15)
	percentLbl.TextColor3 = info.col
	percentLbl.TextXAlignment = Enum.TextXAlignment.Left
	percentLbl.Text = "100%"
	percentLbl.ZIndex = 11
	percentLbl.Parent = statCard

	local barBg = Instance.new("Frame")
	barBg.Size = UDim2.new(1, Device.IS_TINY_PHONE and -8 or -12, 0, Device.IS_TINY_PHONE and 5 or (Device.IS_SMALL_PHONE and 6 or 8))
	barBg.Position = UDim2.new(0, Device.IS_TINY_PHONE and 4 or 6, 1, Device.IS_TINY_PHONE and -9 or -14)
	barBg.BackgroundColor3 = C.Gray200
	barBg.ZIndex = 11
	barBg.Parent = statCard
	corner(barBg, Device.IS_TINY_PHONE and 2 or 3)

	local barFill = Instance.new("Frame")
	barFill.Name = "Fill"
	barFill.Size = UDim2.new(1, 0, 1, 0)
	barFill.BackgroundColor3 = info.col
	barFill.ZIndex = 12
	barFill.Parent = barBg
	corner(barFill, Device.IS_TINY_PHONE and 2 or 3)

	statCards[info.key] = {
		percentLabel = percentLbl,
		barFill      = barFill,
		color        = info.col,
	}
	return statCard
end

createStatCard({ key = "Happiness", icon = "ğŸ˜€", col = C.Green  }, statsLeft, 1)
createStatCard({ key = "Health",    icon = "â¤ï¸", col = C.Red    }, statsLeft, 2)
createStatCard({ key = "Smarts",    icon = "ğŸ§ ", col = C.Purple }, statsRight, 1)
createStatCard({ key = "Looks",     icon = "ğŸ’„", col = C.Pink   }, statsRight, 2)

----------------------------------------------------------------
-- GOD MODE IN-GAME EDITOR
-- CRITICAL FIX #162: Re-enabled God Mode for in-game stat editing
-- Allows players to edit stats, cure diseases, remove addictions, etc.
-- CRITICAL FIX: Wrapped in IIFE to reduce local register usage
----------------------------------------------------------------

;(function()
-- God Mode overlay for in-game editing
godModeOverlay = Instance.new("Frame")
godModeOverlay.Name = "GodModeOverlay"
godModeOverlay.Size = UDim2.fromScale(1, 1)
godModeOverlay.BackgroundColor3 = Color3.new(0, 0, 0)
godModeOverlay.BackgroundTransparency = 0.35
godModeOverlay.Visible = false
godModeOverlay.ZIndex = 150
godModeOverlay.Parent = mainContainer

-- CRITICAL FIX #163 & #275: Create God Mode Button in header area
-- CRITICAL FIX #275: Better mobile positioning - centered in header right side
-- CRITICAL FIX #317: Moved button LEFT to avoid overlapping cash display
local godModeBtnSize = Device.IS_TINY_PHONE and 28 or (Device.IS_SMALL_PHONE and 30 or 34)
godModeButton = Instance.new("TextButton")
godModeButton.Name = "GodModeBtn"
godModeButton.Size = UDim2.new(0, godModeBtnSize, 0, godModeBtnSize)
-- Position: More to the left to avoid cash overlap - increased offset significantly
local godModeBtnOffset = Device.IS_TINY_PHONE and 95 or (Device.IS_SMALL_PHONE and 110 or 140)
godModeButton.Position = UDim2.new(1, -(godModeBtnSize + godModeBtnOffset), 0.5, 0)
godModeButton.AnchorPoint = Vector2.new(0, 0.5) -- Center vertically
godModeButton.BackgroundColor3 = Color3.fromRGB(253, 230, 138)
godModeButton.Text = "âš¡"
godModeButton.TextSize = Device.IS_TINY_PHONE and 16 or 18
godModeButton.ZIndex = 8
godModeButton.Visible = false -- Hidden by default, shown if hasGodMode
godModeButton.Parent = headerBar
corner(godModeButton, godModeBtnSize/2)
stroke(godModeButton, 2, 0, Color3.fromRGB(217, 119, 6))

-- God Mode button hover effect
godModeButton.MouseEnter:Connect(function()
	godModeButton.BackgroundColor3 = Color3.fromRGB(252, 211, 77)
end)
godModeButton.MouseLeave:Connect(function()
	godModeButton.BackgroundColor3 = Color3.fromRGB(253, 230, 138)
end)

-- Update God Mode button visibility
updateGodModeButtonAppearance = function()
	refreshGodModeStatus()
	if godModeButton then
		godModeButton.Visible = hasGodMode
	end
end

-- Create the God Mode Modal
-- CRITICAL FIX #316: Wider modal to fit buttons properly
local godModeModal = Instance.new("Frame")
godModeModal.Name = "GodModeModal"
godModeModal.Size = UDim2.new(0, Device.IS_TINY_PHONE and 320 or 420, 0, 0)
godModeModal.AutomaticSize = Enum.AutomaticSize.Y
godModeModal.AnchorPoint = Vector2.new(0.5, 0.5)
godModeModal.Position = UDim2.new(0.5, 0, 0.5, 0)
godModeModal.BackgroundColor3 = C.White
godModeModal.ZIndex = 151
godModeModal.Parent = godModeOverlay
corner(godModeModal, 16)
stroke(godModeModal, 1, 0.85, C.Gray200)

-- CRITICAL FIX #316: More padding for better layout
local modalPad = Instance.new("UIPadding")
modalPad.PaddingTop = UDim.new(0, 16)
modalPad.PaddingBottom = UDim.new(0, 16)
modalPad.PaddingLeft = UDim.new(0, 20)
modalPad.PaddingRight = UDim.new(0, 20)
modalPad.Parent = godModeModal

local modalScroll = Instance.new("ScrollingFrame")
modalScroll.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 350 or 450)
modalScroll.BackgroundTransparency = 1
modalScroll.ScrollBarThickness = 4
modalScroll.CanvasSize = UDim2.new(1, 0, 0, 0)
modalScroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
modalScroll.ZIndex = 152
modalScroll.Parent = godModeModal

local modalLayout = Instance.new("UIListLayout")
modalLayout.FillDirection = Enum.FillDirection.Vertical
modalLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
modalLayout.Padding = UDim.new(0, 10)
modalLayout.Parent = modalScroll

-- Title
local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(1, 0, 0, 30)
titleLabel.BackgroundTransparency = 1
titleLabel.Font = F.Title
titleLabel.TextSize = textSize(20)
titleLabel.TextColor3 = C.Gray800
titleLabel.Text = "âš¡ God Mode Editor"
titleLabel.ZIndex = 153
titleLabel.LayoutOrder = 0
titleLabel.Parent = modalScroll

-- Subtitle
local subtitleLabel = Instance.new("TextLabel")
subtitleLabel.Size = UDim2.new(1, 0, 0, 20)
subtitleLabel.BackgroundTransparency = 1
subtitleLabel.Font = F.Body
subtitleLabel.TextSize = textSize(12)
subtitleLabel.TextColor3 = C.Gray500
subtitleLabel.Text = "Edit stats, cure diseases, and more!"
subtitleLabel.ZIndex = 153
subtitleLabel.LayoutOrder = 1
subtitleLabel.Parent = modalScroll

-- STAT SLIDERS SECTION
local statSection = Instance.new("Frame")
statSection.Size = UDim2.new(1, 0, 0, 0)
statSection.AutomaticSize = Enum.AutomaticSize.Y
statSection.BackgroundTransparency = 1
statSection.ZIndex = 152
statSection.LayoutOrder = 2
statSection.Parent = modalScroll

local statLayout = Instance.new("UIListLayout")
statLayout.Padding = UDim.new(0, 8)
statLayout.Parent = statSection

local godModeStatInputs = {}
local stats = {
	{ key = "Happiness", emoji = "ğŸ˜Š", color = C.Yellow },
	{ key = "Health", emoji = "â¤ï¸", color = C.Red },
	{ key = "Smarts", emoji = "ğŸ§ ", color = C.Purple },
	{ key = "Looks", emoji = "ğŸ’„", color = C.Pink },
}

for i, stat in ipairs(stats) do
	local row = Instance.new("Frame")
	-- CRITICAL FIX: Better row sizing for mobile
	local rowHeight = Device.IS_TINY_PHONE and 36 or 42
	row.Size = UDim2.new(1, 0, 0, rowHeight)
	row.BackgroundTransparency = 1
	row.LayoutOrder = i
	row.ZIndex = 153
	row.Parent = statSection
	
	local lbl = Instance.new("TextLabel")
	-- CRITICAL FIX: Responsive label width for mobile
	local lblWidth = Device.IS_TINY_PHONE and 70 or 85
	lbl.Size = UDim2.new(0, lblWidth, 1, 0)
	lbl.BackgroundTransparency = 1
	lbl.Font = F.Medium
	lbl.TextSize = Device.IS_TINY_PHONE and 12 or 14
	lbl.TextColor3 = C.Gray700
	lbl.TextXAlignment = Enum.TextXAlignment.Left
	lbl.Text = stat.emoji .. " " .. stat.key
	lbl.ZIndex = 154
	lbl.Parent = row
	
	local sliderBg = Instance.new("Frame")
	-- CRITICAL FIX: Better slider positioning for mobile - centered vertically
	local sliderOffset = Device.IS_TINY_PHONE and 75 or 90
	local sliderPadding = Device.IS_TINY_PHONE and 115 or 135
	local sliderHeight = Device.IS_TINY_PHONE and 18 or 22
	sliderBg.Size = UDim2.new(1, -sliderPadding, 0, sliderHeight)
	sliderBg.Position = UDim2.new(0, sliderOffset, 0.5, -sliderHeight/2)
	sliderBg.BackgroundColor3 = C.Gray200
	sliderBg.ZIndex = 154
	sliderBg.Parent = row
	corner(sliderBg, 6)
	
	local sliderFill = Instance.new("Frame")
	sliderFill.Size = UDim2.new(0.5, 0, 1, 0)
	sliderFill.BackgroundColor3 = stat.color
	sliderFill.ZIndex = 155
	sliderFill.Parent = sliderBg
	corner(sliderFill, 6)
	
	local valInput = Instance.new("TextBox")
	-- CRITICAL FIX: Better input box sizing for mobile - properly centered
	local inputW = Device.IS_TINY_PHONE and 36 or 42
	local inputH = Device.IS_TINY_PHONE and 24 or 30
	valInput.Size = UDim2.new(0, inputW, 0, inputH)
	valInput.Position = UDim2.new(1, -inputW, 0.5, -inputH/2)
	valInput.AnchorPoint = Vector2.new(0, 0) -- Explicitly anchor top-left
	valInput.BackgroundColor3 = C.Gray100
	valInput.Font = F.Medium
	valInput.TextSize = Device.IS_TINY_PHONE and 12 or 14
	valInput.TextColor3 = C.Gray800
	valInput.Text = "50"
	valInput.ZIndex = 154
	valInput.Parent = row
	corner(valInput, 6)
	
	godModeStatInputs[stat.key] = { input = valInput, fill = sliderFill, bg = sliderBg }
	
	-- Slider drag functionality
	local dragging = false
	sliderBg.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
		end
	end)
	sliderBg.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = false
		end
	end)
	sliderBg.InputChanged:Connect(function(input)
		if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
			local relX = math.clamp((input.Position.X - sliderBg.AbsolutePosition.X) / sliderBg.AbsoluteSize.X, 0, 1)
			local newVal = math.floor(relX * 100)
			valInput.Text = tostring(newVal)
			sliderFill.Size = UDim2.new(relX, 0, 1, 0)
		end
	end)
	
	valInput.FocusLost:Connect(function()
		local val = math.clamp(tonumber(valInput.Text) or 50, 0, 100)
		valInput.Text = tostring(val)
		sliderFill.Size = UDim2.new(val/100, 0, 1, 0)
	end)
end

-- QUICK ACTIONS SECTION
local actionsTitle = Instance.new("TextLabel")
actionsTitle.Size = UDim2.new(1, 0, 0, 30)
actionsTitle.BackgroundTransparency = 1
actionsTitle.Font = F.Title
actionsTitle.TextSize = textSize(16)
actionsTitle.TextColor3 = C.Gray700
actionsTitle.Text = "ğŸ› ï¸ Quick Actions"
actionsTitle.ZIndex = 153
actionsTitle.LayoutOrder = 3
actionsTitle.Parent = modalScroll

-- CRITICAL FIX: Wrapper frame to center the grid
local actionsGridWrapper = Instance.new("Frame")
actionsGridWrapper.Size = UDim2.new(1, 0, 0, 0)
actionsGridWrapper.AutomaticSize = Enum.AutomaticSize.Y
actionsGridWrapper.BackgroundTransparency = 1
actionsGridWrapper.ZIndex = 152
actionsGridWrapper.LayoutOrder = 4
actionsGridWrapper.Parent = modalScroll

local actionsGrid = Instance.new("Frame")
actionsGrid.Size = UDim2.new(1, 0, 0, 0)
actionsGrid.AutomaticSize = Enum.AutomaticSize.Y
actionsGrid.BackgroundTransparency = 1
actionsGrid.ZIndex = 152
actionsGrid.AnchorPoint = Vector2.new(0.5, 0) -- CRITICAL FIX: Center anchor
actionsGrid.Position = UDim2.new(0.5, 0, 0, 0) -- CRITICAL FIX: Center position
actionsGrid.Parent = actionsGridWrapper

-- CRITICAL FIX: Better grid layout for mobile - properly centered cells
local gridLayout = Instance.new("UIGridLayout")
-- CRITICAL FIX: Calculate cell width based on modal width minus padding (20 on each side = 40 total)
-- Modal is 320 on tiny, 420 on regular. Minus 40 padding = 280 or 380 usable
local usableWidth = Device.IS_TINY_PHONE and 280 or 380
local cellPad = 8
-- Two columns: usableWidth = 2*cellWidth + cellPad
local cellWidth = math.floor((usableWidth - cellPad) / 2)
local cellHeight = Device.IS_TINY_PHONE and 48 or 52
gridLayout.CellSize = UDim2.new(0, cellWidth, 0, cellHeight)
gridLayout.CellPadding = UDim2.new(0, cellPad, 0, cellPad)
-- CRITICAL FIX: Center the grid horizontally
gridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
gridLayout.VerticalAlignment = Enum.VerticalAlignment.Top
gridLayout.FillDirection = Enum.FillDirection.Horizontal
gridLayout.FillDirectionMaxCells = 2 -- 2 columns
gridLayout.SortOrder = Enum.SortOrder.LayoutOrder
gridLayout.Parent = actionsGrid

-- CRITICAL FIX #164 + #183: Quick action buttons for God Mode - Expanded list
local quickActions = {
	{ id = "cure_diseases", emoji = "ğŸ’Š", name = "Cure Diseases", desc = "Remove all illnesses" },
	{ id = "remove_addictions", emoji = "ğŸš­", name = "No Addictions", desc = "Remove all addictions" },
	{ id = "clear_record", emoji = "ğŸ“‹", name = "Clear Record", desc = "Erase criminal record" },
	{ id = "max_stats", emoji = "â¬†ï¸", name = "Max Stats", desc = "Set all stats to 100" },
	{ id = "clear_debt", emoji = "ğŸ’³", name = "Clear Debt", desc = "Erase all debts" },
	{ id = "full_heal", emoji = "â¤ï¸", name = "Full Heal", desc = "Restore health to 100" },
	{ id = "max_relationships", emoji = "ğŸ’•", name = "Max Relations", desc = "Max all relationships" },
	{ id = "jail_break", emoji = "ğŸ”“", name = "Jail Break", desc = "Get out of jail free" },
	{ id = "fresh_start", emoji = "ğŸ”„", name = "Fresh Start", desc = "Clear all negative flags" },
	{ id = "revive_family", emoji = "âœ¨", name = "Revive Family", desc = "Bring back the dead" },
}

local godModeActionBtns = {}
for i, action in ipairs(quickActions) do
	local btn = Instance.new("TextButton")
	btn.Name = action.id
	btn.BackgroundColor3 = C.Gray100
	btn.Text = ""
	btn.ZIndex = 153
	btn.Parent = actionsGrid
	corner(btn, 10)
	
	-- CRITICAL FIX: Add padding inside button for better mobile appearance
	local btnPad = Instance.new("UIPadding")
	btnPad.PaddingLeft = UDim.new(0, 6)
	btnPad.PaddingRight = UDim.new(0, 6)
	btnPad.Parent = btn
	
	local btnContent = Instance.new("Frame")
	btnContent.Size = UDim2.fromScale(1, 1)
	btnContent.BackgroundTransparency = 1
	btnContent.ZIndex = 154
	btnContent.Parent = btn
	
	-- CRITICAL FIX: Better emoji positioning - left aligned, vertically centered
	local emoji = Instance.new("TextLabel")
	local emojiSize = Device.IS_TINY_PHONE and 22 or 26
	emoji.Size = UDim2.new(0, emojiSize, 1, 0)
	emoji.Position = UDim2.new(0, 2, 0, 0)
	emoji.BackgroundTransparency = 1
	emoji.Font = F.Body
	emoji.TextSize = Device.IS_TINY_PHONE and 14 or 16
	emoji.Text = action.emoji
	emoji.TextYAlignment = Enum.TextYAlignment.Center
	emoji.TextXAlignment = Enum.TextXAlignment.Center
	emoji.ZIndex = 155
	emoji.Parent = btnContent
	
	-- CRITICAL FIX: Better text positioning - properly aligned and sized
	local textOffset = Device.IS_TINY_PHONE and 24 or 28
	local name = Instance.new("TextLabel")
	name.Size = UDim2.new(1, -textOffset - 4, 0, 16)
	name.Position = UDim2.new(0, textOffset, 0, Device.IS_TINY_PHONE and 5 or 7)
	name.BackgroundTransparency = 1
	name.Font = F.Medium
	name.TextSize = Device.IS_TINY_PHONE and 9 or 11
	name.TextColor3 = C.Gray800
	name.TextXAlignment = Enum.TextXAlignment.Left
	name.TextTruncate = Enum.TextTruncate.AtEnd -- Prevent overflow
	name.Text = action.name
	name.ZIndex = 155
	name.Parent = btnContent
	
	local desc = Instance.new("TextLabel")
	desc.Size = UDim2.new(1, -textOffset - 4, 0, 12)
	desc.Position = UDim2.new(0, textOffset, 0, Device.IS_TINY_PHONE and 21 or 25)
	desc.BackgroundTransparency = 1
	desc.Font = F.Body
	desc.TextSize = Device.IS_TINY_PHONE and 8 or 9
	desc.TextColor3 = C.Gray500
	desc.TextXAlignment = Enum.TextXAlignment.Left
	desc.TextTruncate = Enum.TextTruncate.AtEnd -- Prevent overflow
	desc.Text = action.desc
	desc.ZIndex = 155
	desc.Parent = btnContent
	
	btn.MouseEnter:Connect(function() btn.BackgroundColor3 = C.Gray200 end)
	btn.MouseLeave:Connect(function() btn.BackgroundColor3 = C.Gray100 end)
	
	godModeActionBtns[action.id] = btn
end

-- Error label
local errorLabel = Instance.new("TextLabel")
errorLabel.Size = UDim2.new(1, 0, 0, 20)
errorLabel.BackgroundTransparency = 1
errorLabel.Font = F.Body
errorLabel.TextSize = 12
errorLabel.TextColor3 = C.Red
errorLabel.Text = ""
errorLabel.ZIndex = 153
errorLabel.LayoutOrder = 5
errorLabel.Parent = modalScroll

-- Button bar
-- CRITICAL FIX: Properly centered button bar with fixed width buttons
local buttonBar = Instance.new("Frame")
buttonBar.Size = UDim2.new(1, 0, 0, 55)
buttonBar.BackgroundTransparency = 1
buttonBar.ZIndex = 152
buttonBar.LayoutOrder = 6
buttonBar.Parent = modalScroll

-- CRITICAL FIX: Add padding to center buttons properly
local buttonBarPad = Instance.new("UIPadding")
buttonBarPad.PaddingTop = UDim.new(0, 8)
buttonBarPad.Parent = buttonBar

local buttonLayout = Instance.new("UIListLayout")
buttonLayout.FillDirection = Enum.FillDirection.Horizontal
buttonLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
buttonLayout.VerticalAlignment = Enum.VerticalAlignment.Center
buttonLayout.Padding = UDim.new(0, 16)
buttonLayout.Parent = buttonBar

-- CRITICAL FIX: Calculate button width to fit 2 buttons + padding in modal
-- Modal usable width: 280 (tiny) or 380 (regular) 
-- Two buttons + 16px padding between = width/2 - 8
local btnWidth = Device.IS_TINY_PHONE and 120 or 150
local btnHeight = Device.IS_TINY_PHONE and 36 or 40

local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, btnWidth, 0, btnHeight)
closeBtn.BackgroundColor3 = C.Gray300
closeBtn.Text = "Close"
closeBtn.TextColor3 = C.Gray700
closeBtn.TextSize = Device.IS_TINY_PHONE and 14 or 16
closeBtn.Font = F.Medium
closeBtn.ZIndex = 153
closeBtn.Parent = buttonBar
corner(closeBtn, 10)

local applyBtn = Instance.new("TextButton")
applyBtn.Size = UDim2.new(0, btnWidth, 0, btnHeight)
applyBtn.BackgroundColor3 = Color3.fromRGB(253, 230, 138)
applyBtn.Text = "âš¡ Apply"
applyBtn.TextColor3 = C.Gray800
applyBtn.TextSize = Device.IS_TINY_PHONE and 14 or 16
applyBtn.Font = F.Medium
applyBtn.ZIndex = 153
applyBtn.Parent = buttonBar
corner(applyBtn, 10)
stroke(applyBtn, 2, 0, Color3.fromRGB(217, 119, 6))

-- Hide/Show functions
destroyGodModeModal = function()
	godModeOverlay.Visible = false
end

showGodModeModal = function()
	refreshGodModeStatus()
	if not hasGodMode then
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX #513: Use direct client-side prompt instead of server!
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		promptGamepassDirect("GOD_MODE")
		return
	end
	
	-- Update stat inputs from current state
	if currentState and currentState.Stats then
		for key, data in pairs(godModeStatInputs) do
			local val = currentState.Stats[key] or currentState[key] or 50
			data.input.Text = tostring(math.floor(val))
			data.fill.Size = UDim2.new(val/100, 0, 1, 0)
		end
	end
	
	errorLabel.Text = ""
	godModeOverlay.Visible = true
end

-- Connect buttons
closeBtn.MouseButton1Click:Connect(destroyGodModeModal)
godModeButton.MouseButton1Click:Connect(showGodModeModal)

-- Connect quick action buttons
for actionId, btn in pairs(godModeActionBtns) do
	btn.MouseButton1Click:Connect(function()
		if not GodModeEdit then
			errorLabel.Text = "Server not ready"
			return
		end
		
		local payload = { quickAction = actionId }
		local ok, result = pcall(function()
			return GodModeEdit:InvokeServer(payload)
		end)
		
		if ok and result and result.success then
			addFeedEntry(result.message or ("Applied: " .. actionId))
			destroyGodModeModal()
		else
			errorLabel.Text = (result and result.message) or "Action failed"
		end
	end)
end

-- Apply button
applyBtn.MouseButton1Click:Connect(function()
	errorLabel.Text = ""
	
	if not GodModeEdit then
		errorLabel.Text = "Server not ready for God Mode edits."
		return
	end
	
	-- Build payload
	local payload = {
		stats = {}
	}
	
	for key, data in pairs(godModeStatInputs) do
		local val = math.clamp(tonumber(data.input.Text) or 50, 0, 100)
		payload.stats[key] = val
	end
	
	applyBtn.Text = "Applying..."
	applyBtn.AutoButtonColor = false
	
	local ok, result = pcall(function()
		return GodModeEdit:InvokeServer(payload)
	end)
	
	if ok and result and result.success then
		addFeedEntry(result.message or "God Mode changes applied!")
		destroyGodModeModal()
	else
		errorLabel.Text = (result and result.message) or "Unable to apply changes."
	end
	
	applyBtn.Text = "âš¡ Apply Changes"
	applyBtn.AutoButtonColor = true
end)

-- Background click to close
godModeOverlay.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		local pos = input.Position
		local modalPos = godModeModal.AbsolutePosition
		local modalSize = godModeModal.AbsoluteSize
		if pos.X < modalPos.X or pos.X > modalPos.X + modalSize.X or
		   pos.Y < modalPos.Y or pos.Y > modalPos.Y + modalSize.Y then
			destroyGodModeModal()
		end
	end
end)

-- Update button visibility on state sync
task.spawn(function()
	task.wait(1)
	updateGodModeButtonAppearance()
end)
end)() -- End God Mode In-Game Editor IIFE

-- LEGACY CODE BELOW (disabled)
if false then -- Disabled: Old modal code kept for reference
	godModeOverlay = Instance.new("Frame")
	godModeOverlay.Name = "GodModeOverlay"
	godModeOverlay.Size = UDim2.fromScale(1, 1)
	godModeOverlay.BackgroundColor3 = Color3.new(0, 0, 0)
	godModeOverlay.BackgroundTransparency = 0.35
	godModeOverlay.ZIndex = 150
	godModeOverlay.Parent = mainContainer

	local modal = Instance.new("Frame")
	modal.Name = "GodModeModal"
	modal.Size = UDim2.new(0, Device.IS_TINY_PHONE and 280 or 360, 0, 0)
	modal.AutomaticSize = Enum.AutomaticSize.Y
	modal.AnchorPoint = Vector2.new(0.5, 0.5)
	modal.Position = UDim2.new(0.5, 0, 0.5, 0)
	modal.BackgroundColor3 = C.White
	modal.ZIndex = 151
	modal.Parent = godModeOverlay
	corner(modal, 16)
	stroke(modal, 1, 0.85, C.Gray200)
	pad(modal, 14, 14, 14, 14)

	local modalLayout = Instance.new("UIListLayout")
	modalLayout.FillDirection = Enum.FillDirection.Vertical
	modalLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
	modalLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	modalLayout.Padding = UDim.new(0, 8)
	modalLayout.Parent = modal

	local titleLabel = Instance.new("TextLabel")
	titleLabel.Size = UDim2.new(1, 0, 0, textSize(18) + 6)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Font = F.Title
	titleLabel.TextSize = textSize(18)
	titleLabel.TextColor3 = C.Gray800
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Text = "God Mode Editor"
	titleLabel.ZIndex = 152
	titleLabel.Parent = modal

	local subtitleLabel = Instance.new("TextLabel")
	subtitleLabel.Size = UDim2.new(1, 0, 0, textSize(11) + 6)
	subtitleLabel.BackgroundTransparency = 1
	subtitleLabel.Font = F.Body
	subtitleLabel.TextSize = textSize(11)
	subtitleLabel.TextColor3 = C.Gray500
	subtitleLabel.TextXAlignment = Enum.TextXAlignment.Left
	subtitleLabel.TextWrapped = true
	subtitleLabel.Text = "Edit your stats, name, and job instantly. Values are clamped between 0 and 100."
	subtitleLabel.ZIndex = 152
	subtitleLabel.Parent = modal

	local function createInputRow(labelText, defaultText, placeholder, numeric)
		local row = Instance.new("Frame")
		row.Size = UDim2.new(1, 0, 0, 0)
		row.AutomaticSize = Enum.AutomaticSize.Y
		row.BackgroundTransparency = 1
		row.ZIndex = 152

		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(1, 0, 0, textSize(11) + 4)
		label.BackgroundTransparency = 1
		label.Font = F.Medium
		label.TextSize = textSize(11)
		label.TextColor3 = C.Gray600
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.Text = labelText
		label.Parent = row

		local input = Instance.new("TextBox")
		input.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 26 or 32)
		input.BackgroundColor3 = Color3.fromRGB(248, 250, 252)
		input.Font = F.Body
		input.TextSize = textSize(12)
		input.TextColor3 = C.Gray800
		input.ClearTextOnFocus = false
		input.Text = defaultText or ""
		input.PlaceholderText = placeholder or ""
		input.TextXAlignment = Enum.TextXAlignment.Left
		input.Parent = row
		corner(input, 8)
		stroke(input, 1, 0.9, C.Gray200)
		pad(input, 8, 8, 4, 4)

		if numeric then
			input.Text = tostring(defaultText or 0)
		end

		return row, input
	end

	local currentName = currentState.Name or player.Name or ""
	local nameRow, nameInput = createInputRow("Name", currentName, "Enter a new name")
	nameRow.Parent = modal

	local statsGrid = Instance.new("Frame")
	statsGrid.Name = "StatsGrid"
	statsGrid.Size = UDim2.new(1, 0, 0, 0)
	statsGrid.AutomaticSize = Enum.AutomaticSize.Y
	statsGrid.BackgroundTransparency = 1
	statsGrid.ZIndex = 152
	statsGrid.Parent = modal

	local gridLayout = Instance.new("UIGridLayout")
	gridLayout.CellPadding = UDim2.new(0, 8, 0, 8)
	gridLayout.CellSize = UDim2.new(0.5, -4, 0, Device.IS_TINY_PHONE and 60 or 70)
	gridLayout.Parent = statsGrid

	local statInputs = {}
	local statList = {
		{ label = "Happiness", key = "Happiness", value = currentState.Happiness or 50 },
		{ label = "Health", key = "Health", value = currentState.Health or 100 },
		{ label = "Smarts", key = "Smarts", value = currentState.Smarts or 50 },
		{ label = "Looks", key = "Looks", value = currentState.Looks or 50 },
	}

	for _, stat in ipairs(statList) do
		local card = Instance.new("Frame")
		card.BackgroundColor3 = Color3.fromRGB(248, 250, 252)
		card.ZIndex = 153
		card.Parent = statsGrid
		corner(card, 10)
		stroke(card, 1, 0.9, C.Gray200)
		pad(card, 8, 8, 6, 6)

		local title = Instance.new("TextLabel")
		title.Size = UDim2.new(1, 0, 0, textSize(11) + 2)
		title.BackgroundTransparency = 1
		title.Font = F.Medium
		title.TextSize = textSize(11)
		title.TextColor3 = C.Gray600
		title.TextXAlignment = Enum.TextXAlignment.Left
		title.Text = stat.label
		title.Parent = card

		local input = Instance.new("TextBox")
		input.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 24 or 28)
		input.Position = UDim2.new(0, 0, 0, textSize(11) + 6)
		input.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		input.Font = F.Body
		input.TextSize = textSize(12)
		input.TextColor3 = C.Gray800
		input.TextXAlignment = Enum.TextXAlignment.Left
		input.ClearTextOnFocus = false
		input.Text = tostring(stat.value)
		input.Parent = card
		corner(input, 6)
		stroke(input, 1, 0.9, C.Gray200)
		pad(input, 6, 6, 2, 2)

		statInputs[stat.key] = input
	end

	local careerRow, careerInput = createInputRow("Career (ID or name)", "", "e.g. police_officer or clear")
	careerRow.Parent = modal

	local moneyRow, moneyInput = createInputRow("Money", tostring(currentState.Money or 0), "Optional", true)
	moneyRow.Parent = modal

	local errorLabel = Instance.new("TextLabel")
	errorLabel.Size = UDim2.new(1, 0, 0, textSize(11) + 4)
	errorLabel.BackgroundTransparency = 1
	errorLabel.Font = F.Body
	errorLabel.TextSize = textSize(11)
	errorLabel.TextColor3 = C.Red
	errorLabel.TextXAlignment = Enum.TextXAlignment.Left
	errorLabel.Text = ""
	errorLabel.ZIndex = 152
	errorLabel.Parent = modal

	local buttonBar = Instance.new("Frame")
	buttonBar.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 32 or 40)
	buttonBar.BackgroundTransparency = 1
	buttonBar.ZIndex = 152
	buttonBar.Parent = modal

	local buttonLayout = Instance.new("UIListLayout")
	buttonLayout.FillDirection = Enum.FillDirection.Horizontal
	buttonLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
	buttonLayout.Padding = UDim.new(0, 8)
	buttonLayout.Parent = buttonBar

	local closeBtn = Instance.new("TextButton")
	closeBtn.Size = UDim2.new(0, Device.IS_TINY_PHONE and 70 or 90, 1, 0)
	closeBtn.BackgroundColor3 = C.Gray200
	closeBtn.Font = F.Button
	closeBtn.TextSize = textSize(12)
	closeBtn.TextColor3 = C.Gray700
	closeBtn.Text = "Cancel"
	closeBtn.AutoButtonColor = false
	closeBtn.Parent = buttonBar
	corner(closeBtn, 8)

	local applyBtn = Instance.new("TextButton")
	applyBtn.Size = UDim2.new(0, Device.IS_TINY_PHONE and 120 or 150, 1, 0)
	applyBtn.BackgroundColor3 = Color3.fromRGB(249, 200, 10)
	applyBtn.Font = F.Button
	applyBtn.TextSize = textSize(13)
	applyBtn.TextColor3 = C.Black
	applyBtn.Text = "Apply Changes"
	applyBtn.AutoButtonColor = false
	applyBtn.Parent = buttonBar
	corner(applyBtn, 8)

	closeBtn.MouseButton1Click:Connect(destroyGodModeModal)

	applyBtn.MouseButton1Click:Connect(function()
		errorLabel.Text = ""
		local payload = { stats = {} }
		local trimmedName = nameInput.Text and nameInput.Text:gsub("^%s+", ""):gsub("%s+$", "") or ""
		if trimmedName ~= "" and trimmedName ~= (currentState.Name or "") then
			payload.name = trimmedName
		end

		for key, input in pairs(statInputs) do
			local value = tonumber(input.Text)
			if value then
				payload.stats[key] = value
			end
		end

		local moneyValue = tonumber(moneyInput.Text)
		if moneyValue then
			payload.money = moneyValue
		end

		local careerText = careerInput.Text and careerInput.Text:gsub("^%s+", ""):gsub("%s+$", "") or ""
		if careerText ~= "" then
			if careerText:lower() == "clear" or careerText:lower() == "none" then
				payload.clearCareer = true
			else
				payload.careerId = careerText
			end
		end

		local hasChanges = payload.name or payload.money or payload.careerId or payload.clearCareer
		if payload.stats and next(payload.stats) ~= nil then
			hasChanges = true
		else
			payload.stats = nil
		end

		if not hasChanges then
			errorLabel.Text = "Enter at least one change."
			return
		end

		if not GodModeEdit then
			errorLabel.Text = "Server not ready for God Mode edits."
			return
		end

		applyBtn.Text = "Saving..."
		applyBtn.AutoButtonColor = false

		local ok, result = pcall(function()
			return GodModeEdit:InvokeServer(payload)
		end)

		if ok and result and result.success then
			-- CRITICAL FIX: Don't add feed here - pushState on server already sends it!
			-- Adding it here was causing the message to appear TWICE
			destroyGodModeModal()
		else
			errorLabel.Text = (result and result.message) or "Unable to apply changes."
			applyBtn.Text = "Apply Changes"
		end
	end)
end

----------------------------------------------------------------
-- NAV BAR - TINY PHONE FIX: More compact
-- CRITICAL FIX: Wrapped in IIFE to reduce local register usage
----------------------------------------------------------------

-- Variables that need to be accessible outside IIFE
local navBar, navBtnRefs
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: Nav bar was too small
-- User feedback: "THE JOBS BAR AT BOTTOM IS TINY ASF"
-- Solution: Increase nav bar height for better touch targets and visibility
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local navBarHeight = Device.IS_TINY_PHONE and 55 or (Device.IS_SMALL_PHONE and 65 or px(85))

;(function()
-- Nav bar with proper sizing
navBar = Instance.new("Frame")
navBar.Name = "NavBar"
navBar.Size = UDim2.new(1, 0, 0, navBarHeight)
navBar.AnchorPoint = Vector2.new(0.5, 1)
navBar.Position = UDim2.new(0.5, 0, 1, 0)
navBar.BackgroundColor3 = C.NavBlue
navBar.ZIndex = 6
navBar.Parent = mainContainer

local navGrad = Instance.new("UIGradient")
navGrad.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, C.NavBlue),
	ColorSequenceKeypoint.new(1, C.NavDark),
})
navGrad.Rotation = 90
navGrad.Parent = navBar

-- TINY PHONE FIX: Smaller center gap for age button
local ageBtnGap = Device.IS_TINY_PHONE and 28 or (Device.IS_SMALL_PHONE and 36 or px(50))
local navLeft = Instance.new("Frame")
navLeft.Name = "NavLeft"
navLeft.Size = UDim2.new(0.5, -ageBtnGap, 1, 0)
navLeft.Position = UDim2.new(0, 0, 0, 0)
navLeft.BackgroundTransparency = 1
navLeft.ZIndex = 7
navLeft.Parent = navBar
local navPadSide = Device.IS_TINY_PHONE and 4 or padSize(8)
local navPadTop = Device.IS_TINY_PHONE and 4 or padSize(6)
local navPadBottom = Device.IS_TINY_PHONE and 12 or padSize(20)
pad(navLeft, navPadSide, Device.IS_TINY_PHONE and 8 or padSize(15), navPadTop, navPadBottom)

local navLeftLayout = Instance.new("UIListLayout")
navLeftLayout.FillDirection = Enum.FillDirection.Horizontal
navLeftLayout.HorizontalAlignment = Enum.HorizontalAlignment.Right
navLeftLayout.VerticalAlignment = Enum.VerticalAlignment.Center
navLeftLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 2 or padSize(6))
navLeftLayout.Parent = navLeft

local navRight = Instance.new("Frame")
navRight.Name = "NavRight"
navRight.Size = UDim2.new(0.5, -ageBtnGap, 1, 0)
navRight.Position = UDim2.new(0.5, ageBtnGap, 0, 0)
navRight.BackgroundTransparency = 1
navRight.ZIndex = 7
navRight.Parent = navBar
pad(navRight, Device.IS_TINY_PHONE and 8 or padSize(15), navPadSide, navPadTop, navPadBottom)

local navRightLayout = Instance.new("UIListLayout")
navRightLayout.FillDirection = Enum.FillDirection.Horizontal
navRightLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
navRightLayout.VerticalAlignment = Enum.VerticalAlignment.Center
navRightLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 2 or padSize(6))
navRightLayout.Parent = navRight

navBtnRefs = {}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: Larger nav buttons for better touch targets
-- User feedback: "THE JOBS BAR AT BOTTOM IS TINY ASF"
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local navBtnWidth = Device.IS_TINY_PHONE and 38 or (Device.IS_SMALL_PHONE and 46 or px(56))
local navBtnHeight = Device.IS_TINY_PHONE and 36 or (Device.IS_SMALL_PHONE and 44 or btnHeight(52))

local function createNavButton(info, parent, order)
	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(0, navBtnWidth, 0, navBtnHeight)
	btn.BackgroundTransparency = 1
	btn.AutoButtonColor = false
	btn.LayoutOrder = order
	btn.Text = ""
	btn.ZIndex = 8
	btn.Parent = parent

	local btnLayout = Instance.new("UIListLayout")
	btnLayout.FillDirection = Enum.FillDirection.Vertical
	btnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	btnLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 0 or 1)
	btnLayout.Parent = btn

	-- CRITICAL FIX: Larger icons and text for better visibility
	local iconLbl = Instance.new("TextLabel")
	iconLbl.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 20 or (Device.IS_SMALL_PHONE and 24 or px(28)))
	iconLbl.BackgroundTransparency = 1
	iconLbl.Font = F.Body
	iconLbl.TextSize = Device.IS_TINY_PHONE and 18 or (Device.IS_SMALL_PHONE and 22 or textSize(24))
	iconLbl.TextColor3 = C.White
	iconLbl.Text = info.icon
	iconLbl.ZIndex = 9
	iconLbl.Parent = btn

	local textLbl = Instance.new("TextLabel")
	textLbl.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 12 or (Device.IS_SMALL_PHONE and 14 or px(16)))
	textLbl.BackgroundTransparency = 1
	textLbl.Font = F.Medium
	textLbl.TextSize = Device.IS_TINY_PHONE and 9 or (Device.IS_SMALL_PHONE and 10 or textSize(12))
	textLbl.TextColor3 = Color3.fromRGB(148, 163, 184)
	textLbl.Text = info.text
	textLbl.ZIndex = 9
	textLbl.Parent = btn

	btn.MouseEnter:Connect(function()
		iconLbl.TextColor3 = C.Yellow
		textLbl.TextColor3 = C.White
	end)
	btn.MouseLeave:Connect(function()
		iconLbl.TextColor3 = C.White
		textLbl.TextColor3 = Color3.fromRGB(148, 163, 184)
	end)

	btn.MouseButton1Click:Connect(function()
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX: Block navigation when event card is showing!
		-- User feedback: "I AGED AND CLICKED JOBS,ASSETS,PEOPLE,ACTION,STORY AND IT ALL 
		-- OPENED AND THEN BROKE THE GAME"
		-- When an event is active, these buttons should be disabled to prevent
		-- multiple screens opening simultaneously and breaking the UI!
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		if awaitingEvent or (EventUI and EventUI.overlay and EventUI.overlay.Visible) then
			return -- Block navigation while event card is showing
		end
		
		-- Also block if result popup is showing
		if ResultUI and ResultUI.overlay and ResultUI.overlay.Visible then
			return
		end
		
		-- Also block if death screen is showing
		if DeathUI and DeathUI.overlay and DeathUI.overlay.Visible then
			return
		end
		
		if info.screen == "occupation" then
			if ScreenInstances.occupation then
				ScreenInstances.occupation:show()
			else
				warn("[LifeClient] âŒ OccupationScreen not available!")
			end
		elseif info.screen == "assets" then
			if ScreenInstances.assets then
				ScreenInstances.assets:show()
			else
				warn("[LifeClient] âŒ AssetsScreen not available - failed to initialize!")
			end
		elseif info.screen == "relationships" then
			if ScreenInstances.relationships then
				ScreenInstances.relationships:show()
			else
				warn("[LifeClient] âŒ RelationshipsScreen not available!")
			end
		elseif info.screen == "activities" then
			if ScreenInstances.activities then
				ScreenInstances.activities:show()
			else
				warn("[LifeClient] âŒ ActivitiesScreen not available!")
			end
		elseif info.screen == "storypaths" then
			if ScreenInstances.storypaths then
				ScreenInstances.storypaths:show()
			else
				warn("[LifeClient] âŒ StoryPathsScreen not available!")
			end
		elseif info.screen == "progress" then
			if ScreenInstances.progress then
				ScreenInstances.progress:show()
			else
				warn("[LifeClient] âŒ ProgressScreen not available!")
			end
		end
	end)

	navBtnRefs[info.screen] = btn
	return btn
end

-- BitLife-style nav: Jobs, Assets, Relationships, Activities, Story Paths
-- CRITICAL FIX: Added Story Paths button that was missing from bottom navigation
-- CRITICAL FIX #801: Shortened text labels to prevent overlap on right side
createNavButton({ icon = "ğŸ’¼", text = "Jobs",     screen = "occupation"   }, navLeft,  1)
createNavButton({ icon = "ğŸ ", text = "Assets",   screen = "assets"       }, navLeft,  2)
createNavButton({ icon = "ğŸ†", text = "Progress", screen = "progress"     }, navLeft,  3)  -- Awards, Past Lives, Leaderboards
createNavButton({ icon = "ğŸ‘¥", text = "People",   screen = "relationships"}, navRight, 1)  -- CRITICAL FIX #801: "Relations" -> "People"
createNavButton({ icon = "âš¡", text = "Actions",  screen = "activities"   }, navRight, 2)  -- CRITICAL FIX #801: "Activities" -> "Actions"
createNavButton({ icon = "ğŸ“–", text = "Story",    screen = "storypaths"   }, navRight, 3)  -- Story Paths
end)() -- End Nav Bar IIFE


----------------------------------------------------------------
-- AGE BUTTON - TINY PHONE FIX: More compact
-- CRITICAL FIX: Wrapped in IIFE to reduce local register usage
----------------------------------------------------------------

-- Variables that need to be accessible outside IIFE
local ageBtnContainer, ageButton, ageOuterRing, ageBtnSize

;(function()
-- TINY PHONE FIX: Much smaller age button
ageBtnSize = Device.IS_TINY_PHONE and 54 or (Device.IS_SMALL_PHONE and 65 or px(90))
local ageBtnOffset = Device.IS_TINY_PHONE and 6 or padSize(10)
ageBtnContainer = Instance.new("Frame")
ageBtnContainer.Size = UDim2.new(0, ageBtnSize, 0, ageBtnSize)
ageBtnContainer.AnchorPoint = Vector2.new(0.5, 0.5)
ageBtnContainer.Position = UDim2.new(0.5, 0, 1, -(navBarHeight/2 + ageBtnOffset))
ageBtnContainer.BackgroundTransparency = 1
ageBtnContainer.ZIndex = 15
ageBtnContainer.Parent = mainContainer

ageOuterRing = Instance.new("Frame")
ageOuterRing.Size = UDim2.new(1, Device.IS_TINY_PHONE and 4 or 8, 1, Device.IS_TINY_PHONE and 4 or 8)
ageOuterRing.AnchorPoint = Vector2.new(0.5, 0.5)
ageOuterRing.Position = UDim2.fromScale(0.5, 0.5)
ageOuterRing.BackgroundColor3 = C.White
ageOuterRing.ZIndex = 15
ageOuterRing.Parent = ageBtnContainer
corner(ageOuterRing, ageBtnSize/2)

local ageShadowSize = Device.IS_TINY_PHONE and 10 or 16
local ageShadow = Instance.new("Frame")
ageShadow.Size = UDim2.new(1, ageShadowSize, 1, ageShadowSize)
ageShadow.AnchorPoint = Vector2.new(0.5, 0.5)
ageShadow.Position = UDim2.new(0.5, 0, 0.5, Device.IS_TINY_PHONE and 2 or 4)
ageShadow.BackgroundColor3 = C.Black
ageShadow.BackgroundTransparency = 0.9
ageShadow.ZIndex = 14
ageShadow.Parent = ageBtnContainer
corner(ageShadow, ageBtnSize/2 + (Device.IS_TINY_PHONE and 2 or 4))

local ageBtnMargin = Device.IS_TINY_PHONE and 4 or 6
ageButton = Instance.new("TextButton")
ageButton.Size = UDim2.new(1, -ageBtnMargin, 1, -ageBtnMargin)
ageButton.AnchorPoint = Vector2.new(0.5, 0.5)
ageButton.Position = UDim2.fromScale(0.5, 0.5)
ageButton.BackgroundColor3 = C.Green
ageButton.AutoButtonColor = false
ageButton.Text = ""
ageButton.ZIndex = 16
ageButton.Parent = ageBtnContainer
corner(ageButton, ageBtnSize/2 - (Device.IS_TINY_PHONE and 2 or 3))
stroke(ageButton, Device.IS_TINY_PHONE and 2 or 3, 0, C.GreenRing)

local ageGrad = Instance.new("UIGradient")
ageGrad.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(74, 222, 128)),
	ColorSequenceKeypoint.new(1, C.Green),
})
ageGrad.Rotation = 90
ageGrad.Parent = ageButton

-- Age button content - use vertical layout for proper stacking
local ageBtnContent = Instance.new("Frame")
ageBtnContent.Size = UDim2.fromScale(1, 1)
ageBtnContent.BackgroundTransparency = 1
ageBtnContent.ZIndex = 17
ageBtnContent.Parent = ageButton

local ageBtnLayout = Instance.new("UIListLayout")
ageBtnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
ageBtnLayout.VerticalAlignment = Enum.VerticalAlignment.Center
ageBtnLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and -2 or 0)
ageBtnLayout.Parent = ageBtnContent

local agePlus = Instance.new("TextLabel")
agePlus.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 22 or px(32))
agePlus.BackgroundTransparency = 1
agePlus.Font = F.Title
agePlus.TextSize = Device.IS_TINY_PHONE and 24 or textSize(32)
agePlus.TextColor3 = C.White
agePlus.Text = "+"
agePlus.LayoutOrder = 1
agePlus.ZIndex = 17
agePlus.Parent = ageBtnContent

local ageText = Instance.new("TextLabel")
ageText.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 14 or 18)
ageText.BackgroundTransparency = 1
ageText.Font = F.Button
ageText.TextSize = Device.IS_TINY_PHONE and 11 or 16
ageText.TextColor3 = C.White
ageText.Text = "Age"
ageText.LayoutOrder = 2
ageText.ZIndex = 17
ageText.Parent = ageBtnContent

local tutorialRing = Instance.new("Frame")
tutorialRing.Size = UDim2.new(1, Device.IS_TINY_PHONE and 20 or 30, 1, Device.IS_TINY_PHONE and 20 or 30)
tutorialRing.AnchorPoint = Vector2.new(0.5, 0.5)
tutorialRing.Position = UDim2.fromScale(0.5, 0.5)
tutorialRing.BackgroundTransparency = 1
tutorialRing.Visible = false
tutorialRing.ZIndex = 14
tutorialRing.Parent = ageBtnContainer
corner(tutorialRing, 60)
stroke(tutorialRing, 4, 0, C.White) -- Changed to WHITE and thicker for visibility

----------------------------------------------------------------
-- TUTORIAL OVERLAY
----------------------------------------------------------------

local tutorialOverlay = Instance.new("Frame")
tutorialOverlay.Size = UDim2.fromScale(1, 1)
tutorialOverlay.BackgroundTransparency = 1
tutorialOverlay.Visible = false
tutorialOverlay.ZIndex = 40
tutorialOverlay.Parent = screenGui

local tutTextCont = Instance.new("Frame")
tutTextCont.Size = UDim2.new(0.85, 0, 0, 0)
tutTextCont.AutomaticSize = Enum.AutomaticSize.Y
tutTextCont.AnchorPoint = Vector2.new(0.5, 1)
-- Position above the age button (which is near bottom of screen)
tutTextCont.Position = UDim2.new(0.5, 0, 1, Device.IS_TINY_PHONE and -140 or -180)
tutTextCont.BackgroundTransparency = 1
tutTextCont.Parent = tutorialOverlay

local tutLayout = Instance.new("UIListLayout")
tutLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
tutLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 4 or 8)
tutLayout.Parent = tutTextCont

-- Tutorial text FIRST, then pointing finger at the bottom (pointing DOWN to Age button)
local tutLines = {
	{ text = "Tap the AGE button to grow older!", isEmoji = false },
	{ text = "Make choices as events happen.", isEmoji = false },
	{ text = "Live your best (or worst) life!", isEmoji = false },
	{ text = "ğŸ‘‡", isEmoji = true },  -- Finger at BOTTOM pointing DOWN to Age button
}
for i, lineData in ipairs(tutLines) do
	local lbl = Instance.new("TextLabel")
	lbl.Size = UDim2.new(1, 0, 0, lineData.isEmoji and 40 or (Device.IS_TINY_PHONE and 22 or 28))
	lbl.BackgroundTransparency = 1
	lbl.Font = lineData.isEmoji and F.Body or F.Title
	lbl.TextSize = lineData.isEmoji and 36 or (Device.IS_TINY_PHONE and 16 or 20)
	lbl.TextColor3 = C.Gray900  -- DARK text for visibility
	lbl.TextStrokeColor3 = C.White
	lbl.TextStrokeTransparency = 0.5  -- White outline for contrast
	lbl.Text = lineData.text
	lbl.LayoutOrder = i
	lbl.Parent = tutTextCont
end

showTutorial = function()
	if hasShownAgeHint then return end
	hasShownAgeHint = true
	tutorialOverlay.Visible = true
	tutorialRing.Visible = true

	-- Pulse the ring stroke for attention
	local pulse = TweenInfo.new(0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
	local s = tutorialRing:FindFirstChildOfClass("UIStroke")
	if s then
		s.Color = C.White -- Ensure it's white
		s.Thickness = 4
		tween(s, pulse, { Transparency = 0.4, Thickness = 6 })
	end

	-- Also scale pulse the ring for extra visibility
	local scalePulse = TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)
	tween(tutorialRing, scalePulse, { 
		Size = UDim2.new(1, 38, 1, 38) 
	})
end

hideTutorial = function()
	tutorialOverlay.Visible = false
	tutorialRing.Visible = false
	-- Reset ring size for next time
	tutorialRing.Size = UDim2.new(1, 30, 1, 30)
end
end)() -- End Age Button/Tutorial IIFE

----------------------------------------------------------------
-- PREMIUM EVENT MODAL (BitLife-style red card) - MOBILE FIX
----------------------------------------------------------------

-- EventUI table to store event modal references and reduce local variable count
local EventUI = {
	activeChoiceButtons = {},
	currentEventId = nil,
	surpriseConnection = nil,
	currentHideTween = nil,
}

-- Builder function to create event modal UI
local function buildEventModal()
	EventUI.overlay = Instance.new("Frame")
	EventUI.overlay.Name = "EventOverlay"
	EventUI.overlay.Size = UDim2.fromScale(1, 1)
	EventUI.overlay.BackgroundColor3 = C.Black
	EventUI.overlay.BackgroundTransparency = 0.45
	EventUI.overlay.Visible = false
	EventUI.overlay.ZIndex = 60
	EventUI.overlay.Parent = screenGui

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: AGGRESSIVE mobile event card sizing for VERY small phones (iPhone 6 etc)
	-- User feedback: "cards are getting cut off top and bottom for iPhone 6 (667x375)"
	-- Solution: MUCH more aggressive height limits based on ACTUAL screen height
	-- Account for: status bar (~20px), top bar (~60px), bottom nav (~70px) = ~150px taken
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local screenHeight = Device.ViewportSize.Y
	local screenWidth = Device.ViewportSize.X
	
	-- Calculate SAFE height for cards (accounting for UI chrome)
	-- On tiny phones, we need to be very conservative
	local topReserved = Device.IS_TINY_PHONE and 80 or (Device.IS_SMALL_PHONE and 90 or 100)
	local bottomReserved = Device.IS_TINY_PHONE and 40 or (Device.IS_SMALL_PHONE and 50 or 60)
	local safeHeight = screenHeight - topReserved - bottomReserved
	
	local eventWidth
	local maxEventHeight
	
	if Device.IS_TINY_PHONE then
		-- ULTRA COMPACT: Tiny phones (iPhone 6: 667x375, iPhone SE: 568x320)
		-- CRITICAL FIX: Use nearly full safe height to prevent button cutoff
		eventWidth = math.min(screenWidth - 12, 280)
		maxEventHeight = math.min(safeHeight - 10, 650) -- Nearly full safe height
	elseif Device.IS_SMALL_PHONE then
		-- Small phones (under 750px height)
		-- CRITICAL FIX: Use nearly full safe height to prevent button cutoff  
		eventWidth = math.min(screenWidth - 16, 310)
		maxEventHeight = math.min(safeHeight - 10, 720) -- Nearly full safe height
	elseif Device.IS_MOBILE then
		eventWidth = modalWidth(330)
		maxEventHeight = math.min(safeHeight - 10, 800) -- Nearly full safe height
	else
		eventWidth = modalWidth(360)
		maxEventHeight = math.min(safeHeight - 10, 900) -- Nearly full safe height
	end
	
	-- Calculate responsive corner radii and margins (slightly larger for cleaner look)
	local eventCornerRadius = Device.IS_TINY_PHONE and 14 or (Device.IS_SMALL_PHONE and 18 or px(24))
	local shellMargin = Device.IS_TINY_PHONE and 3 or (Device.IS_SMALL_PHONE and 4 or 4)
	local cardMargin = Device.IS_TINY_PHONE and 6 or (Device.IS_SMALL_PHONE and 8 or 8)
	
	-- Shadow frame: fixed width, autosize height
	EventUI.shadowFrame = Instance.new("Frame")
	EventUI.shadowFrame.Size = UDim2.new(0, eventWidth, 0, 0)
	EventUI.shadowFrame.AutomaticSize = Enum.AutomaticSize.Y
	EventUI.shadowFrame.AnchorPoint = Vector2.new(0.5, 0.5)
	EventUI.shadowFrame.Position = UDim2.fromScale(0.5, 0.5)
	EventUI.shadowFrame.BackgroundColor3 = C.Black
	EventUI.shadowFrame.BackgroundTransparency = 0.88
	EventUI.shadowFrame.ZIndex = 61
	EventUI.shadowFrame.Parent = EventUI.overlay
	corner(EventUI.shadowFrame, eventCornerRadius)
	
	-- Add size constraint to prevent modal from being too tall
	local eventSizeConstraint = Instance.new("UISizeConstraint")
	eventSizeConstraint.MaxSize = Vector2.new(eventWidth, maxEventHeight)
	eventSizeConstraint.Parent = EventUI.shadowFrame
	
	-- Enable clipping for clean edges
	EventUI.shadowFrame.ClipsDescendants = true

	-- Shell: autosize height (no Y scale) - fixes button overflow
	EventUI.shell = Instance.new("Frame")
	EventUI.shell.Name = "EventShell"
	EventUI.shell.Size = UDim2.new(1, -shellMargin, 0, 0)
	EventUI.shell.AutomaticSize = Enum.AutomaticSize.Y
	-- CRITICAL FIX: Don't clip descendants - let content overflow visually if needed
	-- The parent shadowFrame handles size constraints, not clipping
	EventUI.shell.ClipsDescendants = false
	EventUI.shell.Position = UDim2.new(0, shellMargin/2, 0, shellMargin/2)
	EventUI.shell.BackgroundColor3 = C.Red
	EventUI.shell.ZIndex = 62
	EventUI.shell.Parent = EventUI.shadowFrame
	corner(EventUI.shell, Device.IS_TINY_PHONE and 12 or (Device.IS_SMALL_PHONE and 16 or px(22)))
	stroke(EventUI.shell, Device.IS_TINY_PHONE and 1 or 2, 0.3, C.RedDark)
	if not Device.IS_TINY_PHONE then
		createShadow(EventUI.shell, Device.IS_SMALL_PHONE and 4 or 6, Device.IS_SMALL_PHONE and px(14) or px(20), C.Black, 0.85)
	end

	-- CRITICAL FIX: Card is a regular Frame - NO SCROLLING!
	-- Text and buttons will be made smaller to fit screen perfectly
	EventUI.card = Instance.new("Frame")
	EventUI.card.Name = "EventCard"
	EventUI.card.Size = UDim2.new(1, -cardMargin, 0, 0)
	EventUI.card.AutomaticSize = Enum.AutomaticSize.Y
	EventUI.card.Position = UDim2.new(0, cardMargin/2, 0, cardMargin/2)
	EventUI.card.BackgroundColor3 = C.White
	EventUI.card.ZIndex = 63
	-- CRITICAL FIX: Don't clip - parent handles size, buttons must always be visible!
	EventUI.card.ClipsDescendants = false
	EventUI.card.Parent = EventUI.shell
	corner(EventUI.card, Device.IS_TINY_PHONE and 10 or (Device.IS_SMALL_PHONE and 14 or px(20)))

	local eventLayout = Instance.new("UIListLayout")
	eventLayout.Padding = UDim.new(0, 0)
	eventLayout.SortOrder = Enum.SortOrder.LayoutOrder  -- CRITICAL: Force correct order
	eventLayout.Parent = EventUI.card

	-- TINY PHONE FIX: MUCH smaller header for tiny phones
	local eventHeaderHeight = Device.IS_TINY_PHONE and 36 or (Device.IS_SMALL_PHONE and 48 or px(70))
	EventUI.header = Instance.new("Frame")
	EventUI.header.Name = "Header"
	EventUI.header.Size = UDim2.new(1, 0, 0, eventHeaderHeight)
	EventUI.header.BackgroundColor3 = C.White
	EventUI.header.LayoutOrder = 1
	EventUI.header.Visible = false
	EventUI.header.ZIndex = 64
	EventUI.header.Parent = EventUI.card
	pad(EventUI.header, padSize(16), padSize(16), padSize(10), padSize(8))

	-- TINY PHONE FIX: Smaller avatar
	local eventAvatarSize = Device.IS_TINY_PHONE and 28 or (Device.IS_SMALL_PHONE and 36 or px(50))
	EventUI.avatar = Instance.new("Frame")
	EventUI.avatar.Size = UDim2.new(0, eventAvatarSize, 0, eventAvatarSize)
	EventUI.avatar.BackgroundColor3 = Color3.fromRGB(254, 226, 226)
	EventUI.avatar.ZIndex = 65
	EventUI.avatar.Parent = EventUI.header
	corner(EventUI.avatar, eventAvatarSize/2)
	stroke(EventUI.avatar, Device.IS_TINY_PHONE and 1 or 2, 0.3, C.Red)

	EventUI.avatarEmoji = Instance.new("TextLabel")
	EventUI.avatarEmoji.Size = UDim2.fromScale(1, 1)
	EventUI.avatarEmoji.BackgroundTransparency = 1
	EventUI.avatarEmoji.Font = F.Body
	EventUI.avatarEmoji.TextSize = Device.IS_TINY_PHONE and 16 or textSize(26)
	EventUI.avatarEmoji.Text = "ğŸ‘¤"
	EventUI.avatarEmoji.ZIndex = 66
	EventUI.avatarEmoji.Parent = EventUI.avatar

	EventUI.nameLbl = Instance.new("TextLabel")
	EventUI.nameLbl.Size = UDim2.new(0.6, 0, 0, Device.IS_TINY_PHONE and 16 or px(22))
	EventUI.nameLbl.Position = UDim2.new(0, eventAvatarSize + padSize(8), 0, padSize(4))
	EventUI.nameLbl.BackgroundTransparency = 1
	EventUI.nameLbl.Font = F.Title
	EventUI.nameLbl.TextSize = Device.IS_TINY_PHONE and 11 or textSize(16)
	EventUI.nameLbl.TextColor3 = C.Gray900
	EventUI.nameLbl.TextXAlignment = Enum.TextXAlignment.Left
	EventUI.nameLbl.TextTruncate = Enum.TextTruncate.AtEnd
	EventUI.nameLbl.Text = "Person Name"
	EventUI.nameLbl.ZIndex = 65
	EventUI.nameLbl.Parent = EventUI.header

	-- TINY PHONE FIX: Smaller relation banner
	local relationBannerWidth = Device.IS_TINY_PHONE and 65 or (Device.IS_SMALL_PHONE and 80 or px(115))
	local relationBannerHeight = Device.IS_TINY_PHONE and 18 or px(26)
	EventUI.relationBanner = Instance.new("Frame")
	EventUI.relationBanner.Size = UDim2.new(0, relationBannerWidth, 0, relationBannerHeight)
	EventUI.relationBanner.AnchorPoint = Vector2.new(1, 0)
	EventUI.relationBanner.Position = UDim2.new(1, 0, 0, padSize(4))
	EventUI.relationBanner.BackgroundColor3 = C.Red
	EventUI.relationBanner.ZIndex = 65
	EventUI.relationBanner.Parent = EventUI.header
	pill(EventUI.relationBanner)

	EventUI.relationLbl = Instance.new("TextLabel")
	EventUI.relationLbl.Size = UDim2.fromScale(1, 0.9)
	EventUI.relationLbl.Position = UDim2.new(0, 0, 0.05, 0)
	EventUI.relationLbl.BackgroundTransparency = 1
	EventUI.relationLbl.Font = F.Button
	EventUI.relationLbl.TextSize = Device.IS_TINY_PHONE and 9 or textSize(11)
	EventUI.relationLbl.TextColor3 = C.White
	EventUI.relationLbl.Text = "Classmate"
	EventUI.relationLbl.ZIndex = 66
	EventUI.relationLbl.Parent = EventUI.relationBanner

	-- title section (emoji + event title) - TINY PHONE FIX: Much more compact
	local titleSection = Instance.new("Frame")
	titleSection.Size = UDim2.new(1, 0, 0, 0)
	titleSection.AutomaticSize = Enum.AutomaticSize.Y
	titleSection.BackgroundTransparency = 1
	titleSection.LayoutOrder = 2
	titleSection.ZIndex = 64
	titleSection.Parent = EventUI.card

	-- MOBILE FIX: Very tight padding on tiny phones to fit cards on small screens
	-- BUG FIX: Even tighter padding so buttons always visible
	local titlePadTop = Device.IS_TINY_PHONE and 2 or (Device.IS_SMALL_PHONE and 4 or padSize(14))
	local titlePadBottom = Device.IS_TINY_PHONE and 2 or (Device.IS_SMALL_PHONE and 4 or padSize(8))
	local titlePadSide = Device.IS_TINY_PHONE and 6 or (Device.IS_SMALL_PHONE and 8 or padSize(16))
	local titlePadding = Instance.new("UIPadding")
	titlePadding.PaddingTop = UDim.new(0, titlePadTop)
	titlePadding.PaddingBottom = UDim.new(0, titlePadBottom)
	titlePadding.PaddingLeft = UDim.new(0, titlePadSide)
	titlePadding.PaddingRight = UDim.new(0, titlePadSide)
	titlePadding.Parent = titleSection

	local titleLayout = Instance.new("UIListLayout")
	titleLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	titleLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	titleLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 2 or padSize(10))
	titleLayout.Parent = titleSection

	-- MOBILE FIX: Responsive emoji sizing - SMALLER on tiny phones to save vertical space
	-- BUG FIX: Even smaller emoji to leave room for buttons
	local eventEmojiSize = Device.IS_TINY_PHONE and 22 or (Device.IS_SMALL_PHONE and 32 or px(56))
	local eventEmojiTextSize = Device.IS_TINY_PHONE and 18 or (Device.IS_SMALL_PHONE and 28 or textSize(46))
	EventUI.emoji = Instance.new("TextLabel")
	EventUI.emoji.Size = UDim2.new(0, eventEmojiSize, 0, eventEmojiSize)
	EventUI.emoji.BackgroundTransparency = 1
	EventUI.emoji.Font = F.Body
	EventUI.emoji.TextSize = eventEmojiTextSize
	EventUI.emoji.Text = "ğŸ™‚"
	EventUI.emoji.LayoutOrder = 1
	EventUI.emoji.ZIndex = 65
	EventUI.emoji.Parent = titleSection

	-- MOBILE FIX: Responsive title text - scaled for tiny phones
	-- CRITICAL FIX: SMALLER title on tiny phones to fit card better
	-- BUG FIX: Even smaller title so buttons always visible
	local eventTitleTextSize = Device.IS_TINY_PHONE and 12 or (Device.IS_SMALL_PHONE and 15 or textSize(24))
	EventUI.title = Instance.new("TextLabel")
	EventUI.title.Size = UDim2.new(1, 0, 0, 0)
	EventUI.title.AutomaticSize = Enum.AutomaticSize.Y
	EventUI.title.BackgroundTransparency = 1
	EventUI.title.Font = F.Title
	EventUI.title.TextSize = eventTitleTextSize
	EventUI.title.TextColor3 = C.Gray900
	EventUI.title.Text = "Life Event"
	EventUI.title.TextWrapped = true
	EventUI.title.TextXAlignment = Enum.TextXAlignment.Center
	EventUI.title.LayoutOrder = 2
	EventUI.title.ZIndex = 65
	EventUI.title.Parent = titleSection

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Scrollable body section for long text on mobile
	-- User feedback: "cards getting cut off top and bottom on mobile"
	-- Solution: Scrollable body area with max height, buttons always visible
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	-- Body text area - uses AutomaticSize, no scrolling

	local bodySection = Instance.new("Frame")
	bodySection.Size = UDim2.new(1, 0, 0, 0)
	bodySection.AutomaticSize = Enum.AutomaticSize.Y
	bodySection.BackgroundTransparency = 1
	bodySection.LayoutOrder = 3
	bodySection.ZIndex = 64
	bodySection.Parent = EventUI.card
	-- BUG FIX: Tighter padding to leave room for buttons
	local bodyPadSide = Device.IS_TINY_PHONE and 4 or (Device.IS_SMALL_PHONE and 8 or padSize(24))
	local bodyPadBottom = Device.IS_TINY_PHONE and 2 or (Device.IS_SMALL_PHONE and 4 or padSize(10))
	pad(bodySection, bodyPadSide, bodyPadSide, 0, bodyPadBottom)

	local bodyLayout = Instance.new("UIListLayout")
	bodyLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	bodyLayout.VerticalAlignment = Enum.VerticalAlignment.Top
	bodyLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 2 or (Device.IS_SMALL_PHONE and 4 or padSize(10)))
	bodyLayout.Parent = bodySection

	-- Body text container - NO SCROLLING, card expands to fit
	EventUI.bodyScroll = Instance.new("Frame")
	EventUI.bodyScroll.Size = UDim2.new(1, 0, 0, 0)
	EventUI.bodyScroll.AutomaticSize = Enum.AutomaticSize.Y
	EventUI.bodyScroll.BackgroundTransparency = 1
	EventUI.bodyScroll.BorderSizePixel = 0
	EventUI.bodyScroll.LayoutOrder = 1
	EventUI.bodyScroll.ZIndex = 65
	EventUI.bodyScroll.Parent = bodySection

	local eventBodyTextSize = Device.IS_TINY_PHONE and 14 or (Device.IS_SMALL_PHONE and 16 or textSize(20))
	EventUI.body = Instance.new("TextLabel")
	EventUI.body.Size = UDim2.new(1, 0, 0, 0)
	EventUI.body.AutomaticSize = Enum.AutomaticSize.Y
	EventUI.body.BackgroundTransparency = 1
	EventUI.body.Font = F.Body
	EventUI.body.TextSize = eventBodyTextSize
	EventUI.body.TextColor3 = C.Gray700
	EventUI.body.TextWrapped = true
	EventUI.body.TextXAlignment = Enum.TextXAlignment.Center
	-- CRITICAL FIX: Tighter line height on tiny phones to fit more text
	EventUI.body.LineHeight = Device.IS_TINY_PHONE and 1.15 or (Device.IS_SMALL_PHONE and 1.25 or 1.4)
	EventUI.body.RichText = true
	EventUI.body.Text = ""
	EventUI.body.ZIndex = 65
	EventUI.body.Parent = EventUI.bodyScroll

	-- MOBILE FIX: Responsive question text
	-- CRITICAL FIX: Smaller question text on tiny phones to fit cards better
	-- BUG FIX: Even smaller to guarantee buttons visible
	local eventQuestionTextSize = Device.IS_TINY_PHONE and 10 or (Device.IS_SMALL_PHONE and 12 or textSize(18))
	EventUI.question = Instance.new("TextLabel")
	EventUI.question.Name = "EventQuestion"
	EventUI.question.Size = UDim2.new(1, 0, 0, 0)
	EventUI.question.AutomaticSize = Enum.AutomaticSize.Y
	EventUI.question.BackgroundTransparency = 1
	EventUI.question.Font = F.Title
	EventUI.question.TextSize = eventQuestionTextSize
	EventUI.question.TextColor3 = C.Gray800
	EventUI.question.Text = "What will you do?"
	EventUI.question.TextXAlignment = Enum.TextXAlignment.Center
	EventUI.question.TextWrapped = true
	EventUI.question.LineHeight = Device.IS_TINY_PHONE and 1.1 or (Device.IS_SMALL_PHONE and 1.15 or 1.25)
	EventUI.question.LayoutOrder = 2
	EventUI.question.ZIndex = 65
	EventUI.question.Parent = bodySection

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: NO SCROLLING - Card scales dynamically to fit screen!
	-- User feedback: "scroll is bad, should scale nicely depending on size"
	-- The showEvent function will dynamically adjust text/button sizes based on content
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	EventUI.choicesSection = Instance.new("Frame")
	EventUI.choicesSection.Name = "ChoicesContainer"
	EventUI.choicesSection.Size = UDim2.new(1, 0, 0, 0)
	EventUI.choicesSection.AutomaticSize = Enum.AutomaticSize.Y
	EventUI.choicesSection.BackgroundTransparency = 1
	EventUI.choicesSection.LayoutOrder = 4
	EventUI.choicesSection.ZIndex = 64
	EventUI.choicesSection.ClipsDescendants = false  -- Don't clip - let parent handle it
	EventUI.choicesSection.Parent = EventUI.card

	-- MOBILE FIX: VERY tight choice section padding on tiny phones
	local choicePadSide = Device.IS_TINY_PHONE and 4 or (Device.IS_SMALL_PHONE and 8 or padSize(18))
	local choicePadTop = Device.IS_TINY_PHONE and 0 or (Device.IS_SMALL_PHONE and 2 or padSize(4))
	local choicePadBottom = Device.IS_TINY_PHONE and 4 or (Device.IS_SMALL_PHONE and 8 or padSize(18))
	pad(EventUI.choicesSection, choicePadSide, choicePadSide, choicePadTop, choicePadBottom)

	local choicesLayout = Instance.new("UIListLayout")
	choicesLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	choicesLayout.SortOrder = Enum.SortOrder.LayoutOrder  -- CRITICAL: Force correct order
	-- MOBILE FIX: Very tight spacing between buttons on tiny phones
	choicesLayout.Padding = UDim.new(0, Device.IS_TINY_PHONE and 2 or (Device.IS_SMALL_PHONE and 4 or padSize(8)))
	choicesLayout.Parent = EventUI.choicesSection
end

-- Build the event modal immediately
buildEventModal()

local function clearChoices()
	for _, b in ipairs(EventUI.activeChoiceButtons) do
		b:Destroy()
	end
	table.clear(EventUI.activeChoiceButtons)

	if EventUI.surpriseConnection then
		EventUI.surpriseConnection:Disconnect()
		EventUI.surpriseConnection = nil
	end
end

-- MOBILE FIX: Touch-friendly surprise button
local surpriseBtn = Instance.new("TextButton")
surpriseBtn.Size = UDim2.new(1, 0, 0, btnHeight(36))
surpriseBtn.BackgroundTransparency = 1
surpriseBtn.Font = F.Medium
surpriseBtn.TextSize = textSize(14)
surpriseBtn.TextColor3 = C.Gray400
surpriseBtn.Text = "âœ¨ Surprise me!"
surpriseBtn.AutoButtonColor = false
surpriseBtn.LayoutOrder = 100
surpriseBtn.ZIndex = 65
surpriseBtn.Parent = EventUI.choicesSection

surpriseBtn.MouseEnter:Connect(function()
	surpriseBtn.TextColor3 = C.Blue
end)
surpriseBtn.MouseLeave:Connect(function()
	surpriseBtn.TextColor3 = C.Gray400
end)

----------------------------------------------------------------
-- DEATH OVERLAY - MOBILE FIX: Responsive death screen
----------------------------------------------------------------

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- BITLIFE-STYLE DEATH SCREEN - Full screen memorial with comprehensive stats
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local DeathUI = {}

-- Builder function to reduce local variable count in module scope
local function buildDeathUI()
	DeathUI.overlay = Instance.new("Frame")
	DeathUI.overlay.Name = "DeathOverlay"
	DeathUI.overlay.Size = UDim2.fromScale(1, 1)
	DeathUI.overlay.BackgroundColor3 = Color3.fromRGB(15, 20, 25)
	DeathUI.overlay.BackgroundTransparency = 0
	DeathUI.overlay.Visible = false
	DeathUI.overlay.ZIndex = 120
	DeathUI.overlay.Parent = screenGui

	-- Scrollable container for all content - MOBILE FIX: Thicker scrollbar for touch
	DeathUI.scroll = Instance.new("ScrollingFrame")
	DeathUI.scroll.Name = "DeathScroll"
	DeathUI.scroll.Size = UDim2.fromScale(1, 1)
	DeathUI.scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
	DeathUI.scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
	DeathUI.scroll.BackgroundTransparency = 1
	DeathUI.scroll.ScrollBarThickness = Device.IS_MOBILE and 8 or 4
	DeathUI.scroll.ScrollBarImageColor3 = C.Gray400
	DeathUI.scroll.ZIndex = 121
	DeathUI.scroll.Parent = DeathUI.overlay

	local deathScrollLayout = Instance.new("UIListLayout")
	deathScrollLayout.Padding = UDim.new(0, 0)
	deathScrollLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	deathScrollLayout.SortOrder = Enum.SortOrder.LayoutOrder
	deathScrollLayout.Parent = DeathUI.scroll

	-- MOBILE FIX: Responsive header height
	local deathHeaderHeight = Device.IS_SMALL_PHONE and 220 or px(280)
	DeathUI.headerSection = Instance.new("Frame")
	DeathUI.headerSection.Name = "Header"
	DeathUI.headerSection.Size = UDim2.new(1, 0, 0, deathHeaderHeight)
	DeathUI.headerSection.BackgroundColor3 = Color3.fromRGB(30, 35, 45)
	DeathUI.headerSection.ZIndex = 121
	DeathUI.headerSection.LayoutOrder = 1
	DeathUI.headerSection.Parent = DeathUI.scroll

	-- MOBILE FIX: Responsive gravestone emoji
	local deathEmojiSize = Device.IS_SMALL_PHONE and 70 or px(100)
	DeathUI.emojiFrame = Instance.new("Frame")
	DeathUI.emojiFrame.Size = UDim2.new(0, deathEmojiSize, 0, deathEmojiSize)
	DeathUI.emojiFrame.Position = UDim2.new(0.5, -deathEmojiSize/2, 0, padSize(30))
	DeathUI.emojiFrame.BackgroundColor3 = Color3.fromRGB(60, 65, 75)
	DeathUI.emojiFrame.ZIndex = 122
	DeathUI.emojiFrame.Parent = DeathUI.headerSection
	corner(DeathUI.emojiFrame, deathEmojiSize/2)

	local deathEmojiLabel = Instance.new("TextLabel")
	deathEmojiLabel.Size = UDim2.fromScale(1, 1)
	deathEmojiLabel.BackgroundTransparency = 1
	deathEmojiLabel.Font = F.Body
	deathEmojiLabel.TextSize = textSize(56)
	deathEmojiLabel.Text = "âš°ï¸"
	deathEmojiLabel.ZIndex = 123
	deathEmojiLabel.Parent = DeathUI.emojiFrame

	-- MOBILE FIX: Responsive RIP label positioning
	local ripLabelY = deathEmojiSize + padSize(40)
	local ripLabel = Instance.new("TextLabel")
	ripLabel.Name = "RIP"
	ripLabel.Size = UDim2.new(1, 0, 0, px(28))
	ripLabel.Position = UDim2.new(0, 0, 0, ripLabelY)
	ripLabel.BackgroundTransparency = 1
	ripLabel.Font = F.Medium
	ripLabel.TextSize = textSize(14)
	ripLabel.TextColor3 = C.Gray400
	ripLabel.Text = "REST IN PEACE"
	ripLabel.ZIndex = 122
	ripLabel.Parent = DeathUI.headerSection

	-- MOBILE FIX: Responsive name text
	local titleLabelY = ripLabelY + px(28)
	DeathUI.title = Instance.new("TextLabel")
	DeathUI.title.Size = UDim2.new(1, -padSize(32), 0, px(36))
	DeathUI.title.Position = UDim2.new(0, padSize(16), 0, titleLabelY)
	DeathUI.title.BackgroundTransparency = 1
	DeathUI.title.Font = F.Title
	DeathUI.title.TextSize = textSize(28)
	DeathUI.title.TextColor3 = C.White
	DeathUI.title.TextWrapped = true
	DeathUI.title.Text = "Name Here"
	DeathUI.title.ZIndex = 122
	DeathUI.title.Parent = DeathUI.headerSection

	-- MOBILE FIX: Responsive lifespan text
	local lifespanY = titleLabelY + px(36)
	DeathUI.lifespan = Instance.new("TextLabel")
	DeathUI.lifespan.Name = "Lifespan"
	DeathUI.lifespan.Size = UDim2.new(1, 0, 0, px(24))
	DeathUI.lifespan.Position = UDim2.new(0, 0, 0, lifespanY)
	DeathUI.lifespan.BackgroundTransparency = 1
	DeathUI.lifespan.Font = F.Body
	DeathUI.lifespan.TextSize = textSize(16)
	DeathUI.lifespan.TextColor3 = C.Gray300
	DeathUI.lifespan.Text = "2000 - 2080 (80 years)"
	DeathUI.lifespan.ZIndex = 122
	DeathUI.lifespan.Parent = DeathUI.headerSection

	-- Cause of death
	DeathUI.cause = Instance.new("TextLabel")
	DeathUI.cause.Size = UDim2.new(0.9, 0, 0, 0)
	DeathUI.cause.Position = UDim2.new(0.05, 0, 0, 235)
	DeathUI.cause.AutomaticSize = Enum.AutomaticSize.Y
	DeathUI.cause.BackgroundTransparency = 1
	DeathUI.cause.Font = F.Body
	DeathUI.cause.TextSize = 14
	DeathUI.cause.TextColor3 = C.Gray400
	DeathUI.cause.TextWrapped = true
	DeathUI.cause.Text = "Cause of death"
	DeathUI.cause.ZIndex = 122
	DeathUI.cause.Parent = DeathUI.headerSection

	-- Stats container
	DeathUI.statsSection = Instance.new("Frame")
	DeathUI.statsSection.Name = "StatsSection"
	DeathUI.statsSection.Size = UDim2.new(1, 0, 0, 0)
	DeathUI.statsSection.AutomaticSize = Enum.AutomaticSize.Y
	DeathUI.statsSection.BackgroundColor3 = Color3.fromRGB(20, 25, 32)
	DeathUI.statsSection.ZIndex = 121
	DeathUI.statsSection.LayoutOrder = 2
	DeathUI.statsSection.Parent = DeathUI.scroll

	local statsSectionPad = Instance.new("UIPadding")
	statsSectionPad.PaddingTop = UDim.new(0, 20)
	statsSectionPad.PaddingBottom = UDim.new(0, 20)
	statsSectionPad.PaddingLeft = UDim.new(0, 16)
	statsSectionPad.PaddingRight = UDim.new(0, 16)
	statsSectionPad.Parent = DeathUI.statsSection

	local statsSectionLayout = Instance.new("UIListLayout")
	statsSectionLayout.Padding = UDim.new(0, 12)
	statsSectionLayout.SortOrder = Enum.SortOrder.LayoutOrder
	statsSectionLayout.Parent = DeathUI.statsSection

	-- Stats title
	local statsTitle = Instance.new("TextLabel")
	statsTitle.Name = "StatsTitle"
	statsTitle.Size = UDim2.new(1, 0, 0, 28)
	statsTitle.BackgroundTransparency = 1
	statsTitle.Font = F.Title
	statsTitle.TextSize = 18
	statsTitle.TextColor3 = C.White
	statsTitle.TextXAlignment = Enum.TextXAlignment.Left
	statsTitle.Text = "ğŸ“Š LIFE STATISTICS"
	statsTitle.LayoutOrder = 0
	statsTitle.ZIndex = 122
	statsTitle.Parent = DeathUI.statsSection

	DeathUI.statsFrame = Instance.new("Frame")
	DeathUI.statsFrame.Name = "StatsFrame"
	DeathUI.statsFrame.Size = UDim2.new(1, 0, 0, 0)
	DeathUI.statsFrame.AutomaticSize = Enum.AutomaticSize.Y
	DeathUI.statsFrame.BackgroundTransparency = 1
	DeathUI.statsFrame.LayoutOrder = 1
	DeathUI.statsFrame.ZIndex = 122
	DeathUI.statsFrame.Parent = DeathUI.statsSection

	local deathStatsLayout = Instance.new("UIListLayout")
	deathStatsLayout.Padding = UDim.new(0, 8)
	deathStatsLayout.Parent = DeathUI.statsFrame

	-- Achievements section
	DeathUI.achievementsSection = Instance.new("Frame")
	DeathUI.achievementsSection.Name = "AchievementsSection"
	DeathUI.achievementsSection.Size = UDim2.new(1, 0, 0, 0)
	DeathUI.achievementsSection.AutomaticSize = Enum.AutomaticSize.Y
	DeathUI.achievementsSection.BackgroundColor3 = Color3.fromRGB(25, 30, 38)
	DeathUI.achievementsSection.ZIndex = 121
	DeathUI.achievementsSection.LayoutOrder = 3
	DeathUI.achievementsSection.Parent = DeathUI.scroll

	local achievePad = Instance.new("UIPadding")
	achievePad.PaddingTop = UDim.new(0, 16)
	achievePad.PaddingBottom = UDim.new(0, 16)
	achievePad.PaddingLeft = UDim.new(0, 16)
	achievePad.PaddingRight = UDim.new(0, 16)
	achievePad.Parent = DeathUI.achievementsSection

	local achieveLayout = Instance.new("UIListLayout")
	achieveLayout.Padding = UDim.new(0, 10)
	achieveLayout.SortOrder = Enum.SortOrder.LayoutOrder
	achieveLayout.Parent = DeathUI.achievementsSection

	local achieveTitle = Instance.new("TextLabel")
	achieveTitle.Name = "AchieveTitle"
	achieveTitle.Size = UDim2.new(1, 0, 0, 24)
	achieveTitle.BackgroundTransparency = 1
	achieveTitle.Font = F.Title
	achieveTitle.TextSize = 16
	achieveTitle.TextColor3 = C.Gold or Color3.fromRGB(255, 193, 7)
	achieveTitle.TextXAlignment = Enum.TextXAlignment.Left
	achieveTitle.Text = "ğŸ† ACHIEVEMENTS"
	achieveTitle.LayoutOrder = 0
	achieveTitle.ZIndex = 122
	achieveTitle.Parent = DeathUI.achievementsSection

	DeathUI.achieveFrame = Instance.new("Frame")
	DeathUI.achieveFrame.Name = "AchieveFrame"
	DeathUI.achieveFrame.Size = UDim2.new(1, 0, 0, 0)
	DeathUI.achieveFrame.AutomaticSize = Enum.AutomaticSize.Y
	DeathUI.achieveFrame.BackgroundTransparency = 1
	DeathUI.achieveFrame.LayoutOrder = 1
	DeathUI.achieveFrame.ZIndex = 122
	DeathUI.achieveFrame.Parent = DeathUI.achievementsSection

	local achieveListLayout = Instance.new("UIListLayout")
	achieveListLayout.Padding = UDim.new(0, 6)
	achieveListLayout.Parent = DeathUI.achieveFrame

	-- Epitaph section
	DeathUI.epitaphSection = Instance.new("Frame")
	DeathUI.epitaphSection.Name = "EpitaphSection"
	DeathUI.epitaphSection.Size = UDim2.new(1, 0, 0, 0)
	DeathUI.epitaphSection.AutomaticSize = Enum.AutomaticSize.Y
	DeathUI.epitaphSection.BackgroundColor3 = Color3.fromRGB(20, 25, 32)
	DeathUI.epitaphSection.ZIndex = 121
	DeathUI.epitaphSection.LayoutOrder = 4
	DeathUI.epitaphSection.Parent = DeathUI.scroll

	local epitaphPad = Instance.new("UIPadding")
	epitaphPad.PaddingTop = UDim.new(0, 16)
	epitaphPad.PaddingBottom = UDim.new(0, 24)
	epitaphPad.PaddingLeft = UDim.new(0, 20)
	epitaphPad.PaddingRight = UDim.new(0, 20)
	epitaphPad.Parent = DeathUI.epitaphSection

	DeathUI.epitaph = Instance.new("TextLabel")
	DeathUI.epitaph.Name = "Epitaph"
	DeathUI.epitaph.Size = UDim2.new(1, 0, 0, 0)
	DeathUI.epitaph.AutomaticSize = Enum.AutomaticSize.Y
	DeathUI.epitaph.BackgroundTransparency = 1
	DeathUI.epitaph.Font = F.Body
	DeathUI.epitaph.TextSize = 14
	DeathUI.epitaph.TextColor3 = C.Gray400
	DeathUI.epitaph.TextWrapped = true
	DeathUI.epitaph.TextXAlignment = Enum.TextXAlignment.Center
	DeathUI.epitaph.Text = ""
	DeathUI.epitaph.ZIndex = 122
	DeathUI.epitaph.Parent = DeathUI.epitaphSection

	-- Restart button section (EXPANDED: Time Machine + Continue as Kid + New Life + Promo)
	DeathUI.buttonSection = Instance.new("Frame")
	DeathUI.buttonSection.Name = "ButtonSection"
	-- CRITICAL FIX: Increased height to fit Continue as Kid button
	DeathUI.buttonSection.Size = UDim2.new(1, 0, 0, 380)
	DeathUI.buttonSection.BackgroundColor3 = Color3.fromRGB(15, 20, 25)
	DeathUI.buttonSection.ZIndex = 121
	DeathUI.buttonSection.LayoutOrder = 5
	DeathUI.buttonSection.Parent = DeathUI.scroll
	
	-- TIME MACHINE SECTION (BitLife-style premium feature)
	-- CRITICAL FIX #424: Use global hasTimeMachine cache, never downgrade true to false
	local function checkTimeMachineGamepass()
		-- If already true, don't even check - can't lose a purchased gamepass
		if hasTimeMachine then
			return true
		end
		if CheckGamepass then
			local success, owns = pcall(function()
				return CheckGamepass:InvokeServer("TIME_MACHINE")
			end)
			if success and owns == true then
				hasTimeMachine = true  -- ONLY upgrade to true, never downgrade
			end
		end
		return hasTimeMachine
	end
	
	local tmTitle = Instance.new("TextLabel")
	tmTitle.Size = UDim2.new(1, 0, 0, 30)
	tmTitle.Position = UDim2.new(0, 0, 0, 8)
	tmTitle.BackgroundTransparency = 1
	tmTitle.Font = F.Title
	tmTitle.TextSize = 16
	tmTitle.TextColor3 = Color3.fromRGB(255, 215, 0)
	tmTitle.Text = "â° TIME MACHINE"
	tmTitle.ZIndex = 122
	tmTitle.Parent = DeathUI.buttonSection
	DeathUI.tmTitle = tmTitle
	
	-- Time Machine buttons container
	local tmContainer = Instance.new("Frame")
	tmContainer.Size = UDim2.new(0.92, 0, 0, 85)
	tmContainer.Position = UDim2.new(0.04, 0, 0, 40)
	tmContainer.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
	tmContainer.ZIndex = 122
	tmContainer.Parent = DeathUI.buttonSection
	corner(tmContainer, 12)
	DeathUI.tmContainer = tmContainer
	
	local tmGrid = Instance.new("UIGridLayout")
	tmGrid.CellSize = UDim2.new(0.48, 0, 0, 36)
	tmGrid.CellPadding = UDim2.new(0.02, 0, 0, 6)
	tmGrid.HorizontalAlignment = Enum.HorizontalAlignment.Center
	tmGrid.SortOrder = Enum.SortOrder.LayoutOrder
	tmGrid.Parent = tmContainer
	
	local tmPad = Instance.new("UIPadding")
	tmPad.PaddingTop = UDim.new(0, 6)
	tmPad.PaddingLeft = UDim.new(0, 6)
	tmPad.PaddingRight = UDim.new(0, 6)
	tmPad.Parent = tmContainer
	
	-- CRITICAL FIX: Add "Get Unlimited Rewinds" promo button for users without gamepass
	local tmPromoContainer = Instance.new("Frame")
	tmPromoContainer.Name = "TimeMachinePromo"
	tmPromoContainer.Size = UDim2.new(0.92, 0, 0, 50)
	tmPromoContainer.Position = UDim2.new(0.04, 0, 0, 40)
	tmPromoContainer.BackgroundColor3 = Color3.fromRGB(45, 35, 60)
	tmPromoContainer.ZIndex = 122
	tmPromoContainer.Visible = false  -- Hidden by default, shown if no gamepass
	tmPromoContainer.Parent = DeathUI.buttonSection
	corner(tmPromoContainer, 12)
	DeathUI.tmPromoContainer = tmPromoContainer
	
	local tmPromoBtn = Instance.new("TextButton")
	tmPromoBtn.Size = UDim2.new(1, 0, 1, 0)
	tmPromoBtn.BackgroundTransparency = 1
	tmPromoBtn.Font = F.Title
	tmPromoBtn.TextSize = 15
	tmPromoBtn.TextColor3 = Color3.fromRGB(255, 215, 0)
	tmPromoBtn.Text = "ğŸ”“ Get Unlimited Rewinds!"
	tmPromoBtn.AutoButtonColor = false
	tmPromoBtn.ZIndex = 123
	tmPromoBtn.Parent = tmPromoContainer
	
	local tmPromoSubtext = Instance.new("TextLabel")
	tmPromoSubtext.Size = UDim2.new(1, 0, 0, 16)
	tmPromoSubtext.Position = UDim2.new(0, 0, 1, -18)
	tmPromoSubtext.BackgroundTransparency = 1
	tmPromoSubtext.Font = F.Body
	tmPromoSubtext.TextSize = 11
	tmPromoSubtext.TextColor3 = C.Gray400
	tmPromoSubtext.Text = "Go back anytime with Time Machine Pass"
	tmPromoSubtext.ZIndex = 123
	tmPromoSubtext.Parent = tmPromoContainer
	
	-- CRITICAL FIX: Promo button prompts gamepass purchase
	tmPromoBtn.MouseButton1Click:Connect(function()
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX #514: Use direct client-side prompt instead of server!
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		promptGamepassDirect("TIME_MACHINE")
	end)
	
	local tmOptions = { {5, "5 Years"}, {10, "10 Years"}, {20, "20 Years"}, {-1, "Baby"} }
	local tmButtons = {}
	
	for i, opt in ipairs(tmOptions) do
		local tmBtn = Instance.new("TextButton")
		tmBtn.Name = "TM_" .. opt[1]
		tmBtn.BackgroundColor3 = Color3.fromRGB(80, 70, 20)
		tmBtn.Font = F.Button
		tmBtn.TextSize = 13
		tmBtn.TextColor3 = Color3.fromRGB(255, 215, 0)
		tmBtn.Text = "â° " .. opt[2]
		tmBtn.AutoButtonColor = false
		tmBtn.LayoutOrder = i
		tmBtn.ZIndex = 123
		tmBtn.Parent = tmContainer
		corner(tmBtn, 8)
		table.insert(tmButtons, {btn = tmBtn, opt = opt})
		
		tmBtn.MouseButton1Click:Connect(function()
			local UseTimeMachine = remotesFolder:FindFirstChild("UseTimeMachine")
			if UseTimeMachine then
				tmBtn.Text = "â³..."
				local ok, result = pcall(function() return UseTimeMachine:InvokeServer(opt[1]) end)
				if ok and result and result.success then
					-- CRITICAL FIX: After Time Machine success:
					-- 1. Hide the death overlay
					-- 2. Update the current state from server result
					-- 3. Refresh the UI to show new age/stats
					hideDeathOverlay()
					
					-- Update currentState with new age if provided
					if result.newAge then
						currentState.Age = result.newAge
						currentState.Health = 100 -- Restore health
						currentState.Stats = currentState.Stats or {}
						currentState.Stats.Health = 100
						
						-- Clear death flags
						if currentState.Flags then
							currentState.Flags.dead = nil
						end
					end
					
					-- Refresh UI
					if updateFromState then
						updateFromState()
					end
				elseif ok and result and result.needsProduct then
					-- CRITICAL FIX #363: Player needs to purchase developer product (one-time use)
					tmBtn.Text = "ğŸ’° " .. opt[2]
					-- The server already prompted the product purchase
					-- The ProcessReceipt will handle the time travel
				elseif ok and result and result.needsGamepass then
					-- CRITICAL FIX: Player needs to purchase the gamepass for unlimited uses
					tmBtn.Text = "ğŸ‘‘ " .. opt[2]
					-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
					-- CRITICAL FIX #515: Use direct client-side prompt instead of server!
					-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
					promptGamepassDirect("TIME_MACHINE")
				else
					tmBtn.Text = "â° " .. opt[2]
				end
			end
		end)
	end
	
	-- CRITICAL FIX #425: Function to update Time Machine UI based on gamepass ownership
	-- Uses global hasTimeMachine cache that NEVER downgrades true to false
	DeathUI.updateTimeMachineUI = function()
		-- Check if already true (purchased this session), if so don't even call server
		if not hasTimeMachine then
			-- Only call server if we don't already know they own it
			if CheckGamepass then
				local ok, owns = pcall(function() return CheckGamepass:InvokeServer("TIME_MACHINE") end)
				if ok and owns == true then
					hasTimeMachine = true  -- ONLY upgrade to true
				end
			end
		end
		
		if hasTimeMachine then
			-- User owns gamepass - show full time machine UI with UNLIMITED badge
			tmContainer.Visible = true
			tmPromoContainer.Visible = false
			tmTitle.Text = "â° TIME MACHINE (UNLIMITED)"
			tmTitle.TextColor3 = Color3.fromRGB(255, 215, 0)
			for _, data in ipairs(tmButtons) do
				data.btn.BackgroundColor3 = Color3.fromRGB(80, 70, 20)
				data.btn.TextColor3 = Color3.fromRGB(255, 215, 0)
				data.btn.Text = "â° " .. data.opt[2]
			end
		else
			-- User doesn't own gamepass - show one-time purchase options
			tmContainer.Visible = true
			tmPromoContainer.Visible = true
			tmPromoContainer.Position = UDim2.new(0.04, 0, 0, 130)
			tmTitle.Text = "â° TIME MACHINE"
			tmTitle.TextColor3 = Color3.fromRGB(200, 170, 60)
			-- Buttons work but will cost Robux per use (Developer Products)
			for _, data in ipairs(tmButtons) do
				data.btn.BackgroundColor3 = Color3.fromRGB(60, 50, 30)
				data.btn.TextColor3 = Color3.fromRGB(200, 170, 60)
				data.btn.Text = "ğŸ’° " .. data.opt[2]
			end
		end
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FEATURE: Continue as Your Kid Button
	-- User requested: "I WANT A CONTINUE AS YOUR KID BUTTON WHEN YOU DIE"
	-- Allows player to continue as their adult child (18+) with inherited assets
	-- Can only be used ONCE per life (not infinitely)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	DeathUI.continueAsKidBtn = Instance.new("TextButton")
	DeathUI.continueAsKidBtn.Size = UDim2.new(0.85, 0, 0, 56)
	DeathUI.continueAsKidBtn.Position = UDim2.new(0.075, 0, 0, 195)
	DeathUI.continueAsKidBtn.BackgroundColor3 = Color3.fromRGB(88, 86, 214) -- Purple
	DeathUI.continueAsKidBtn.Font = F.Button
	DeathUI.continueAsKidBtn.TextSize = 18
	DeathUI.continueAsKidBtn.TextColor3 = C.White
	DeathUI.continueAsKidBtn.Text = "ğŸ‘¶ Continue as Your Child"
	DeathUI.continueAsKidBtn.AutoButtonColor = false
	DeathUI.continueAsKidBtn.ZIndex = 122
	DeathUI.continueAsKidBtn.Visible = false -- Hidden by default, shown if eligible
	DeathUI.continueAsKidBtn.Parent = DeathUI.buttonSection
	corner(DeathUI.continueAsKidBtn, 16)
	
	local kidBtnHoverColor = Color3.fromRGB(76, 73, 186) -- Darker purple
	DeathUI.continueAsKidBtn.MouseEnter:Connect(function()
		tween(DeathUI.continueAsKidBtn, TweenInfo.new(0.12), { BackgroundColor3 = kidBtnHoverColor })
	end)
	DeathUI.continueAsKidBtn.MouseLeave:Connect(function()
		tween(DeathUI.continueAsKidBtn, TweenInfo.new(0.12), { BackgroundColor3 = Color3.fromRGB(88, 86, 214) })
	end)
	
	-- Handler for Continue as Kid button
	local ContinueAsKid = remotesFolder:FindFirstChild("ContinueAsKid")
	DeathUI.continueAsKidBtn.MouseButton1Click:Connect(function()
		if not DeathUI._continueAsKidData then return end
		
		DeathUI.continueAsKidBtn.Text = "â³ Inheriting legacy..."
		
		if ContinueAsKid then
			local ok, result = pcall(function()
				return ContinueAsKid:InvokeServer(DeathUI._continueAsKidData.child)
			end)
			
			if ok and result and result.success then
				-- Success! Hide death overlay and refresh
				hideDeathOverlay()
				if updateFromState then
					updateFromState()
				end
			else
				-- Failed - show error
				DeathUI.continueAsKidBtn.Text = "âŒ " .. (result and result.message or "Failed")
				task.delay(2, function()
					if DeathUI._continueAsKidData then
						local child = DeathUI._continueAsKidData.child
						DeathUI.continueAsKidBtn.Text = string.format("ğŸ‘¶ Continue as %s", child.name or "Your Child")
					end
				end)
			end
		else
			DeathUI.continueAsKidBtn.Text = "âŒ Feature unavailable"
		end
	end)

	DeathUI.restart = Instance.new("TextButton")
	DeathUI.restart.Size = UDim2.new(0.85, 0, 0, 56)
	-- CRITICAL FIX: Moved down to accommodate Continue as Kid button
	DeathUI.restart.Position = UDim2.new(0.075, 0, 0, 260)
	DeathUI.restart.BackgroundColor3 = C.Green
	DeathUI.restart.Font = F.Button
	DeathUI.restart.TextSize = 20
	DeathUI.restart.TextColor3 = C.White
	DeathUI.restart.Text = "ğŸ”„ Start New Life"
	DeathUI.restart.AutoButtonColor = false
	DeathUI.restart.ZIndex = 122
	DeathUI.restart.Parent = DeathUI.buttonSection
	corner(DeathUI.restart, 16)

	DeathUI.restart.MouseEnter:Connect(function()
		tween(DeathUI.restart, TweenInfo.new(0.12), { BackgroundColor3 = C.GreenDark })
	end)
	DeathUI.restart.MouseLeave:Connect(function()
		tween(DeathUI.restart, TweenInfo.new(0.12), { BackgroundColor3 = C.Green })
	end)

	local ResetLife = remotesFolder:FindFirstChild("ResetLife")

	DeathUI.restart.MouseButton1Click:Connect(function()
		if ResetLife then
			DeathUI.restart.Text = "Starting new life..."
			ResetLife:FireServer()
		end
	end)
end

-- Build the Death UI immediately
buildDeathUI()

-- Helper to create a stat row
local function createDeathStatRow(icon, label, value, color, order)
	local row = Instance.new("Frame")
	row.Size = UDim2.new(1, 0, 0, 36)
	row.BackgroundColor3 = Color3.fromRGB(35, 40, 50)
	row.LayoutOrder = order or 0
	row.ZIndex = 123
	corner(row, 10)

	local lbl = Instance.new("TextLabel")
	lbl.Size = UDim2.new(0.55, 0, 1, 0)
	lbl.Position = UDim2.new(0, 12, 0, 0)
	lbl.BackgroundTransparency = 1
	lbl.Font = F.Medium
	lbl.TextSize = 14
	lbl.TextColor3 = C.Gray300
	lbl.TextXAlignment = Enum.TextXAlignment.Left
	lbl.Text = icon .. " " .. label
	lbl.ZIndex = 124
	lbl.Parent = row

	local val = Instance.new("TextLabel")
	val.Size = UDim2.new(0.45, -12, 1, 0)
	val.Position = UDim2.new(0.55, 0, 0, 0)
	val.BackgroundTransparency = 1
	val.Font = F.Title
	val.TextSize = 14
	val.TextColor3 = color or C.White
	val.TextXAlignment = Enum.TextXAlignment.Right
	val.Text = tostring(value)
	val.ZIndex = 124
	val.Parent = row
	
	return row
end

-- Helper to create achievement badge
local function createAchievementBadge(icon, text, order)
	local badge = Instance.new("Frame")
	badge.Size = UDim2.new(1, 0, 0, 32)
	badge.BackgroundColor3 = Color3.fromRGB(45, 40, 20)
	badge.LayoutOrder = order or 0
	badge.ZIndex = 123
	corner(badge, 8)
	
	local lbl = Instance.new("TextLabel")
	lbl.Size = UDim2.new(1, -16, 1, 0)
	lbl.Position = UDim2.new(0, 8, 0, 0)
	lbl.BackgroundTransparency = 1
	lbl.Font = F.Medium
	lbl.TextSize = 13
	lbl.TextColor3 = C.Gold or Color3.fromRGB(255, 193, 7)
	lbl.TextXAlignment = Enum.TextXAlignment.Left
	lbl.Text = icon .. " " .. text
	lbl.ZIndex = 124
	lbl.Parent = badge
	
	return badge
end

showDeathOverlay = function(causeText, age, canContinueAsKid, continueAsKidData)
	local name = currentState.Name or "Unknown"
	local finalAge = age or currentState.Age or 0
	local birthYear = 2024 - finalAge
	local deathYear = 2024
	
	DeathUI.title.Text = name
	DeathUI.lifespan.Text = string.format("%d - %d (%d years)", birthYear, deathYear, finalAge)
	DeathUI.cause.Text = causeText or "Natural causes"
	DeathUI.overlay.Visible = true
	DeathUI.restart.Text = "ğŸ”„ Start New Life"
	DeathUI.scroll.CanvasPosition = Vector2.new(0, 0)
	
	-- CRITICAL FIX: Update Time Machine UI based on gamepass ownership
	if DeathUI.updateTimeMachineUI then
		DeathUI.updateTimeMachineUI()
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FEATURE: Continue as Your Kid button
	-- User requested: "I WANT A CONTINUE AS YOUR KID BUTTON WHEN YOU DIE"
	-- Shows only if player has adult children to continue as
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	if DeathUI.continueAsKidBtn then
		if canContinueAsKid and continueAsKidData and continueAsKidData.child then
			local child = continueAsKidData.child
			DeathUI.continueAsKidBtn.Visible = true
			DeathUI.continueAsKidBtn.Text = string.format("ğŸ‘¶ Continue as %s (Age %d)", child.name or "Your Child", child.age or 18)
			
			-- Store data for the button click handler
			DeathUI._continueAsKidData = continueAsKidData
		else
			DeathUI.continueAsKidBtn.Visible = false
			DeathUI._continueAsKidData = nil
		end
	end

	-- Clear old stats
	for _, child in ipairs(DeathUI.statsFrame:GetChildren()) do
		if child:IsA("Frame") then child:Destroy() end
	end
	for _, child in ipairs(DeathUI.achieveFrame:GetChildren()) do
		if child:IsA("Frame") then child:Destroy() end
	end

	-- Gather comprehensive stats
	local stats = currentState.Stats or {}
	local money = currentState.Money or 0
	local happiness = stats.Happiness or currentState.Happiness or 50
	local health = stats.Health or currentState.Health or 0
	local smarts = stats.Smarts or currentState.Smarts or 50
	local looks = stats.Looks or currentState.Looks or 50
	local education = currentState.Education or "None"
	
	-- CRITICAL FIX: Use career history if no current job (e.g., retired, fired, etc.)
	-- This fixes the bug where death screen shows "Unemployed" even when player had jobs
	-- BUG FIX: Check ALL possible field names (Title/title, name/Name, Job/CurrentJob)
	local career = "Unemployed"
	
	-- Check CurrentJob with all possible field name variations
	local currentJob = currentState.CurrentJob or currentState.Job
	if currentJob then
		local jobTitle = currentJob.Title or currentJob.title or currentJob.name or currentJob.Name or currentJob.jobTitle
		if jobTitle and jobTitle ~= "" and jobTitle ~= "Unemployed" then
			career = jobTitle
		end
	end
	
	-- If still unemployed, check career history
	if career == "Unemployed" then
		if currentState.CareerInfo then
			-- Check lastJob
			local lastJob = currentState.CareerInfo.lastJob or currentState.CareerInfo.LastJob
			if lastJob then
				local jobTitle = lastJob.title or lastJob.Title or lastJob.name or lastJob.Name
				if jobTitle and jobTitle ~= "" then
					career = jobTitle .. " (Retired)"
				end
			end
			
			-- Check careerHistory array
			if career == "Unemployed" then
				local history = currentState.CareerInfo.careerHistory or currentState.CareerInfo.CareerHistory or {}
				if #history > 0 then
					local lastCareer = history[#history]
					if lastCareer then
						local jobTitle = lastCareer.title or lastCareer.Title or lastCareer.name or lastCareer.Name
						if jobTitle and jobTitle ~= "" then
							career = jobTitle .. " (Former)"
						end
					end
				end
			end
		end
		
		-- Check flags for previous career
		if career == "Unemployed" and currentState.Flags then
			local prevCareer = currentState.Flags.previous_career or currentState.Flags.previousCareer or currentState.Flags.last_job
			if prevCareer and prevCareer ~= "" then
				career = prevCareer .. " (Former)"
			end
		end
		
		-- Check ExtendedState if available
		if career == "Unemployed" and currentState.ExtendedState then
			local ext = currentState.ExtendedState
			local jobTitle = ext.CurrentJobTitle or ext.LastJobTitle or ext.JobTitle
			if jobTitle and jobTitle ~= "" and jobTitle ~= "Unemployed" then
				career = jobTitle
			end
		end
	end
	
	local flags = currentState.Flags or {}
	local assets = currentState.Assets or {}
	
	-- Count assets
	local propertyCount = assets.Properties and #assets.Properties or 0
	local vehicleCount = assets.Vehicles and #assets.Vehicles or 0
	local itemCount = assets.Items and #assets.Items or 0
	
	-- Count relationships
	local relationships = currentState.Relationships or {}
	local relationshipCount = 0
	local childCount = 0
	local marriageCount = 0
	for _, rel in pairs(relationships) do
		relationshipCount = relationshipCount + 1
		if rel.Type == "Child" then childCount = childCount + 1 end
		if rel.Type == "Spouse" then marriageCount = marriageCount + 1 end
	end
	
	-- CRITICAL FIX: Calculate actual Net Worth (cash + assets)
	-- User confusion: "I had 300 mil but couldn't buy 1k item"
	-- This was because Net Worth â‰  Cash! Assets can't be spent directly.
	local netWorth = money -- Start with cash
	if assets.Properties then
		for _, prop in ipairs(assets.Properties) do
			netWorth = netWorth + (prop.value or prop.price or 0)
		end
	end
	if assets.Vehicles then
		for _, vehicle in ipairs(assets.Vehicles) do
			netWorth = netWorth + (vehicle.value or vehicle.price or 0)
		end
	end
	if assets.Items then
		for _, item in ipairs(assets.Items) do
			netWorth = netWorth + (item.value or item.price or 0)
		end
	end
	
	-- Create stat rows - FIXED: Show Cash AND Net Worth separately!
	local statList = {
		{ icon = "ğŸ‚", label = "Years Lived", value = finalAge .. " years", color = C.White, order = 1 },
		{ icon = "ğŸ’µ", label = "Cash", value = formatMoney(money), color = money >= 100000 and C.Green or C.White, order = 2 },
		{ icon = "ğŸ’°", label = "Net Worth", value = formatMoney(netWorth), color = netWorth >= 1000000 and C.Gold or (netWorth >= 100000 and C.Green or C.White), order = 3 },
		{ icon = "ğŸ˜€", label = "Final Happiness", value = happiness .. "%", color = happiness >= 70 and C.Green or (happiness >= 40 and C.Amber or C.Red), order = 4 },
		{ icon = "â¤ï¸", label = "Final Health", value = health .. "%", color = C.Red, order = 5 },
		{ icon = "ğŸ§ ", label = "Intelligence", value = smarts .. "%", color = C.Blue, order = 6 },
		{ icon = "âœ¨", label = "Looks", value = looks .. "%", color = C.Purple, order = 7 },
		{ icon = "ğŸ“", label = "Education", value = education == "none" and (finalAge < 18 and "In School" or "None") or education:gsub("^%l", string.upper):gsub("_", " "), color = C.Teal, order = 8 },
		{ icon = "ğŸ’¼", label = "Last Career", value = career, color = C.Amber, order = 9 },
		{ icon = "ğŸ ", label = "Properties", value = propertyCount, color = C.White, order = 10 },
		{ icon = "ğŸš—", label = "Vehicles", value = vehicleCount, color = C.White, order = 11 },
		{ icon = "ğŸ“¦", label = "Items", value = itemCount, color = C.White, order = 12 },
		{ icon = "ğŸ‘¥", label = "Relationships", value = relationshipCount, color = C.Pink or C.Purple, order = 13 },
		{ icon = "ğŸ‘¶", label = "Children", value = childCount, color = C.White, order = 14 },
		{ icon = "ğŸ’", label = "Marriages", value = marriageCount, color = C.White, order = 15 },
	}
	
	for _, s in ipairs(statList) do
		local row = createDeathStatRow(s.icon, s.label, s.value, s.color, s.order)
		row.Parent = DeathUI.statsFrame
	end
	
	-- Generate achievements (EXPANDED - BitLife-style comprehensive list)
	local achievements = {}
	
	-- Age achievements
	if finalAge >= 100 then
		table.insert(achievements, { icon = "ğŸ–ï¸", text = "Centenarian - Lived 100+ years!" })
	elseif finalAge >= 80 then
		table.insert(achievements, { icon = "ğŸ‘´", text = "Golden Years - Lived to 80+" })
	elseif finalAge >= 65 then
		table.insert(achievements, { icon = "ğŸ§“", text = "Retiree - Made it to 65+" })
	end
	
	-- Early death achievements
	if finalAge < 20 then
		table.insert(achievements, { icon = "ğŸ˜¢", text = "Gone Too Soon - Died before 20" })
	elseif finalAge < 40 then
		table.insert(achievements, { icon = "ğŸ’”", text = "Life Cut Short - Died before 40" })
	end
	
	-- Wealth achievements
	if money >= 100000000 then
		table.insert(achievements, { icon = "ğŸ‘‘", text = "Billionaire Club - $100M+ net worth" })
	elseif money >= 10000000 then
		table.insert(achievements, { icon = "ğŸ’", text = "Mega Millionaire - $10M+ net worth" })
	elseif money >= 1000000 then
		table.insert(achievements, { icon = "ğŸ’°", text = "Millionaire - $1M+ net worth" })
	elseif money >= 100000 then
		table.insert(achievements, { icon = "ğŸ¦", text = "Wealthy - $100K+ net worth" })
	elseif money < 0 then
		table.insert(achievements, { icon = "ğŸ’¸", text = "In Debt - Died owing money" })
	elseif money < 1000 then
		table.insert(achievements, { icon = "ğŸª™", text = "Broke - Died nearly penniless" })
	end
	
	-- Happiness achievements
	if happiness >= 90 then
		table.insert(achievements, { icon = "ğŸ˜Š", text = "Joyful Life - 90%+ happiness" })
	elseif happiness < 20 then
		table.insert(achievements, { icon = "ğŸ˜", text = "Miserable - Low happiness" })
	end
	
	-- Intelligence achievements
	if smarts >= 90 then
		table.insert(achievements, { icon = "ğŸ§ ", text = "Genius - 90%+ intelligence" })
	end
	
	-- Looks achievements
	if looks >= 90 then
		table.insert(achievements, { icon = "ğŸ˜", text = "Gorgeous - 90%+ looks" })
	end
	
	-- Education achievements
	if education == "phd" or education == "doctorate" then
		table.insert(achievements, { icon = "ğŸ“š", text = "Scholar - Earned a Doctorate" })
	elseif education == "master" then
		table.insert(achievements, { icon = "ğŸ“", text = "Academic - Master's Degree" })
	elseif education == "law" then
		table.insert(achievements, { icon = "âš–ï¸", text = "Lawyer - Earned a Law Degree" })
	elseif education == "medical" then
		table.insert(achievements, { icon = "ğŸ¥", text = "Doctor - Earned a Medical Degree" })
	elseif education == "bachelor" then
		table.insert(achievements, { icon = "ğŸ“", text = "Graduate - Bachelor's Degree" })
	elseif education == "none" and finalAge >= 22 then
		table.insert(achievements, { icon = "ğŸš«", text = "No Degree - Never completed higher education" })
	end
	
	-- Family achievements
	if childCount >= 10 then
		table.insert(achievements, { icon = "ğŸ†", text = "Super Parent - 10+ children" })
	elseif childCount >= 5 then
		table.insert(achievements, { icon = "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦", text = "Big Family - 5+ children" })
	elseif childCount >= 1 then
		table.insert(achievements, { icon = "ğŸ‘¶", text = "Parent - Had children" })
	end
	
	if marriageCount >= 3 then
		table.insert(achievements, { icon = "ğŸ’", text = "Serial Spouse - Married 3+ times" })
	elseif marriageCount >= 1 then
		table.insert(achievements, { icon = "ğŸ’’", text = "Married - Found love" })
	end
	
	-- Property/Assets achievements
	if propertyCount >= 5 then
		table.insert(achievements, { icon = "ğŸ°", text = "Property Baron - 5+ properties" })
	elseif propertyCount >= 3 then
		table.insert(achievements, { icon = "ğŸ˜ï¸", text = "Real Estate Mogul - 3+ properties" })
	elseif propertyCount >= 1 then
		table.insert(achievements, { icon = "ğŸ ", text = "Homeowner - Owned property" })
	end
	
	if vehicleCount >= 10 then
		table.insert(achievements, { icon = "ğŸï¸", text = "Car Enthusiast - 10+ vehicles" })
	elseif vehicleCount >= 5 then
		table.insert(achievements, { icon = "ğŸš—", text = "Car Collector - 5+ vehicles" })
	end
	
	-- Fame achievements
	if flags.famous or flags.celebrity then
		table.insert(achievements, { icon = "â­", text = "Famous - Became a celebrity" })
	end
	
	-- Crime achievements
	if flags.criminal_mastermind then
		table.insert(achievements, { icon = "ğŸ¦¹", text = "Criminal Mastermind" })
	end
	if flags.served_time or flags.ex_convict then
		table.insert(achievements, { icon = "â›“ï¸", text = "Ex-Con - Served prison time" })
	end
	if flags.never_caught and flags.criminal_record then
		table.insert(achievements, { icon = "ğŸ¥·", text = "Ghost - Never caught" })
	end
	
	-- Career achievements - CRITICAL FIX: Check career history, not just current job
	local hadCareer = career and career ~= "Unemployed" and career ~= ""
	local hasCareerHistory = currentState.CareerInfo and currentState.CareerInfo.careerHistory and #currentState.CareerInfo.careerHistory > 0
	local workedYears = currentState.CareerInfo and currentState.CareerInfo.totalYearsWorked or 0
	
	if hadCareer or hasCareerHistory or workedYears > 0 then
		if flags.ceo or flags.executive then
			table.insert(achievements, { icon = "ğŸ‘”", text = "Executive - Reached the top" })
		elseif flags.retired then
			table.insert(achievements, { icon = "ğŸ‰", text = "Retired - Earned retirement" })
		elseif workedYears >= 20 then
			table.insert(achievements, { icon = "ğŸ’¼", text = "Career Professional - Worked 20+ years" })
		elseif workedYears >= 10 then
			table.insert(achievements, { icon = "ğŸ“Š", text = "Experienced Worker - 10+ years in workforce" })
		end
	else
		-- Only show "Never held a job" if they TRULY never worked
		if finalAge >= 22 and not flags.employed and not flags.has_job and not flags.had_job then
			table.insert(achievements, { icon = "ğŸ˜´", text = "Unemployed - Never held a job" })
		end
	end
	
	-- Special achievements from flags
	if flags.war_hero then
		table.insert(achievements, { icon = "ğŸ–ï¸", text = "War Hero - Served honorably" })
	end
	if flags.olympic_gold or flags.champion then
		table.insert(achievements, { icon = "ğŸ…", text = "Champion - Won a major competition" })
	end
	if flags.viral or flags.influencer then
		table.insert(achievements, { icon = "ğŸ“±", text = "Influencer - Went viral" })
	end
	if flags.good_person or flags.philanthropist then
		table.insert(achievements, { icon = "ğŸ˜‡", text = "Good Samaritan - Helped others" })
	end
	if flags.world_traveler then
		table.insert(achievements, { icon = "âœˆï¸", text = "Globetrotter - Traveled the world" })
	end
	
	-- Default achievement if none earned
	if #achievements == 0 then
		table.insert(achievements, { icon = "ğŸŒŸ", text = "Lived a Life - Every journey counts" })
	end
	
	for i, achieve in ipairs(achievements) do
		local badge = createAchievementBadge(achieve.icon, achieve.text, i)
		badge.Parent = DeathUI.achieveFrame
	end
	
	-- Generate epitaph (EXPANDED - more variety and context-specific)
	local epitaphs = {
		"A life well lived, remembered by many.",
		"Gone but never forgotten.",
		"Their story may end, but their legacy lives on.",
		"Every moment was a gift.",
		"Beloved by those who knew them.",
		"Here lies one who made their mark on the world.",
		"They came, they lived, they mattered.",
		"In the end, it's not the years in your life that count, it's the life in your years.",
		"Rest in peace, forever in our hearts.",
		"Until we meet again.",
	}
	
	-- Context-specific epitaphs
	if money >= 10000000 then
		table.insert(epitaphs, "Died richer than most could dream.")
		table.insert(epitaphs, "Their wealth was legendary, their legacy even more so.")
	elseif money >= 1000000 then
		table.insert(epitaphs, "They say money can't buy happiness, but they sure tried.")
		table.insert(epitaphs, "Left behind a fortune and a legacy.")
	elseif money < 100 then
		table.insert(epitaphs, "Proved that money isn't everything.")
		table.insert(epitaphs, "Rich in spirit, if not in wallet.")
	end
	
	if happiness >= 90 then
		table.insert(epitaphs, "Lived life to the fullest with a smile.")
		table.insert(epitaphs, "Happiness was their greatest treasure.")
		table.insert(epitaphs, "Found joy in every day.")
	elseif happiness < 30 then
		table.insert(epitaphs, "May they find peace at last.")
		table.insert(epitaphs, "Rest now, the struggles are over.")
	end
	
	if finalAge >= 100 then
		table.insert(epitaphs, "A century of memories, a lifetime of love.")
		table.insert(epitaphs, "Proved that age is just a number.")
	elseif finalAge >= 90 then
		table.insert(epitaphs, "A long life filled with countless memories.")
		table.insert(epitaphs, "Witnessed history and made their own.")
	elseif finalAge < 20 then
		table.insert(epitaphs, "A candle that burned briefly but brightly.")
		table.insert(epitaphs, "Young in years, old in wisdom.")
	end
	
	if childCount >= 5 then
		table.insert(epitaphs, "Their greatest achievement: their family.")
		table.insert(epitaphs, "Surrounded by the love of many children.")
	elseif childCount >= 1 then
		table.insert(epitaphs, "Lives on through their children.")
	end
	
	if marriageCount >= 3 then
		table.insert(epitaphs, "Loved many, loved deeply.")
	elseif marriageCount >= 1 then
		table.insert(epitaphs, "Found true love in this lifetime.")
	end
	
	if flags.famous or flags.celebrity then
		table.insert(epitaphs, "A star that shone bright in the world.")
		table.insert(epitaphs, "Famous in life, legendary in death.")
	end
	
	if flags.criminal_record then
		table.insert(epitaphs, "Lived life by their own rules.")
		table.insert(epitaphs, "A complicated soul with a complicated past.")
	end
	
	if education == "phd" or education == "doctorate" then
		table.insert(epitaphs, "A brilliant mind, gone too soon.")
		table.insert(epitaphs, "Their knowledge lives on in their work.")
	end
	
	if propertyCount >= 3 then
		table.insert(epitaphs, "Built an empire, brick by brick.")
	end
	
	-- Random selection
	DeathUI.epitaph.Text = "\"" .. epitaphs[math.random(1, #epitaphs)] .. "\""
end

hideDeathOverlay = function()
	DeathUI.overlay.Visible = false
	DeathUI.restart.Text = "Start New Life"
end

----------------------------------------------------------------
-- EVENT CATEGORY COLORS (BitLife-style themed borders)
----------------------------------------------------------------

local CategoryColors = {
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Comprehensive category colors for proper visual feedback
	-- User complaint: "bad cards have green border instead of red"
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	-- NEGATIVE EVENTS - RED (must be explicit about all bad things!)
	disaster = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	danger = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	emergency = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	failure = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	fired = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	arrested = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	jail = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	prison = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	death = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	negative = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	bad = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	crime_caught = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	eviction = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	homeless = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	breakup = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	divorce = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	accident = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	injury = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	diagnosis = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	disease = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	illness = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	rejected = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	expelled = { shell = C.Red, stroke = C.RedDark, flash = C.Red },
	
	-- HEALTH - ORANGE (concerning but not always bad)
	health = { shell = Color3.fromRGB(249, 115, 22), stroke = Color3.fromRGB(194, 65, 12), flash = C.Orange },
	medical = { shell = Color3.fromRGB(249, 115, 22), stroke = Color3.fromRGB(194, 65, 12), flash = C.Orange },

	-- POSITIVE EVENTS - GREEN
	success = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },
	escape = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },
	positive = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },
	promotion = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },
	inheritance = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },
	raise = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },
	hired = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },
	good = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },
	win = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },
	windfall = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },
	reward = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },
	
	-- ROMANCE/RELATIONSHIPS - PINK
	romance = { shell = C.Pink, stroke = Color3.fromRGB(219, 39, 119), flash = C.Pink },
	dating = { shell = C.Pink, stroke = Color3.fromRGB(219, 39, 119), flash = C.Pink },
	love = { shell = C.Pink, stroke = Color3.fromRGB(219, 39, 119), flash = C.Pink },
	wedding = { shell = Color3.fromRGB(255, 182, 193), stroke = Color3.fromRGB(219, 112, 147), flash = Color3.fromRGB(255, 192, 203) },

	-- CAREER/MONEY - BLUE  
	career = { shell = C.Blue, stroke = C.BlueDark, flash = C.Blue },
	job = { shell = C.Blue, stroke = C.BlueDark, flash = C.Blue },
	work = { shell = C.Blue, stroke = C.BlueDark, flash = C.Blue },

	-- FAMILY - PURPLE
	family = { shell = C.Purple, stroke = Color3.fromRGB(126, 34, 206), flash = C.Purple },
	birth = { shell = Color3.fromRGB(135, 206, 235), stroke = Color3.fromRGB(70, 130, 180), flash = Color3.fromRGB(176, 224, 230) },

	-- SCHOOL - TEAL
	school = { shell = Color3.fromRGB(20, 184, 166), stroke = Color3.fromRGB(13, 148, 136), flash = Color3.fromRGB(20, 184, 166) },
	education = { shell = Color3.fromRGB(20, 184, 166), stroke = Color3.fromRGB(13, 148, 136), flash = Color3.fromRGB(20, 184, 166) },

	-- SOCIAL - GREEN
	social = { shell = C.Green, stroke = C.GreenDark, flash = C.Green },

	-- MOTORSPORT/RACING - ORANGE/GOLD
	motorsport = { shell = Color3.fromRGB(245, 158, 11), stroke = Color3.fromRGB(217, 119, 6), flash = Color3.fromRGB(251, 191, 36) },
	racing = { shell = Color3.fromRGB(245, 158, 11), stroke = Color3.fromRGB(217, 119, 6), flash = Color3.fromRGB(251, 191, 36) },

	-- MILESTONE EVENTS - GOLD
	milestone = { shell = Color3.fromRGB(251, 191, 36), stroke = Color3.fromRGB(202, 138, 4), flash = Color3.fromRGB(253, 224, 71) },
	graduation = { shell = Color3.fromRGB(251, 191, 36), stroke = Color3.fromRGB(202, 138, 4), flash = Color3.fromRGB(253, 224, 71) },
	achievement = { shell = Color3.fromRGB(251, 191, 36), stroke = Color3.fromRGB(202, 138, 4), flash = Color3.fromRGB(253, 224, 71) },
	lottery = { shell = Color3.fromRGB(251, 191, 36), stroke = Color3.fromRGB(202, 138, 4), flash = Color3.fromRGB(253, 224, 71) },
	
	-- ROYAL - GOLD/PURPLE
	royal = { shell = Color3.fromRGB(147, 51, 234), stroke = Color3.fromRGB(126, 34, 206), flash = Color3.fromRGB(168, 85, 247) },
	royalty = { shell = Color3.fromRGB(147, 51, 234), stroke = Color3.fromRGB(126, 34, 206), flash = Color3.fromRGB(168, 85, 247) },
	
	-- MAFIA - DARK GRAY/BLACK
	mafia = { shell = Color3.fromRGB(55, 65, 81), stroke = Color3.fromRGB(31, 41, 55), flash = Color3.fromRGB(75, 85, 99) },
	crime = { shell = Color3.fromRGB(55, 65, 81), stroke = Color3.fromRGB(31, 41, 55), flash = Color3.fromRGB(75, 85, 99) },
	
	-- NEUTRAL/DEFAULT - Use BLUE instead of RED for neutral events
	-- RED should only be for explicitly bad events!
	neutral = { shell = C.Blue, stroke = C.BlueDark, flash = C.Blue },
	default = { shell = C.Blue, stroke = C.BlueDark, flash = C.Blue },
	life = { shell = C.Blue, stroke = C.BlueDark, flash = C.Blue },
}

-- Detect if event is a TRUE disaster/emergency (for visual effects)
-- NOTE: This should be VERY conservative - only actual life-threatening emergencies
-- Regular events (motorsport, career, social) should NOT trigger shake on appearance
local function isDisasterEvent(payload)
	local id = payload.id or ""
	local emoji = payload.emoji or ""
	local category = payload.category or ""
	local title = payload.title or ""

	-- Check ID prefix for explicit disaster events
	if id:match("^d_") or id:match("^disaster_") or id:match("^emergency_") then return true end

	-- Check dangerous emojis - ONLY actual disaster/death emojis
	-- Removed: ğŸš— (cars), ğŸ”« (crime), ğŸ˜¨ (general fear) - these are too broad
	local dangerEmojis = {"ğŸŒªï¸", "ğŸ”¥", "â›ˆï¸", "ğŸŒ€", "ğŸŒŠ", "â„ï¸", "ğŸŒ¡ï¸", "ğŸ’€", "â˜ ï¸", "ğŸ†˜", "ğŸ¥", "ğŸš¨"}
	for _, de in ipairs(dangerEmojis) do
		if emoji == de then return true end
	end

	-- Check category - only explicit disaster categories
	if category == "disaster" or category == "emergency" then
		return true
	end

	-- Check title keywords - only actual natural disasters and life-threatening emergencies
	local dangerWords = {"tornado", "hurricane", "earthquake", "flood", "blizzard", "tsunami", "wildfire", "heart attack", "stroke", "collapsed", "dying"}
	local lowerTitle = title:lower()
	for _, word in ipairs(dangerWords) do
		if lowerTitle:find(word) then return true end
	end

	return false
end

-- Get the appropriate color scheme for an event
local function getEventColors(payload)
	local category = payload.category or "default"

	-- Override for disaster events
	if isDisasterEvent(payload) then
		return CategoryColors.disaster
	end

	-- Check for category match
	if CategoryColors[category] then
		return CategoryColors[category]
	end

	return CategoryColors.default
end

----------------------------------------------------------------
-- EVENT FUNCTIONS
------------------------------------------------------------------

showEvent = function(payload)
	-- Validate payload first
	if not payload then
		warn("[LifeClient] âŒ showEvent called with nil payload!")
		awaitingEvent = false
		return
	end

	-- Cancel any in-progress hide animation to prevent race conditions
	if EventUI.currentHideTween then
		EventUI.currentHideTween:Cancel()
		EventUI.currentHideTween = nil
	end

	-- Wrap in pcall to catch errors and ensure awaitingEvent gets reset
	local success, errorMsg = pcall(function()
		awaitingEvent = true
		EventUI.currentEventId = payload.id
		clearChoices()

		-- Get category-based colors
		local colors = getEventColors(payload)
		local isDisaster = isDisasterEvent(payload)

		-- Apply themed shell color
		EventUI.shell.BackgroundColor3 = colors.shell
		local shellStroke = EventUI.shell:FindFirstChildOfClass("UIStroke")
		if shellStroke then
			shellStroke.Color = colors.stroke
		end

		-- header
		EventUI.header.Visible = payload.showRelationship or false
		if payload.showRelationship and payload.relationName then
			EventUI.nameLbl.Text = payload.relationName
			EventUI.relationLbl.Text  = payload.relationship or "Friend"
		end

		EventUI.emoji.Text     = payload.emoji or "ğŸ™‚"
		EventUI.title.Text     = payload.title or "Life Event"
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX: Dynamic text sizing - only shrink for VERY long text
		-- Normal cards should look the same as before!
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		local bodyText = payload.text or ""
		local textLen = #bodyText
		local baseBodyTextSize = Device.IS_TINY_PHONE and 14 or (Device.IS_SMALL_PHONE and 16 or textSize(18))
		local adjustedBodyTextSize = baseBodyTextSize
		local adjustedLineHeight = Device.IS_TINY_PHONE and 1.2 or (Device.IS_SMALL_PHONE and 1.25 or 1.35)
		
		-- Only shrink text for VERY long content (300+ characters)
		if textLen > 400 then
			adjustedBodyTextSize = Device.IS_TINY_PHONE and 11 or (Device.IS_SMALL_PHONE and 12 or 14)
			adjustedLineHeight = 1.1
		elseif textLen > 300 then
			adjustedBodyTextSize = Device.IS_TINY_PHONE and 12 or (Device.IS_SMALL_PHONE and 14 or 16)
			adjustedLineHeight = 1.15
		end
		
		-- CRITICAL FIX: Use safe text size setter to prevent UITextSizeConstraint errors
		safeSetTextSize(EventUI.body, adjustedBodyTextSize)
		EventUI.body.LineHeight = adjustedLineHeight
		EventUI.body.Text = bodyText
		EventUI.question.Text  = payload.question or "What will you do?"

		-- Body container uses AutomaticSize - NO scrolling, card expands to fit text

		local choiceHandlers = {}

		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX: DYNAMIC SCALING based on number of choices!
		-- User feedback: "should scale nicely depending on size, no scrolling"
		-- More choices = smaller buttons/text so everything fits on screen perfectly
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		local numChoices = #(payload.choices or {})
		local hasSurpriseBtn = numChoices >= 2  -- Surprise btn only shows for 2+ choices
		local totalButtons = numChoices + (hasSurpriseBtn and 1 or 0)
		
		-- Get screen dimensions for smart scaling
		local screenHeight = screenGui.AbsoluteSize.Y
		local screenWidth = screenGui.AbsoluteSize.X
		local safeHeight = screenHeight - 80  -- Account for header/notch
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX: PC vs MOBILE scaling!
		-- User bug: "PC THE BUTTONS GET TINY EVEN THO THERES MORE SCREEN SIZE"
		-- On PC with large screens, buttons should be BIGGER, not smaller!
		-- Only apply aggressive scaling on mobile devices where space is limited.
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		local isPC = not Device.IS_MOBILE
		local isLargeScreen = screenHeight >= 800 and screenWidth >= 1000
		
		-- PC gets larger card and no aggressive scaling
		local maxCardHeight
		if isPC or isLargeScreen then
			maxCardHeight = math.min(750, safeHeight)  -- PC can have taller cards
		else
			maxCardHeight = Device.IS_TINY_PHONE and 500 or (Device.IS_SMALL_PHONE and 560 or 650)
			maxCardHeight = math.min(maxCardHeight, safeHeight)
		end
		
		-- Base button sizing - PC gets appropriate values (not too big, not too small)
		local baseButtonHeight, baseSpacing, baseTextSize, baseCorner
		if isPC or isLargeScreen then
			-- CRITICAL FIX: Reduced by 20% - user said buttons were too big
			baseButtonHeight = 48  -- Was 56, now more reasonable
			baseSpacing = 8
			baseTextSize = 15  -- Was 18, now more readable
			baseCorner = 10
		elseif Device.IS_TINY_PHONE then
			baseButtonHeight = 32
			baseSpacing = 3
			baseTextSize = 10
			baseCorner = 5
		elseif Device.IS_SMALL_PHONE then
			baseButtonHeight = 38
			baseSpacing = 5
			baseTextSize = 12
			baseCorner = 7
		else
			baseButtonHeight = 48
			baseSpacing = 8
			baseTextSize = 15
			baseCorner = 10
		end
		
		-- Estimate content height to determine if we need to scale
		local estimatedBodyHeight = math.min(200, textLen * 0.5)
		local fixedContentHeight = 60 + 50 + 30 + 40
		local estimatedButtonsHeight = (baseButtonHeight + baseSpacing) * totalButtons
		local estimatedTotalHeight = fixedContentHeight + estimatedBodyHeight + estimatedButtonsHeight
		
		-- Calculate scale factor based on how much we need to shrink
		local scaleFactor = 1.0
		if estimatedTotalHeight > maxCardHeight then
			scaleFactor = maxCardHeight / estimatedTotalHeight
			-- PC has a higher minimum scale (don't shrink as much)
			local minScale = (isPC or isLargeScreen) and 0.75 or 0.55
			scaleFactor = math.max(minScale, scaleFactor)
		end
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX: COMPREHENSIVE MOBILE SCALING FOR MANY CHOICES!
		-- User bug: "8 CHOICES GOES OFF SCREEN ON MOBILE - TOP AND BOTTOM CUT OFF"
		-- When there are 5+ choices on mobile, we need to scale EVERYTHING:
		-- - Button height and text
		-- - Body text size
		-- - Emoji size
		-- - Title size
		-- - Padding/spacing
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		local isManyChoices = totalButtons >= 5
		local isVeryManyChoices = totalButtons >= 7
		local isExtremeChoices = totalButtons >= 9
		
		-- Additional scaling for many choices - LESS AGGRESSIVE ON PC
		if isPC or isLargeScreen then
			-- PC: Only scale down for 8+ choices, and not as much
			if totalButtons >= 8 then
				scaleFactor = math.min(scaleFactor, 0.80)
			elseif totalButtons >= 7 then
				scaleFactor = math.min(scaleFactor, 0.85)
			end
			-- 6 or fewer choices on PC = NO additional scaling needed
		else
			-- Mobile: Scale AGGRESSIVELY for screen fit
			-- User bug: "8 choices goes off screen"
			if isExtremeChoices then
				scaleFactor = math.min(scaleFactor, 0.48)  -- 9+ choices: 48% scale
			elseif totalButtons >= 8 then
				scaleFactor = math.min(scaleFactor, 0.52)  -- 8 choices: 52% scale
			elseif totalButtons >= 7 then
				scaleFactor = math.min(scaleFactor, 0.58)  -- 7 choices: 58% scale
			elseif totalButtons >= 6 then
				scaleFactor = math.min(scaleFactor, 0.68)  -- 6 choices: 68% scale
			elseif totalButtons >= 5 then
				scaleFactor = math.min(scaleFactor, 0.78)  -- 5 choices: 78% scale
			end
		end
		
		-- Apply scale factor to button sizing with device-appropriate minimums
		local minHeight = (isPC or isLargeScreen) and 40 or 18  -- Lower min for mobile with many choices
		local minTextSize = (isPC or isLargeScreen) and 14 or 7  -- Lower min text for mobile
		local minCorner = (isPC or isLargeScreen) and 8 or 2
		
		local baseMinHeight = math.max(minHeight, math.floor(baseButtonHeight * scaleFactor))
		local choiceBtnTextSize = math.max(minTextSize, math.floor(baseTextSize * scaleFactor))
		local choiceBtnCorner = math.max(minCorner, math.floor(baseCorner * scaleFactor))
		local choiceBtnPadH = (isPC or isLargeScreen) and 12 or (Device.IS_TINY_PHONE and 2 or (Device.IS_SMALL_PHONE and 3 or 6))
		local choiceBtnPadV = (isPC or isLargeScreen) and 6 or (Device.IS_TINY_PHONE and 1 or (Device.IS_SMALL_PHONE and 1 or 3))
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX: Scale EVERYTHING on mobile for many choices, not just buttons!
		-- User bug: "top of card and bottom cut off on mobile with 8 choices"
		-- We need to scale body text, emoji, title, etc. to fit everything
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		if not isPC and isManyChoices then
			-- Scale body text more aggressively
			local bodyScaleFactor = scaleFactor
			if isExtremeChoices then
				bodyScaleFactor = math.min(bodyScaleFactor, 0.55)
			elseif isVeryManyChoices then
				bodyScaleFactor = math.min(bodyScaleFactor, 0.65)
			end
			adjustedBodyTextSize = math.max(8, math.floor(adjustedBodyTextSize * bodyScaleFactor))
			adjustedLineHeight = math.max(0.95, 1.0)  -- Tighter line height
			safeSetTextSize(EventUI.body, adjustedBodyTextSize)
			EventUI.body.LineHeight = adjustedLineHeight
			
			-- Scale emoji size for many choices
			if EventUI.emoji then
				local emojiScale = isExtremeChoices and 0.5 or (isVeryManyChoices and 0.6 or 0.75)
				local baseEmojiSize = 48
				EventUI.emoji.TextSize = math.floor(baseEmojiSize * emojiScale)
			end
			
			-- Scale title for many choices
			if EventUI.title then
				local titleScale = isExtremeChoices and 0.65 or (isVeryManyChoices and 0.75 or 0.85)
				local baseTitleSize = 20
				safeSetTextSize(EventUI.title, math.max(12, math.floor(baseTitleSize * titleScale)))
			end
			
			-- Scale question text for many choices
			if EventUI.question then
				local questionScale = isExtremeChoices and 0.65 or (isVeryManyChoices and 0.75 or 0.85)
				local baseQuestionSize = 14
				safeSetTextSize(EventUI.question, math.max(10, math.floor(baseQuestionSize * questionScale)))
			end
		elseif scaleFactor < 0.85 and not isPC then
			-- Standard scaling for fewer choices but still need some reduction
			adjustedBodyTextSize = math.max(9, math.floor(adjustedBodyTextSize * scaleFactor))
			adjustedLineHeight = math.max(1.0, adjustedLineHeight * 0.9)
			safeSetTextSize(EventUI.body, adjustedBodyTextSize)
			EventUI.body.LineHeight = adjustedLineHeight
		end
		
		-- Tighten spacing based on scale factor (but keep generous on PC)
		local baseSpacingForDevice = (isPC or isLargeScreen) and 6 or (isManyChoices and 1 or 2)
		local choiceSpacing = math.max(baseSpacingForDevice, math.floor(baseSpacing * scaleFactor))
		
		-- Update the layout padding dynamically
		local choicesLayout = EventUI.choicesSection:FindFirstChildOfClass("UIListLayout")
		if choicesLayout then
			choicesLayout.Padding = UDim.new(0, choiceSpacing)
		end
		
		for i, choice in ipairs(payload.choices or {}) do
			local btn = Instance.new("TextButton")
			-- KEY: Let height auto-expand for long text
			btn.Size = UDim2.new(1, 0, 0, 0)
			btn.AutomaticSize = Enum.AutomaticSize.Y
			
			-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			-- CRITICAL FIX: Handle UNAVAILABLE choices (server already checked eligibility)
			-- Server sends unavailable=true for choices the player can't use
			-- This includes eligibility function checks (e.g., "need a job", "need partner")
			-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			local isUnavailable = choice.unavailable == true
			local unavailableReason = choice.unavailableReason or "Not available"
			
			-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			-- CRITICAL FIX #AFFORD-1: Check if player can AFFORD this choice!
			-- User feedback: "should just grey them out saying (cant afford)"
			-- Instead of hiding events, show ALL choices but gray out unaffordable ones
			-- This is better UX - players SEE options and know what they're missing!
			-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			local cannotAfford = false
			local choiceCost = 0
			
			-- Check effects.Money (negative = cost)
			if choice.effects and choice.effects.Money and choice.effects.Money < 0 then
				choiceCost = math.abs(choice.effects.Money)
			end
			
			-- Check explicit cost field
			if choice.cost and choice.cost > 0 then
				choiceCost = choice.cost
			end
			
			-- Compare with player's money
			if choiceCost > 0 then
				local playerMoney = currentState and currentState.Money or 0
				if playerMoney < choiceCost then
					cannotAfford = true
				end
			end
			
			-- If server marked as unavailable due to eligibility, treat as unavailable
			-- (This catches non-money eligibility like "need a job", "need partner", etc.)
			if isUnavailable and not cannotAfford then
				-- Server already determined this is unavailable for some reason
				-- The unavailableReason might say "You don't have a job" etc.
				cannotAfford = false  -- Keep isUnavailable handling for non-money reasons
			end
			
			-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			-- CRITICAL FIX: Premium choices have distinct GOLD/PURPLE colors!
			-- This makes it clear which choices require gamepasses
			-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			local isPremiumChoice = choice.requiresGamepass ~= nil
			local btnColor = C.Blue  -- Default color
			local btnDarkColor = C.BlueDark
			local strokeColor = C.BlueLight
			
			-- Override colors for unavailable OR unaffordable choices
			if isUnavailable or cannotAfford then
				btnColor = Color3.fromRGB(100, 100, 100)  -- Gray
				btnDarkColor = Color3.fromRGB(80, 80, 80)
				strokeColor = Color3.fromRGB(130, 130, 130)
			end
			
			if isPremiumChoice then
				-- Check which gamepass and use appropriate color
				local gp = choice.requiresGamepass
				if gp == "MAFIA" then
					btnColor = Color3.fromRGB(60, 60, 60)  -- Dark gray/black for mafia
					btnDarkColor = Color3.fromRGB(40, 40, 40)
					strokeColor = Color3.fromRGB(100, 100, 100)
				elseif gp == "CELEBRITY" then
					btnColor = Color3.fromRGB(147, 51, 234)  -- Purple for celebrity
					btnDarkColor = Color3.fromRGB(126, 34, 206)
					strokeColor = Color3.fromRGB(192, 132, 252)
				elseif gp == "ROYALTY" then
					btnColor = Color3.fromRGB(234, 179, 8)  -- Gold for royalty
					btnDarkColor = Color3.fromRGB(202, 138, 4)
					strokeColor = Color3.fromRGB(253, 224, 71)
				elseif gp == "GOD_MODE" then
					btnColor = Color3.fromRGB(239, 68, 68)  -- Red for god mode
					btnDarkColor = Color3.fromRGB(220, 38, 38)
					strokeColor = Color3.fromRGB(252, 165, 165)
				else
					btnColor = Color3.fromRGB(168, 85, 247)  -- Default purple for other premium
					btnDarkColor = Color3.fromRGB(147, 51, 234)
					strokeColor = Color3.fromRGB(216, 180, 254)
				end
			end
			
			btn.BackgroundColor3 = btnColor
			btn.Font = F.Button
			btn.TextSize = choiceBtnTextSize
			btn.TextColor3 = C.White
			
			-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			-- CRITICAL FIX #AFFORD-2: Show "(Can't Afford)" or reason for unavailable choices
			-- User feedback: "should just grey them out saying (cant afford)"
			-- Players can SEE all options but know which ones they can't pick!
			-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			local displayText = choice.text
			if cannotAfford then
				displayText = "ğŸ’° " .. displayText .. " (Can't Afford)"
				btn.TextColor3 = Color3.fromRGB(180, 180, 180)  -- Dimmed text
			elseif isUnavailable then
				-- Server marked this unavailable for non-money reasons (e.g., "need a job")
				-- Shorten long reasons for mobile display
				local shortReason = unavailableReason
				if #shortReason > 30 then
					shortReason = string.sub(shortReason, 1, 27) .. "..."
				end
				displayText = "ğŸš« " .. displayText .. " (" .. shortReason .. ")"
				btn.TextColor3 = Color3.fromRGB(180, 180, 180)  -- Dimmed text
			end
			btn.Text = displayText
			
			btn.AutoButtonColor = false
			btn.LayoutOrder = i
			btn.ZIndex = 65
			btn.TextWrapped = true
			btn.TextXAlignment = Enum.TextXAlignment.Center
			btn.TextYAlignment = Enum.TextYAlignment.Center
			btn.Parent = EventUI.choicesSection

			corner(btn, choiceBtnCorner)
			stroke(btn, isPremiumChoice and 2 or 1, 0.5, strokeColor)
			-- Add padding so text doesn't touch edges
			pad(btn, choiceBtnPadH, choiceBtnPadH, choiceBtnPadV, choiceBtnPadV)

			-- Enforce minimum tap height
			local sizeConstraint = Instance.new("UISizeConstraint")
			sizeConstraint.MinSize = Vector2.new(0, btnHeight(baseMinHeight))
			sizeConstraint.Parent = btn

			if choice.minigame then
				btn.Text = "ğŸ® " .. (cannotAfford and displayText or choice.text)
			end
			
			-- CRITICAL FIX: Add "ğŸ”’" indicator if player doesn't own required gamepass
			if isPremiumChoice then
				local ownsPass = false
				local gp = choice.requiresGamepass
				if gp == "GOD_MODE" then ownsPass = hasGodMode
				elseif gp == "MAFIA" then ownsPass = hasMafia
				elseif gp == "CELEBRITY" then ownsPass = hasCelebrity
				elseif gp == "ROYALTY" then ownsPass = hasRoyalty
				elseif gp == "TIME_MACHINE" then ownsPass = hasTimeMachine
				end
				
				if not ownsPass then
					-- Show lock icon to indicate they need to purchase
					btn.Text = "ğŸ”’ " .. choice.text
				end
			end

			-- Hover color only (no size change to prevent layout jumps)
			btn.MouseEnter:Connect(function()
				tween(btn, TweenInfo.new(0.1), { BackgroundColor3 = btnDarkColor })
			end)
			btn.MouseLeave:Connect(function()
				tween(btn, TweenInfo.new(0.1), { BackgroundColor3 = btnColor })
			end)

			local choiceIndex = choice.index or i
			local minigameType = choice.minigame
			-- CRITICAL FIX #CONTEXT-2: Extract minigame context from choice for proper question bank selection
			local minigameContext = choice.minigameContext or choice.context or "general"
			local minigameTitle = choice.minigameTitle or choice.title

			local function handleChoice()
				if not EventUI.currentEventId then return end
				
				-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				-- CRITICAL FIX: Block clicking UNAVAILABLE choices (from retry after can't afford)
				-- These choices are grayed out and player should pick a different one
				-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				if isUnavailable then
					-- Show feedback that this choice isn't available
					flashScreen(Color3.fromRGB(255, 100, 100), 0.5, 0.2)
					-- Don't process - they need to pick a different choice
					return
				end
				
				-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				-- CRITICAL FIX #AFFORD-3: Block clicking UNAFFORDABLE or UNAVAILABLE choices
				-- User feedback: "grey them out saying (cant afford)"
				-- Players can see but not select choices they can't afford or aren't eligible for!
				-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				if cannotAfford then
					-- Show feedback that player can't afford this
					flashScreen(Color3.fromRGB(255, 180, 100), 0.5, 0.2)  -- Orange flash
					-- Don't process - they need to pick an affordable choice
					return
				end
				
				if isUnavailable then
					-- Show feedback that player can't use this option
					flashScreen(Color3.fromRGB(200, 150, 100), 0.5, 0.2)  -- Brown flash for unavailable
					-- Don't process - they need to pick an available choice
					return
				end

				-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				-- CRITICAL FIX: CHECK GAMEPASS REQUIREMENTS BEFORE ALLOWING PREMIUM CHOICES!
				-- User feedback: "gamepass options when clicked don't check if I own gamepass"
				-- If choice requires a gamepass and player doesn't own it, prompt purchase!
				-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				if choice.requiresGamepass then
					local gamepassKey = choice.requiresGamepass
					local ownsPass = false
					
					-- Check ownership based on gamepass key
					if gamepassKey == "GOD_MODE" then
						ownsPass = hasGodMode
					elseif gamepassKey == "MAFIA" then
						ownsPass = hasMafia
					elseif gamepassKey == "CELEBRITY" then
						ownsPass = hasCelebrity
					elseif gamepassKey == "ROYALTY" then
						ownsPass = hasRoyalty
					elseif gamepassKey == "TIME_MACHINE" then
						ownsPass = hasTimeMachine
					end
					
					if not ownsPass then
						-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
						-- CRITICAL FIX #524: Use direct client-side prompt for premium choices!
						-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
						print("[LifeClient] Premium choice requires gamepass:", gamepassKey)
						promptGamepassDirect(gamepassKey)
						-- Don't process the choice - they need to buy the gamepass first
						return
					end
				end

				-- CRITICAL FIX #444: Handle mafia operations with callback instead of server
				if payload.isMafiaOperation and payload.onMafiaChoice then
					hideEvent()
					-- Call the mafia choice callback with the accumulated modifiers from the choice
					payload.onMafiaChoice(choiceIndex, choice.accumulatedMods or {})
					return
				end
				
				-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				-- CRITICAL FIX: Handle activity events with callback
				-- User feedback: "I CLICK ONE OF THE CHOICES AND IT JUST DISAPPEARS NUN ELSE POPUPS"
				-- This was missing - activity choices need to call back to show results!
				-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
				if payload.isActivityEvent and payload.onActivityChoice then
					hideEvent()
					-- Call the activity choice callback
					payload.onActivityChoice(choiceIndex, choice)
					return
				end

				if minigameType and minigamesInstance then
					pendingMinigameEventId     = EventUI.currentEventId
					pendingMinigameChoiceIndex = choiceIndex
					hideEvent()

					-- CRITICAL FIX #CONTEXT-3: Pass minigame options for proper question bank!
					local choiceMinigameOptions = {
						context = minigameContext,
						title = minigameTitle,
					}
					minigamesInstance:play(minigameType, function(won, data)
						SubmitChoice:FireServer(pendingMinigameEventId, pendingMinigameChoiceIndex)
						if MinigameResult then
							MinigameResult:FireServer(won, data)
						end
						pendingMinigameEventId     = nil
						pendingMinigameChoiceIndex = nil
					end, choiceMinigameOptions)
				else
					SubmitChoice:FireServer(EventUI.currentEventId, choiceIndex)
					hideEvent()
				end
			end

			btn.MouseButton1Click:Connect(handleChoice)
			table.insert(choiceHandlers, handleChoice)
			table.insert(EventUI.activeChoiceButtons, btn)
		end

		-- CRITICAL FIX: No scroll adjustment needed - card auto-expands to fit all buttons (BitLife-style)

		-- Only show Surprise Me when there are 2+ choices
		surpriseBtn.Visible = (payload.choices and #payload.choices >= 2) or false
		
		-- CRITICAL FIX: Scale surprise button to match choice buttons!
		-- User bug: "Surprise me cuts off at bottom"
		local surpriseBtnHeight = math.floor((Device.IS_TINY_PHONE and 28 or (Device.IS_SMALL_PHONE and 32 or 36)) * scaleFactor)
		local surpriseBtnTextSize = math.floor((Device.IS_TINY_PHONE and 10 or (Device.IS_SMALL_PHONE and 12 or 14)) * scaleFactor)
		surpriseBtn.Size = UDim2.new(1, 0, 0, surpriseBtnHeight)
		surpriseBtn.TextSize = math.max(8, surpriseBtnTextSize)

		EventUI.surpriseConnection = surpriseBtn.MouseButton1Click:Connect(function()
			if EventUI.currentEventId and #choiceHandlers > 0 then
				local handler = choiceHandlers[math.random(1, #choiceHandlers)]
				handler()
			end
		end)

		EventUI.overlay.Visible = true
		EventUI.shadowFrame.Position = UDim2.new(0.5, 0, 0.5, 40)
		EventUI.shadowFrame.BackgroundTransparency = 1
		EventUI.shell.BackgroundTransparency = 1
		EventUI.card.BackgroundTransparency = 1
		
		tween(EventUI.shadowFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
			Position = UDim2.fromScale(0.5, 0.5),
			BackgroundTransparency = 0.92,
		})
		tween(EventUI.shell, TweenInfo.new(0.25), { BackgroundTransparency = 0 })
		tween(EventUI.card, TweenInfo.new(0.25), { BackgroundTransparency = 0 })
	end) -- End of pcall

	-- Handle errors in showEvent
	if not success then
		warn("[LifeClient] âŒ ERROR in showEvent:", errorMsg)
		awaitingEvent = false
		EventUI.currentEventId = nil
		EventUI.overlay.Visible = false
	end
end

hideEvent = function()
	awaitingEvent  = false
	EventUI.currentEventId = nil

	-- Create the hide tween and track it
	EventUI.currentHideTween = tween(EventUI.shadowFrame, TweenInfo.new(0.2), {
		Position = UDim2.new(0.5, 0, 0.5, 40),
		BackgroundTransparency = 1,
	})
	tween(EventUI.shell, TweenInfo.new(0.2), { BackgroundTransparency = 1 })
	tween(EventUI.card, TweenInfo.new(0.2), { BackgroundTransparency = 1 })

	EventUI.currentHideTween.Completed:Connect(function()
		-- Only hide overlay if we're not currently showing a new event
		-- This prevents race condition where hide completes after new show started
		if not awaitingEvent then
			EventUI.overlay.Visible = false

			-- Reset event UI elements for next event
			EventUI.emoji.Text = "ğŸ™‚"
			EventUI.title.Text = ""
			EventUI.body.Text = ""
			EventUI.avatarEmoji.Text = "ğŸ‘¤"
			EventUI.nameLbl.Text = ""
			EventUI.relationLbl.Text = ""
			EventUI.header.Visible = false
			
		end

		EventUI.currentHideTween = nil
	end)
end

----------------------------------------------------------------
-- INTRO (gender + name) - Consolidated into IntroUI table to reduce local register usage
-- CRITICAL FIX #252: Using table instead of individual locals
----------------------------------------------------------------

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- WELCOME/UPDATE SCREEN - BitLife style popup
-- First time: Shows welcome message
-- Returning: Shows latest updates
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local WelcomeUI = {}
local hasShownPopup = false
local BITLIFE_GREEN = Color3.fromRGB(76, 217, 100)

-- Current version/update info
local CURRENT_VERSION = "1.3.0"
local UPDATES_TEXT = [[
ğŸ‰ What's New in v1.3:

âœ… Fixed marriage system - spouse now properly tracked!
âœ… Fixed proposals - getting engaged works correctly
âœ… Fixed divorce - properly clears relationship
âœ… Improved dating/relationship detection
âœ… Fixed widow/widower events
âœ… Many more stability improvements!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“£ SUBMIT FEEDBACK PLEASE!
Found a bug? Have an idea?
I'll fix it ASAP - usually within a day!
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
]]

local WELCOME_TEXT = [[
ğŸ® Welcome to Ro Life!

Made by a solo developer who LOVES feedback!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“£ FOUND A BUG?
Submit feedback and I'll fix it ASAP!
I read EVERY review and fix issues fast!
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Enjoy living your best life! ğŸŒŸ
]]

-- Dark overlay background
WelcomeUI.overlay = Instance.new("Frame")
WelcomeUI.overlay.Name = "WelcomeOverlay"
WelcomeUI.overlay.Size = UDim2.fromScale(1, 1)
WelcomeUI.overlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
WelcomeUI.overlay.BackgroundTransparency = 0.4
WelcomeUI.overlay.Visible = false
WelcomeUI.overlay.ZIndex = 200
WelcomeUI.overlay.Parent = screenGui

-- White popup card
WelcomeUI.card = Instance.new("Frame")
WelcomeUI.card.Name = "PopupCard"
WelcomeUI.card.Size = UDim2.new(0.88, 0, 0, 0)
WelcomeUI.card.AutomaticSize = Enum.AutomaticSize.Y
WelcomeUI.card.AnchorPoint = Vector2.new(0.5, 0.5)
WelcomeUI.card.Position = UDim2.fromScale(0.5, 0.5)
WelcomeUI.card.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
WelcomeUI.card.ZIndex = 201
WelcomeUI.card.Parent = WelcomeUI.overlay
corner(WelcomeUI.card, 12)

-- Card padding
local cardPadding = Instance.new("UIPadding")
cardPadding.PaddingTop = UDim.new(0, 20)
cardPadding.PaddingBottom = UDim.new(0, 20)
cardPadding.PaddingLeft = UDim.new(0, 18)
cardPadding.PaddingRight = UDim.new(0, 18)
cardPadding.Parent = WelcomeUI.card

-- Card layout
local cardLayout = Instance.new("UIListLayout")
cardLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
cardLayout.Padding = UDim.new(0, 10)
cardLayout.SortOrder = Enum.SortOrder.LayoutOrder
cardLayout.Parent = WelcomeUI.card

-- Title (green header)
WelcomeUI.title = Instance.new("TextLabel")
WelcomeUI.title.Name = "Title"
WelcomeUI.title.Size = UDim2.new(1, 0, 0, 28)
WelcomeUI.title.BackgroundTransparency = 1
WelcomeUI.title.Font = F.Title
WelcomeUI.title.TextSize = 22
WelcomeUI.title.TextColor3 = BITLIFE_GREEN
WelcomeUI.title.Text = "Welcome!"
WelcomeUI.title.ZIndex = 202
WelcomeUI.title.LayoutOrder = 1
WelcomeUI.title.Parent = WelcomeUI.card

-- Body text
WelcomeUI.body = Instance.new("TextLabel")
WelcomeUI.body.Name = "Body"
WelcomeUI.body.Size = UDim2.new(1, 0, 0, 0)
WelcomeUI.body.AutomaticSize = Enum.AutomaticSize.Y
WelcomeUI.body.BackgroundTransparency = 1
WelcomeUI.body.Font = F.Body
WelcomeUI.body.TextSize = 14
WelcomeUI.body.TextColor3 = Color3.fromRGB(60, 60, 60)
WelcomeUI.body.TextWrapped = true
WelcomeUI.body.TextXAlignment = Enum.TextXAlignment.Left
WelcomeUI.body.Text = WELCOME_TEXT
WelcomeUI.body.ZIndex = 202
WelcomeUI.body.LayoutOrder = 2
WelcomeUI.body.Parent = WelcomeUI.card

-- Green continue button
WelcomeUI.btn = Instance.new("TextButton")
WelcomeUI.btn.Name = "ContinueBtn"
WelcomeUI.btn.Size = UDim2.new(1, 0, 0, 44)
WelcomeUI.btn.BackgroundColor3 = BITLIFE_GREEN
WelcomeUI.btn.Font = F.Button
WelcomeUI.btn.TextSize = 16
WelcomeUI.btn.TextColor3 = Color3.fromRGB(255, 255, 255)
WelcomeUI.btn.Text = "Continue"
WelcomeUI.btn.ZIndex = 203
WelcomeUI.btn.LayoutOrder = 3
WelcomeUI.btn.Parent = WelcomeUI.card
corner(WelcomeUI.btn, 8)

WelcomeUI.btn.MouseButton1Click:Connect(function()
	hasShownPopup = true
	WelcomeUI.overlay.Visible = false
end)

-- Show welcome for first-timers, updates for returning players
local function showWelcomeScreen(isFirstTime)
	if hasShownPopup then return end

	if isFirstTime then
		WelcomeUI.title.Text = "Welcome to Ro Life!"
		WelcomeUI.body.Text = WELCOME_TEXT
	else
		WelcomeUI.title.Text = "Updates v" .. CURRENT_VERSION
		WelcomeUI.body.Text = UPDATES_TEXT
	end

	WelcomeUI.overlay.Visible = true
end

local IntroUI = {}

IntroUI.overlay = Instance.new("Frame")
IntroUI.overlay.Size = UDim2.fromScale(1, 1)
IntroUI.overlay.BackgroundColor3 = C.Black
IntroUI.overlay.BackgroundTransparency = 0.5
IntroUI.overlay.Visible = false
IntroUI.overlay.ZIndex = 70
IntroUI.overlay.Parent = screenGui

IntroUI.content = Instance.new("Frame")
IntroUI.content.Size = UDim2.new(0.9, 0, 0, 0)
IntroUI.content.AutomaticSize = Enum.AutomaticSize.Y
IntroUI.content.AnchorPoint = Vector2.new(0.5, 0.5)
IntroUI.content.Position = UDim2.fromScale(0.5, 0.5)
IntroUI.content.BackgroundTransparency = 1
IntroUI.content.ZIndex = 71
IntroUI.content.Parent = IntroUI.overlay

IntroUI.layout = Instance.new("UIListLayout")
IntroUI.layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
IntroUI.layout.Padding = UDim.new(0, 10) -- MOBILE FIX: Reduced from 20 to fit on small screens
IntroUI.layout.Parent = IntroUI.content

IntroUI.genderTitle = Instance.new("TextLabel")
-- MOBILE FIX: Compact title that fits on small screens
IntroUI.genderTitle.Size = UDim2.new(1, 0, 0, 32) -- Reduced from 48
IntroUI.genderTitle.BackgroundTransparency = 1
IntroUI.genderTitle.Font = F.Title or Enum.Font.GothamBold
IntroUI.genderTitle.TextSize = 18 -- Reduced from 22
IntroUI.genderTitle.TextScaled = true -- Scale for mobile
IntroUI.genderTitle.TextColor3 = C.Gray900
IntroUI.genderTitle.Text = "Start by picking a gender"
IntroUI.genderTitle.TextYAlignment = Enum.TextYAlignment.Center
IntroUI.genderTitle.LayoutOrder = 1
IntroUI.genderTitle.ZIndex = 72
IntroUI.genderTitle.Parent = IntroUI.content

-- Constrain title text scaling
IntroUI.genderTitleConstraint = Instance.new("UITextSizeConstraint")
IntroUI.genderTitleConstraint.MaxTextSize = 20
IntroUI.genderTitleConstraint.MinTextSize = 12
IntroUI.genderTitleConstraint.Parent = IntroUI.genderTitle

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- BONUS INCOME DISPLAY - "Join our group & like for 25% extra income!"
-- Shows on intro screen - PASSIVE DISPLAY (not a button)
-- Bonus is AUTOMATICALLY activated when player joins - no click needed!
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
IntroUI.bonusPrompt = Instance.new("Frame") -- CHANGED: Frame instead of TextButton
IntroUI.bonusPrompt.Name = "BonusPrompt"
IntroUI.bonusPrompt.Size = UDim2.new(0.85, 0, 0, 30) -- Smaller since not clickable
IntroUI.bonusPrompt.BackgroundColor3 = Color3.fromRGB(34, 197, 94) -- Green
IntroUI.bonusPrompt.BackgroundTransparency = 0
IntroUI.bonusPrompt.LayoutOrder = 1.5 -- Between title and gender buttons
IntroUI.bonusPrompt.ZIndex = 72
IntroUI.bonusPrompt.Parent = IntroUI.content

IntroUI.bonusPromptCorner = Instance.new("UICorner")
IntroUI.bonusPromptCorner.CornerRadius = UDim.new(0, 8)
IntroUI.bonusPromptCorner.Parent = IntroUI.bonusPrompt

IntroUI.bonusPromptStroke = Instance.new("UIStroke")
IntroUI.bonusPromptStroke.Color = Color3.fromRGB(22, 163, 74)
IntroUI.bonusPromptStroke.Thickness = 2
IntroUI.bonusPromptStroke.Parent = IntroUI.bonusPrompt

IntroUI.bonusPromptText = Instance.new("TextLabel")
IntroUI.bonusPromptText.Name = "BonusText"
IntroUI.bonusPromptText.Size = UDim2.fromScale(1, 1)
IntroUI.bonusPromptText.BackgroundTransparency = 1
IntroUI.bonusPromptText.Font = F.Title or Enum.Font.GothamBold or Enum.Font.SourceSansBold
IntroUI.bonusPromptText.TextSize = 11
IntroUI.bonusPromptText.TextColor3 = Color3.fromRGB(255, 255, 255)
IntroUI.bonusPromptText.Text = "â­ +25% Income! Join Group & Like! ğŸ’°"
IntroUI.bonusPromptText.TextScaled = true
IntroUI.bonusPromptText.ZIndex = 73
IntroUI.bonusPromptText.Parent = IntroUI.bonusPrompt

-- Constrain text scaling
IntroUI.bonusPromptTextConstraint = Instance.new("UITextSizeConstraint")
IntroUI.bonusPromptTextConstraint.MaxTextSize = 12
IntroUI.bonusPromptTextConstraint.MinTextSize = 8
IntroUI.bonusPromptTextConstraint.Parent = IntroUI.bonusPromptText

-- Add padding to the text
IntroUI.bonusPromptPadding = Instance.new("UIPadding")
IntroUI.bonusPromptPadding.PaddingLeft = UDim.new(0, 6)
IntroUI.bonusPromptPadding.PaddingRight = UDim.new(0, 6)
IntroUI.bonusPromptPadding.PaddingTop = UDim.new(0, 3)
IntroUI.bonusPromptPadding.PaddingBottom = UDim.new(0, 3)
IntroUI.bonusPromptPadding.Parent = IntroUI.bonusPromptText

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: Check if player is ACTUALLY in group before giving bonus!
-- Group ID: 706017476
-- Bug: Was giving everyone bonus without checking group membership
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local GROUP_ID = 706017476
local GroupService = game:GetService("GroupService")

task.spawn(function()
	task.wait(0.5) -- Wait for remotes and player to be ready
	local SetEngagementBonus = remotesFolder and remotesFolder:FindFirstChild("SetEngagementBonus")
	if not SetEngagementBonus then return end
	
	-- Check if player is in the group
	local isInGroup = false
	local success, err = pcall(function()
		isInGroup = player:IsInGroup(GROUP_ID)
	end)
	
	if not success then
		warn("[LifeClient] Failed to check group membership:", err)
	end
	
	-- Only give bonus if player is actually in the group
	if isInGroup then
		SetEngagementBonus:FireServer("group")
		print("[LifeClient] â­ Player is in group - +25% income bonus activated!")
	else
		print("[LifeClient] Player not in group - no bonus applied (Join group for +25% income!)")
	end
end)

IntroUI.genderBtns = Instance.new("Frame")
-- MOBILE FIX: Use AutomaticSize so it fits content perfectly
IntroUI.genderBtns.Size = UDim2.new(1, 0, 0, 0)
IntroUI.genderBtns.AutomaticSize = Enum.AutomaticSize.Y -- Auto-size based on content
IntroUI.genderBtns.BackgroundTransparency = 1
IntroUI.genderBtns.LayoutOrder = 2
IntroUI.genderBtns.ZIndex = 71
IntroUI.genderBtns.Parent = IntroUI.content

IntroUI.genderBtnLayout = Instance.new("UIListLayout")
IntroUI.genderBtnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
-- MOBILE FIX: Reduced padding to fit more on small screens
IntroUI.genderBtnLayout.Padding = UDim.new(0, 8)
IntroUI.genderBtnLayout.Parent = IntroUI.genderBtns

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- COUNTRY SELECTION SCREEN - Added after gender, before name
-- User requested: "add countries even if it doesn't do much like let u pick country after u pick gender"
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
IntroUI.countryBtns = Instance.new("ScrollingFrame")
IntroUI.countryBtns.Name = "CountryBtns"
IntroUI.countryBtns.Size = UDim2.new(1, 0, 0, 280)
IntroUI.countryBtns.BackgroundTransparency = 1
IntroUI.countryBtns.Visible = false
IntroUI.countryBtns.LayoutOrder = 3
IntroUI.countryBtns.ZIndex = 71
IntroUI.countryBtns.ScrollBarThickness = 4
IntroUI.countryBtns.CanvasSize = UDim2.new(0, 0, 0, 0)
IntroUI.countryBtns.AutomaticCanvasSize = Enum.AutomaticSize.Y
IntroUI.countryBtns.Parent = IntroUI.content

IntroUI.countryBtnLayout = Instance.new("UIListLayout")
IntroUI.countryBtnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
IntroUI.countryBtnLayout.Padding = UDim.new(0, 8)
IntroUI.countryBtnLayout.Parent = IntroUI.countryBtns

-- Define available countries with flags
IntroUI.countryData = {
	{ id = "usa", name = "United States", flag = "ğŸ‡ºğŸ‡¸", color = Color3.fromRGB(59, 130, 246) },
	{ id = "uk", name = "United Kingdom", flag = "ğŸ‡¬ğŸ‡§", color = Color3.fromRGB(220, 38, 38) },
	{ id = "canada", name = "Canada", flag = "ğŸ‡¨ğŸ‡¦", color = Color3.fromRGB(220, 38, 38) },
	{ id = "australia", name = "Australia", flag = "ğŸ‡¦ğŸ‡º", color = Color3.fromRGB(34, 197, 94) },
	{ id = "germany", name = "Germany", flag = "ğŸ‡©ğŸ‡ª", color = Color3.fromRGB(17, 24, 39) },
	{ id = "france", name = "France", flag = "ğŸ‡«ğŸ‡·", color = Color3.fromRGB(59, 130, 246) },
	{ id = "japan", name = "Japan", flag = "ğŸ‡¯ğŸ‡µ", color = Color3.fromRGB(220, 38, 38) },
	{ id = "brazil", name = "Brazil", flag = "ğŸ‡§ğŸ‡·", color = Color3.fromRGB(34, 197, 94) },
	{ id = "mexico", name = "Mexico", flag = "ğŸ‡²ğŸ‡½", color = Color3.fromRGB(34, 197, 94) },
	{ id = "italy", name = "Italy", flag = "ğŸ‡®ğŸ‡¹", color = Color3.fromRGB(34, 197, 94) },
	{ id = "spain", name = "Spain", flag = "ğŸ‡ªğŸ‡¸", color = Color3.fromRGB(234, 179, 8) },
	{ id = "india", name = "India", flag = "ğŸ‡®ğŸ‡³", color = Color3.fromRGB(249, 115, 22) },
	{ id = "china", name = "China", flag = "ğŸ‡¨ğŸ‡³", color = Color3.fromRGB(220, 38, 38) },
	{ id = "russia", name = "Russia", flag = "ğŸ‡·ğŸ‡º", color = Color3.fromRGB(59, 130, 246) },
	{ id = "south_korea", name = "South Korea", flag = "ğŸ‡°ğŸ‡·", color = Color3.fromRGB(59, 130, 246) },
}

-- Store selected country
local selectedCountry = "usa" -- Default

-- Create country buttons
for i, country in ipairs(IntroUI.countryData) do
	local btn = Instance.new("TextButton")
	btn.Name = country.id
	btn.Size = UDim2.new(0.85, 0, 0, 48)
	btn.BackgroundColor3 = country.color
	btn.Font = F.Title
	btn.TextSize = 16
	btn.TextColor3 = C.White
	btn.Text = country.flag .. " " .. country.name
	btn.AutoButtonColor = false
	btn.LayoutOrder = i
	btn.ZIndex = 72
	btn.Parent = IntroUI.countryBtns
	pill(btn)
	stroke(btn, 2, 0.5, C.White)
	
	btn.MouseEnter:Connect(function()
		tween(btn, TweenInfo.new(0.1), { Size = UDim2.new(0.88, 0, 0, 52) })
	end)
	btn.MouseLeave:Connect(function()
		tween(btn, TweenInfo.new(0.1), { Size = UDim2.new(0.85, 0, 0, 48) })
	end)
	
	btn.MouseButton1Click:Connect(function()
		selectedCountry = country.id
		currentState.Country = country.name
		IntroUI.genderTitle.Text = "Now, pick someone to become"
		
		-- Fade out country buttons
		for _, countryBtn in ipairs(IntroUI.countryBtns:GetChildren()) do
			if countryBtn:IsA("TextButton") then
				tween(countryBtn, TweenInfo.new(0.15), { BackgroundTransparency = 1, TextTransparency = 1 })
			end
		end
		
		task.delay(0.15, function()
			IntroUI.countryBtns.Visible = false
			IntroUI.nameBtns.Visible = true
			
			-- Reset country buttons
			for _, countryBtn in ipairs(IntroUI.countryBtns:GetChildren()) do
				if countryBtn:IsA("TextButton") then
					countryBtn.BackgroundTransparency = 0
					countryBtn.TextTransparency = 0
				end
			end
			
			updateNameButtons()
			
			-- Fade in name buttons
			for _, nameBtn in ipairs(IntroUI.nameBtns:GetChildren()) do
				if nameBtn:IsA("TextButton") then
					nameBtn.BackgroundTransparency = 1
					nameBtn.TextTransparency = 1
					tween(nameBtn, TweenInfo.new(0.2), { BackgroundTransparency = 0, TextTransparency = 0 })
				end
			end
		end)
	end)
end

IntroUI.nameBtns = Instance.new("Frame")
IntroUI.nameBtns.Name = "NameBtns"
IntroUI.nameBtns.Size = UDim2.new(1, 0, 0, 200)
IntroUI.nameBtns.BackgroundTransparency = 1
IntroUI.nameBtns.Visible = false
IntroUI.nameBtns.LayoutOrder = 4
IntroUI.nameBtns.ZIndex = 71
IntroUI.nameBtns.Parent = IntroUI.content

IntroUI.nameBtnLayout = Instance.new("UIListLayout")
IntroUI.nameBtnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
IntroUI.nameBtnLayout.Padding = UDim.new(0, 12)
IntroUI.nameBtnLayout.Parent = IntroUI.nameBtns

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- GOD MODE CHARACTER CREATION CUSTOMIZATION
-- Full character customization at creation for God Mode owners
-- Wrapped in do-end block to reduce local register usage
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- God Mode customization data (needs to be accessible outside scope)
local GodModeCreateData = {
	customName = "",
	gender = "Male",
	ethnicity = "Random",
	familyWealth = "Middle Class",
	country = "United States",
	stats = { Happiness = 50, Health = 100, Smarts = 50, Looks = 50 },
	-- CRITICAL FIX #28: Track if player selected Royal birth
	isRoyalBirth = false,
	royalCountry = nil,
}

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX #251: Move makeSection helper OUTSIDE the do-block
-- This reduces local register usage inside the God Mode UI builder
-- Lua has a limit of 200 local registers per function/chunk
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function makeGodModeSection(parentScroll, title, order)
	local sec = Instance.new("Frame")
	sec.Name = "Section_" .. title
	sec.Size = UDim2.new(1, 0, 0, 0)
	sec.AutomaticSize = Enum.AutomaticSize.Y
	sec.BackgroundColor3 = C.White
	sec.LayoutOrder = order
	sec.ZIndex = 72
	sec.Parent = parentScroll
	corner(sec, 12)
	
	local p = Instance.new("UIPadding")
	p.PaddingLeft = UDim.new(0, 12)
	p.PaddingRight = UDim.new(0, 12)
	p.PaddingTop = UDim.new(0, 10)
	p.PaddingBottom = UDim.new(0, 10)
	p.Parent = sec
	
	local l = Instance.new("UIListLayout")
	l.Padding = UDim.new(0, 8)
	l.Parent = sec
	
	local t = Instance.new("TextLabel")
	t.Size = UDim2.new(1, 0, 0, 24)
	t.BackgroundTransparency = 1
	t.Text = title
	t.TextColor3 = C.Gray800
	t.TextSize = 16
	t.Font = F.Title
	t.TextXAlignment = Enum.TextXAlignment.Left
	t.LayoutOrder = 1
	t.ZIndex = 73
	t.Parent = sec
	
	return sec
end

-- Build God Mode UI in separate scope to reduce local registers
-- CRITICAL FIX: Use IIFEs (Immediately Invoked Function Expressions) to create actual new function scopes
-- do...end blocks don't create new function scopes for register allocation, only lexical scopes
;(function()
	-- Container now just holds the scroll - no fixed bottom area
	IntroUI.godModeContainer = Instance.new("Frame")
	IntroUI.godModeContainer.Name = "GodModeCustomize"
	IntroUI.godModeContainer.Size = UDim2.new(1, 0, 0, 0)
	IntroUI.godModeContainer.AutomaticSize = Enum.AutomaticSize.Y
	IntroUI.godModeContainer.BackgroundTransparency = 1
	IntroUI.godModeContainer.Visible = false
	IntroUI.godModeContainer.LayoutOrder = 4
	IntroUI.godModeContainer.ZIndex = 71
	IntroUI.godModeContainer.Parent = IntroUI.content

	-- Scroll area - full width, auto height
	local scroll = Instance.new("ScrollingFrame")
	scroll.Size = UDim2.new(1, 0, 0, 400) -- Fixed height for scrolling
	scroll.BackgroundTransparency = 1
	scroll.BackgroundColor3 = C.Bg
	scroll.ScrollBarThickness = 6
	scroll.ScrollBarImageColor3 = Color3.fromRGB(253, 230, 138)
	scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
	scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
	scroll.ScrollingEnabled = true
	scroll.ElasticBehavior = Enum.ElasticBehavior.Always
	scroll.Parent = IntroUI.godModeContainer
	IntroUI.godModeScroll = scroll

	local layout = Instance.new("UIListLayout")
	layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout.Padding = UDim.new(0, 8)
	layout.SortOrder = Enum.SortOrder.LayoutOrder
	layout.Parent = scroll

	local padding = Instance.new("UIPadding")
	padding.PaddingLeft = UDim.new(0, 8)
	padding.PaddingRight = UDim.new(0, 8)
	padding.PaddingTop = UDim.new(0, 8)
	padding.PaddingBottom = UDim.new(0, 20)
	padding.Parent = scroll
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- BACK BUTTON AT TOP (LayoutOrder = 0)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local backBtn = Instance.new("TextButton")
	backBtn.Name = "BackBtn"
	backBtn.Size = UDim2.new(0.5, 0, 0, 32)
	backBtn.BackgroundColor3 = C.Gray200
	backBtn.Text = "â† Back to Gender"
	backBtn.TextColor3 = C.Gray600
	backBtn.TextSize = 13
	backBtn.Font = F.Medium
	backBtn.ZIndex = 73
	backBtn.LayoutOrder = 0
	backBtn.Parent = scroll
	corner(backBtn, 8)
	IntroUI.godModeBackBtn = backBtn
	
	backBtn.MouseButton1Click:Connect(function()
		IntroUI.godModeContainer.Visible = false
		IntroUI.content.AutomaticSize = Enum.AutomaticSize.Y
		IntroUI.content.Size = UDim2.new(0.9, 0, 0, 0)
		IntroUI.genderBtns.Visible = true
		IntroUI.nameBtns.Visible = false
		IntroUI.genderTitle.Text = "Start by picking a gender"
	end)
end)() -- End setup IIFE

-- CRITICAL FIX: Each section in its own IIFE to create actual new function scope and reset register count
-- Name section
;(function()
	local scroll = IntroUI.godModeScroll
	local nameSec = makeGodModeSection(scroll, "ğŸ‘¤ Character Name", 1)
	IntroUI.customNameInput = Instance.new("TextBox")
	IntroUI.customNameInput.Size = UDim2.new(1, 0, 0, 40)
	IntroUI.customNameInput.BackgroundColor3 = C.Gray100
	IntroUI.customNameInput.Text = ""
	IntroUI.customNameInput.PlaceholderText = "Enter custom name..."
	IntroUI.customNameInput.TextColor3 = C.Gray900
	IntroUI.customNameInput.PlaceholderColor3 = C.Gray400
	IntroUI.customNameInput.TextSize = 16
	IntroUI.customNameInput.Font = F.Medium
	IntroUI.customNameInput.ClearTextOnFocus = false
	IntroUI.customNameInput.LayoutOrder = 2
	IntroUI.customNameInput.ZIndex = 73
	IntroUI.customNameInput.Parent = nameSec
	corner(IntroUI.customNameInput, 8)
	IntroUI.customNameInput:GetPropertyChangedSignal("Text"):Connect(function()
		GodModeCreateData.customName = IntroUI.customNameInput.Text
	end)
end)()

-- Gender section
;(function()
	local scroll = IntroUI.godModeScroll
	local genderSec = makeGodModeSection(scroll, "âš§ Gender", 2)
	local gFrame = Instance.new("Frame")
	gFrame.Size = UDim2.new(1, 0, 0, 40)
	gFrame.BackgroundTransparency = 1
	gFrame.LayoutOrder = 2
	gFrame.ZIndex = 73
	gFrame.Parent = genderSec
	local gLayout = Instance.new("UIListLayout")
	gLayout.FillDirection = Enum.FillDirection.Horizontal
	gLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	gLayout.Padding = UDim.new(0, 8)
	gLayout.Parent = gFrame
	
	IntroUI.genderBtnsCustom = {}
	for _, gData in ipairs({{id="Male", icon="â™‚", color=C.Male}, {id="Female", icon="â™€", color=C.Female}}) do
		local btn = Instance.new("TextButton")
		btn.Size = UDim2.new(0, 100, 0, 36)
		btn.BackgroundColor3 = gData.id == "Male" and gData.color or C.Gray200
		btn.Text = gData.icon .. " " .. gData.id
		btn.TextColor3 = gData.id == "Male" and C.White or C.Gray600
		btn.TextSize = 14
		btn.Font = F.Medium
		btn.ZIndex = 74
		btn.Parent = gFrame
		corner(btn, 8)
		IntroUI.genderBtnsCustom[gData.id] = btn
		btn.MouseButton1Click:Connect(function()
			GodModeCreateData.gender = gData.id
			selectedGender = gData.id
			for id, b in pairs(IntroUI.genderBtnsCustom) do
				b.BackgroundColor3 = id == gData.id and (id == "Male" and C.Male or C.Female) or C.Gray200
				b.TextColor3 = id == gData.id and C.White or C.Gray600
			end
		end)
	end
end)()

-- Ethnicity section with emojis
;(function()
	local scroll = IntroUI.godModeScroll
	local ethSec = makeGodModeSection(scroll, "ğŸŒ Ethnicity / Heritage", 3)
	local ef = Instance.new("Frame")
	ef.Size = UDim2.new(1, 0, 0, 0)
	ef.AutomaticSize = Enum.AutomaticSize.Y
	ef.BackgroundTransparency = 1
	ef.LayoutOrder = 2
	ef.ZIndex = 73
	ef.Parent = ethSec
	local eg = Instance.new("UIGridLayout")
	eg.CellSize = UDim2.new(0, Device.IS_TINY_PHONE and 85 or 100, 0, 34)
	eg.CellPadding = UDim2.new(0, 4, 0, 4)
	eg.HorizontalAlignment = Enum.HorizontalAlignment.Center
	eg.Parent = ef
	
	local ethOpts = {
		{ id = "Random", label = "ğŸ² Random" }, { id = "Caucasian", label = "ğŸ§‘â€ğŸ¦± Caucasian" },
		{ id = "African", label = "ğŸ‘¨ğŸ¿ African" }, { id = "Asian", label = "ğŸ§‘ğŸ» Asian" },
		{ id = "Hispanic", label = "ğŸ§‘ğŸ½ Hispanic" }, { id = "Middle Eastern", label = "ğŸ§”ğŸ½ Middle Eastern" },
		{ id = "Indian", label = "ğŸ§‘ğŸ¾ South Asian" }, { id = "Pacific Islander", label = "ğŸï¸ Pacific Islander" },
		{ id = "Indigenous", label = "ğŸª¶ Indigenous" }, { id = "Mixed", label = "ğŸŒˆ Mixed" },
	}
	
	-- CRITICAL FIX #274: Helper function to create ethnicity buttons (isolates locals)
	IntroUI.ethnicityBtns = {}
	local function createEthBtn(ethId, ethLabel)
		local btn = Instance.new("TextButton")
		btn.Name = ethId
		btn.Size = UDim2.new(0, 100, 0, 34)
		btn.BackgroundColor3 = ethId == "Random" and C.Purple or C.Gray200
		btn.Text = ethLabel
		btn.TextColor3 = ethId == "Random" and C.White or C.Gray600
		btn.TextSize = Device.IS_TINY_PHONE and 10 or 11
		btn.Font = F.Medium
		btn.TextTruncate = Enum.TextTruncate.AtEnd
		btn.ZIndex = 74
		btn.Parent = ef
		corner(btn, 6)
		IntroUI.ethnicityBtns[ethId] = btn
		btn.MouseButton1Click:Connect(function()
			GodModeCreateData.ethnicity = ethId
			for id, bt in pairs(IntroUI.ethnicityBtns) do
				bt.BackgroundColor3 = id == ethId and C.Purple or C.Gray200
				bt.TextColor3 = id == ethId and C.White or C.Gray600
			end
		end)
	end
	for _, eth in ipairs(ethOpts) do
		createEthBtn(eth.id, eth.label)
	end
end)()

-- Wealth section
-- CRITICAL FIX #22: Link Royalty gamepass to Famous/Royal wealth option
;(function()
	local scroll = IntroUI.godModeScroll
	local ws = makeGodModeSection(scroll, "ğŸ’° Family Wealth", 4)
		IntroUI.wealthBtns = {}
		local wOpts = {
			{ id = "Poor", label = "ğŸšï¸ Poor Family", desc = "$0-500" },
			{ id = "Lower Middle", label = "ğŸ  Lower Middle Class", desc = "$1K-5K" },
			{ id = "Middle Class", label = "ğŸ¡ Middle Class", desc = "$5K-20K" },
			{ id = "Upper Middle", label = "ğŸ¢ Upper Middle Class", desc = "$50K-100K" },
			{ id = "Rich", label = "ğŸ° Wealthy Family", desc = "$500K-2M" },
			{ id = "Royal", label = "ğŸ‘‘ Royal Family", desc = "$10M+ (Gamepass)", requiresGamepass = "ROYALTY" },
		}
		
		-- CRITICAL FIX #415: Helper to check Royalty gamepass ownership (uses cached value)
		local function hasRoyaltyGamepass()
			-- First check cached value (set immediately on purchase)
			if hasRoyalty then
				return true
			end
			-- Then verify with server (updates cache)
			if CheckGamepass then
				local success, owns = pcall(function()
					return CheckGamepass:InvokeServer("ROYALTY")
				end)
				if success and owns == true then
					hasRoyalty = true
					return true
				end
			end
			return false
		end
		
		-- CRITICAL FIX #291: Helper function to create wealth buttons (isolates local registers)
		local function createWealthBtn(parent, wealthData, layoutOrder, checkRoyalty)
			local btn = Instance.new("TextButton")
			btn.Name = wealthData.id
			btn.Size = UDim2.new(1, 0, 0, 44)
			local isRoyal = wealthData.id == "Royal"
			local hasRoyal = isRoyal and checkRoyalty()
			local defaultColor = wealthData.id == "Middle Class" and C.Green or (isRoyal and (hasRoyal and Color3.fromRGB(255, 215, 0) or C.Gray300) or C.Gray100)
			btn.BackgroundColor3 = defaultColor
			btn.Text = ""
			btn.LayoutOrder = layoutOrder
			btn.ZIndex = 74
			btn.Parent = parent
			corner(btn, 8)
			
			local lbl = Instance.new("TextLabel")
			lbl.Size = UDim2.new(1, -16, 0, 24)
			lbl.Position = UDim2.new(0, 8, 0, 4)
			lbl.BackgroundTransparency = 1
			lbl.Text = isRoyal and (hasRoyal and "ğŸ‘‘ Royal Family" or "ğŸ”’ Royal Family") or wealthData.label
			lbl.TextColor3 = wealthData.id == "Middle Class" and C.White or (isRoyal and (hasRoyal and C.Gray900 or C.Gray500) or C.Gray800)
			lbl.TextSize = 14
			lbl.Font = F.Medium
			lbl.TextXAlignment = Enum.TextXAlignment.Left
			lbl.ZIndex = 75
			lbl.Parent = btn
			
			local desc = Instance.new("TextLabel")
			desc.Size = UDim2.new(1, -16, 0, 16)
			desc.Position = UDim2.new(0, 8, 0, 26)
			desc.BackgroundTransparency = 1
			desc.Text = isRoyal and (hasRoyal and "$10M+ â€¢ Prince/Princess" or "Requires Royalty Gamepass") or wealthData.desc
			desc.TextColor3 = wealthData.id == "Middle Class" and Color3.fromRGB(220, 252, 231) or (isRoyal and (hasRoyal and Color3.fromRGB(180, 150, 50) or C.Gray400) or C.Gray500)
			desc.TextSize = 11
			desc.Font = F.Body
			desc.TextXAlignment = Enum.TextXAlignment.Left
			desc.ZIndex = 75
			desc.Parent = btn
			
			IntroUI.wealthBtns[wealthData.id] = { btn = btn, label = lbl, desc = desc, isRoyal = isRoyal }
			
			btn.MouseButton1Click:Connect(function()
				if wealthData.requiresGamepass then
					local hasPass = checkRoyalty()
					if not hasPass then
						-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
						-- CRITICAL FIX #525: Use direct client-side prompt for wealth selector!
						-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
						promptGamepassDirect("ROYALTY")
						return
					end
				end
				GodModeCreateData.familyWealth = wealthData.id
				GodModeCreateData.isRoyalBirth = (wealthData.id == "Royal")
				for id, dt in pairs(IntroUI.wealthBtns) do
					local isSelected = id == wealthData.id
					local isRoyalBtn = dt.isRoyal
					local hasRoyalPass = isRoyalBtn and checkRoyalty()
					if isSelected then
						dt.btn.BackgroundColor3 = isRoyalBtn and Color3.fromRGB(255, 215, 0) or C.Green
						dt.label.TextColor3 = isRoyalBtn and C.Gray900 or C.White
						dt.desc.TextColor3 = isRoyalBtn and Color3.fromRGB(180, 150, 50) or Color3.fromRGB(220, 252, 231)
					else
						dt.btn.BackgroundColor3 = isRoyalBtn and (hasRoyalPass and Color3.fromRGB(255, 235, 180) or C.Gray300) or C.Gray100
						dt.label.TextColor3 = isRoyalBtn and (hasRoyalPass and C.Gray700 or C.Gray500) or C.Gray800
						dt.desc.TextColor3 = isRoyalBtn and (hasRoyalPass and C.Gray500 or C.Gray400) or C.Gray500
					end
				end
			end)
		end
		
		-- Create wealth buttons using helper function
		for i, w in ipairs(wOpts) do
			createWealthBtn(ws, w, i + 1, hasRoyaltyGamepass)
		end
end)()

-- CRITICAL FIX #273: Stats section - wrapped in IIFE to avoid register limit
;(function()
	local scroll = IntroUI.godModeScroll
	local ss = makeGodModeSection(scroll, "ğŸ“Š Starting Stats", 5)
	IntroUI.statSliders = {}
	
	-- Helper function to create each slider (isolates local variables)
	local function createStatSlider(parent, statKey, statIcon, statColor, layoutOrder)
		local row = Instance.new("Frame")
		row.Size = UDim2.new(1, 0, 0, 36)
		row.BackgroundTransparency = 1
		row.LayoutOrder = layoutOrder
		row.ZIndex = 73
		row.Parent = parent
		
		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(0, 80, 1, 0)
		label.BackgroundTransparency = 1
		label.Text = statIcon .. " " .. statKey
		label.TextColor3 = C.Gray700
		label.TextSize = 13
		label.Font = F.Medium
		label.TextXAlignment = Enum.TextXAlignment.Left
		label.ZIndex = 74
		label.Parent = row
		
		local sliderBg = Instance.new("Frame")
		sliderBg.Size = UDim2.new(1, -130, 0, 12)
		sliderBg.Position = UDim2.new(0, 85, 0.5, 0)
		sliderBg.AnchorPoint = Vector2.new(0, 0.5)
		sliderBg.BackgroundColor3 = C.Gray200
		sliderBg.ZIndex = 74
		sliderBg.Parent = row
		corner(sliderBg, 6)
		
		local fill = Instance.new("Frame")
		fill.Size = UDim2.new(GodModeCreateData.stats[statKey] / 100, 0, 1, 0)
		fill.BackgroundColor3 = statColor
		fill.ZIndex = 75
		fill.Parent = sliderBg
		corner(fill, 6)
		
		local valueLabel = Instance.new("TextLabel")
		valueLabel.Size = UDim2.new(0, 40, 1, 0)
		valueLabel.Position = UDim2.new(1, -40, 0, 0)
		valueLabel.BackgroundTransparency = 1
		valueLabel.Text = tostring(GodModeCreateData.stats[statKey]) .. "%"
		valueLabel.TextColor3 = C.Gray700
		valueLabel.TextSize = 13
		valueLabel.Font = F.Medium
		valueLabel.TextXAlignment = Enum.TextXAlignment.Right
		valueLabel.ZIndex = 74
		valueLabel.Parent = row
		
		IntroUI.statSliders[statKey] = { fill = fill, value = valueLabel, bg = sliderBg }
		
		-- Dragging logic
		local dragging = false
		local function updateSlider(posX)
			local relX = math.clamp((posX - sliderBg.AbsolutePosition.X) / sliderBg.AbsoluteSize.X, 0, 1)
			local newVal = math.floor(relX * 100)
			GodModeCreateData.stats[statKey] = newVal
			fill.Size = UDim2.new(relX, 0, 1, 0)
			valueLabel.Text = tostring(newVal) .. "%"
		end
		
		sliderBg.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				dragging = true
				updateSlider(input.Position.X)
			end
		end)
		
		sliderBg.InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				dragging = false
			end
		end)
		
		game:GetService("UserInputService").InputChanged:Connect(function(input)
			if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
				updateSlider(input.Position.X)
			end
		end)
		
		game:GetService("UserInputService").InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				dragging = false
			end
		end)
	end
	
	-- Create sliders using helper function
	createStatSlider(ss, "Happiness", "ğŸ˜Š", C.Yellow, 2)
	createStatSlider(ss, "Health", "â¤ï¸", C.Green, 3)
	createStatSlider(ss, "Smarts", "ğŸ§ ", C.Purple, 4)
	createStatSlider(ss, "Looks", "ğŸ’„", C.Pink, 5)
end)()

-- Country section with flag emojis
;(function()
	local scroll = IntroUI.godModeScroll
	local cs = makeGodModeSection(scroll, "ğŸŒ Country of Birth", 6)
		local cOpts = {
			{id = "United States", flag = "ğŸ‡ºğŸ‡¸"}, {id = "United Kingdom", flag = "ğŸ‡¬ğŸ‡§"},
			{id = "Canada", flag = "ğŸ‡¨ğŸ‡¦"}, {id = "Australia", flag = "ğŸ‡¦ğŸ‡º"},
			{id = "Germany", flag = "ğŸ‡©ğŸ‡ª"}, {id = "France", flag = "ğŸ‡«ğŸ‡·"},
			{id = "Japan", flag = "ğŸ‡¯ğŸ‡µ"}, {id = "Brazil", flag = "ğŸ‡§ğŸ‡·"},
			{id = "Mexico", flag = "ğŸ‡²ğŸ‡½"}, {id = "India", flag = "ğŸ‡®ğŸ‡³"},
			{id = "China", flag = "ğŸ‡¨ğŸ‡³"}, {id = "Italy", flag = "ğŸ‡®ğŸ‡¹"},
			{id = "Spain", flag = "ğŸ‡ªğŸ‡¸"}, {id = "Russia", flag = "ğŸ‡·ğŸ‡º"},
			{id = "South Korea", flag = "ğŸ‡°ğŸ‡·"}, {id = "Nigeria", flag = "ğŸ‡³ğŸ‡¬"},
			{id = "South Africa", flag = "ğŸ‡¿ğŸ‡¦"}, {id = "Argentina", flag = "ğŸ‡¦ğŸ‡·"},
			{id = "Philippines", flag = "ğŸ‡µğŸ‡­"}, {id = "Indonesia", flag = "ğŸ‡®ğŸ‡©"},
		}
		local dd = Instance.new("TextButton")
		dd.Size = UDim2.new(1, 0, 0, 40); dd.BackgroundColor3 = C.Gray100
		dd.Text = "ğŸ‡ºğŸ‡¸ " .. GodModeCreateData.country; dd.TextColor3 = C.Gray800
		dd.TextSize = 14; dd.Font = F.Medium; dd.LayoutOrder = 2; dd.ZIndex = 74; dd.Parent = cs
		corner(dd, 8)
		IntroUI.countryDropdown = dd
		-- CRITICAL UI FIX: Country dropdown with proper scrollable list
		local exp = false
		local cl = Instance.new("ScrollingFrame")
		cl.Size = UDim2.new(1, 0, 0, 0); cl.BackgroundColor3 = C.White; cl.Visible = false
		cl.LayoutOrder = 3; cl.ZIndex = 80; cl.Parent = cs
		cl.ScrollBarThickness = 6
		cl.ScrollBarImageColor3 = C.Gray400
		cl.CanvasSize = UDim2.new(0, 0, 0, #cOpts * 32)
		cl.AutomaticCanvasSize = Enum.AutomaticSize.Y
		corner(cl, 8); stroke(cl, 1, 0.5, C.Gray300)
		-- CRITICAL FIX #290: Helper function to create country buttons (isolates locals)
		local cll = Instance.new("UIListLayout"); cll.Parent = cl
		local function createCountryBtn(countryId, countryFlag)
			local btn = Instance.new("TextButton")
			btn.Size = UDim2.new(1, -6, 0, 32)
			btn.BackgroundColor3 = C.White
			btn.Text = countryFlag .. " " .. countryId
			btn.TextColor3 = C.Gray700
			btn.TextSize = 13
			btn.Font = F.Body
			btn.ZIndex = 81
			btn.Parent = cl
			btn.MouseEnter:Connect(function() btn.BackgroundColor3 = C.Gray100 end)
			btn.MouseLeave:Connect(function() btn.BackgroundColor3 = C.White end)
			btn.MouseButton1Click:Connect(function()
				GodModeCreateData.country = countryId
				dd.Text = countryFlag .. " " .. countryId
				cl.Visible = false
				cl.Size = UDim2.new(1, 0, 0, 0)
				exp = false
			end)
		end
		for _, c in ipairs(cOpts) do
			createCountryBtn(c.id, c.flag)
		end
	dd.MouseButton1Click:Connect(function()
		exp = not exp; cl.Visible = exp
		-- CRITICAL UI FIX: Limit dropdown height to 180px for mobile
		cl.Size = exp and UDim2.new(1, 0, 0, math.min(#cOpts * 32, 180)) or UDim2.new(1, 0, 0, 0)
	end)
end)()

-- Start button section
;(function()
	local scroll = IntroUI.godModeScroll
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- START BUTTON AT BOTTOM OF SCROLL (LayoutOrder = 100)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	IntroUI.godModeStartBtn = Instance.new("TextButton")
	IntroUI.godModeStartBtn.Name = "StartBtn"
	IntroUI.godModeStartBtn.Size = UDim2.new(1, 0, 0, Device.IS_TINY_PHONE and 48 or 56)
	IntroUI.godModeStartBtn.BackgroundColor3 = Color3.fromRGB(253, 230, 138)
	IntroUI.godModeStartBtn.Text = "âš¡ START YOUR CUSTOM LIFE âš¡"
	IntroUI.godModeStartBtn.TextColor3 = C.Gray900
	IntroUI.godModeStartBtn.TextSize = Device.IS_TINY_PHONE and 16 or 18
	IntroUI.godModeStartBtn.Font = F.Title
	IntroUI.godModeStartBtn.ZIndex = 73
	IntroUI.godModeStartBtn.LayoutOrder = 100 -- Always at bottom
	IntroUI.godModeStartBtn.Parent = scroll
	corner(IntroUI.godModeStartBtn, 12)
	stroke(IntroUI.godModeStartBtn, 2, 0, Color3.fromRGB(217, 119, 6))
	
	IntroUI.godModeStartBtn.MouseButton1Click:Connect(function()
		local cName = GodModeCreateData.customName:gsub("^%s+", ""):gsub("%s+$", "")
		if cName == "" then
			-- BUG FIX: Guard against nil NameData (may not be initialized yet)
			local n = {}
			if NameData and NameData.currentMaleNames and NameData.currentFemaleNames then
				n = GodModeCreateData.gender == "Male" and NameData.currentMaleNames or NameData.currentFemaleNames
			end
			cName = (n and #n > 0) and n[1] or (GodModeCreateData.gender == "Male" and "John Doe" or "Jane Doe")
		end
		SetLifeInfo:FireServer(cName, GodModeCreateData.gender)
		-- CRITICAL FIX #28: Pass royal birth information to server
		local p = { 
			name = cName, 
			gender = GodModeCreateData.gender, 
			stats = GodModeCreateData.stats,
			godModeCreate = true, 
			familyWealth = GodModeCreateData.familyWealth,
			ethnicity = GodModeCreateData.ethnicity, 
			country = GodModeCreateData.country,
			-- CRITICAL: Royal birth flags
			isRoyalBirth = GodModeCreateData.isRoyalBirth,
			royalCountry = GodModeCreateData.royalCountry,
		}
		if GodModeEdit then pcall(function() GodModeEdit:InvokeServer(p) end) end
		-- CRITICAL FIX: Set both selectedGender AND currentState.Gender for avatar display
		selectedGender = GodModeCreateData.gender
		currentState.Gender = GodModeCreateData.gender
		currentState.Name = cName
		-- CRITICAL FIX #28: Set royal flag in local state
		if GodModeCreateData.isRoyalBirth then
			currentState.Flags = currentState.Flags or {}
			currentState.Flags.is_royalty = true
			currentState.Flags.royal_birth = true
		end
		introComplete = true
		IntroUI.content.AutomaticSize = Enum.AutomaticSize.Y
		IntroUI.content.Size = UDim2.new(0.9, 0, 0, 0)
		hideIntro()
		task.defer(function() if updateFromState then updateFromState() end end)
	end)
end)() -- End of Start button IIFE

-- Function to show God Mode customization
local function showGodModeIntroCustomize()
	-- Refresh God Mode status
	refreshGodModeStatus()
	
	if not hasGodMode then
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX #511: Use direct client-side prompt instead of server!
		-- This bypasses the server's cooldown and ALWAYS shows the Roblox purchase popup!
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		promptGamepassDirect("GOD_MODE")
		return
	end
	
	-- Hide BOTH gender and name buttons
	IntroUI.genderBtns.Visible = false
	IntroUI.nameBtns.Visible = false
	
	-- Show God Mode container
	IntroUI.godModeContainer.Visible = true
	IntroUI.genderTitle.Text = "âš¡ Customize Your Character"
	IntroUI.genderTitle.Visible = true
	
	-- Adjust scroll height based on viewport
	if IntroUI.godModeScroll then
		local viewportHeight = workspace.CurrentCamera.ViewportSize.Y
		local scrollHeight = math.min(viewportHeight * 0.65, 450)
		IntroUI.godModeScroll.Size = UDim2.new(1, 0, 0, scrollHeight)
	end
	
	-- Reset to defaults but keep selected gender
	GodModeCreateData.gender = selectedGender or "Male"
	GodModeCreateData.customName = ""
	GodModeCreateData.ethnicity = "Random"
	GodModeCreateData.familyWealth = "Middle Class"
	GodModeCreateData.country = "United States"
	GodModeCreateData.stats = { Happiness = 50, Health = 100, Smarts = 50, Looks = 50 }
	
	-- Update UI to match data
	IntroUI.customNameInput.Text = ""
	-- Gender buttons
	for id, btn in pairs(IntroUI.genderBtnsCustom) do
		btn.BackgroundColor3 = id == GodModeCreateData.gender and (id == "Male" and C.Male or C.Female) or C.Gray200
		btn.TextColor3 = id == GodModeCreateData.gender and C.White or C.Gray600
	end
	-- Ethnicity buttons
	for id, btn in pairs(IntroUI.ethnicityBtns) do
		btn.BackgroundColor3 = id == "Random" and C.Purple or C.Gray200
		btn.TextColor3 = id == "Random" and C.White or C.Gray600
	end
	-- Wealth buttons
	for id, data in pairs(IntroUI.wealthBtns) do
		data.btn.BackgroundColor3 = id == "Middle Class" and C.Green or C.Gray100
		data.label.TextColor3 = id == "Middle Class" and C.White or C.Gray800
		data.desc.TextColor3 = id == "Middle Class" and Color3.fromRGB(220, 252, 231) or C.Gray500
	end
	-- Stats sliders
	for key, slider in pairs(IntroUI.statSliders) do
		local defaultVal = key == "Health" and 100 or 50
		slider.fill.Size = UDim2.new(defaultVal / 100, 0, 1, 0)
		slider.value.Text = tostring(defaultVal) .. "%"
	end
	-- Country dropdown
	if IntroUI.countryDropdown then
		IntroUI.countryDropdown.Text = "ğŸ‡ºğŸ‡¸ United States"
	end
end

-- CRITICAL FIX #416: Function to update wealth buttons after royalty gamepass purchase
-- Note: Uses hasRoyalty cache directly since checkRoyaltyGamepass may not be defined yet
IntroUI.updateWealthButtons = function()
	if IntroUI.wealthBtns and IntroUI.wealthBtns["Royal"] then
		local royalData = IntroUI.wealthBtns["Royal"]
		-- Use cached value first, then try to refresh if needed
		local hasRoyal = hasRoyalty
		if not hasRoyal and CheckGamepass then
			local success, owns = pcall(function()
				return CheckGamepass:InvokeServer("ROYALTY")
			end)
			if success and owns == true then
				hasRoyalty = true
				hasRoyal = true
			end
		end
		
		if hasRoyal then
			royalData.btn.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
			royalData.label.Text = "ğŸ‘‘ Royal Family"
			royalData.label.TextColor3 = Color3.fromRGB(30, 30, 30)
			royalData.desc.Text = "$10M+ â€¢ Prince/Princess"
			royalData.desc.TextColor3 = Color3.fromRGB(180, 150, 50)
		else
			royalData.btn.BackgroundColor3 = C.Gray300
			royalData.label.Text = "ğŸ”’ Royal Family"
			royalData.label.TextColor3 = C.Gray500
			royalData.desc.Text = "Requires Royalty Gamepass"
			royalData.desc.TextColor3 = C.Gray400
		end
	end
end

local NameData = {
	maleFirstNames = {
		"James", "Michael", "Daniel", "Alexander", "Liam", "Noah",
		"Jackson", "Elijah", "Logan", "Wyatt", "Kai", "Rowan",
	},
	femaleFirstNames = {
		"Emma", "Sophia", "Olivia", "Isabella", "Mia", "Charlotte",
		"Avery", "Camila", "Scarlett", "Chloe", "Hazel", "Naomi",
	},
	lastNames = {
		"Wilson", "Brown", "Johnson", "Williams", "Taylor", "Clark",
		"Walker", "King", "Adams", "Carter", "Parker", "Reed",
	},

	currentMaleNames = {},
	currentFemaleNames = {},
	nameColors = { C.Green, Color3.fromRGB(234, 179, 8), C.Orange }
}

-- Function to generate random names
local function generateRandomNames()
	NameData.currentMaleNames = {}
	NameData.currentFemaleNames = {}

	-- Shuffle and pick 3 unique male names
	local usedMale = {}
	for i = 1, 3 do
		local firstName, lastName
		repeat
			firstName = NameData.maleFirstNames[math.random(#NameData.maleFirstNames)]
			lastName = NameData.lastNames[math.random(#NameData.lastNames)]
		until not usedMale[firstName .. lastName]
		usedMale[firstName .. lastName] = true
		table.insert(NameData.currentMaleNames, firstName .. " " .. lastName)
	end

	-- Shuffle and pick 3 unique female names
	local usedFemale = {}
	for i = 1, 3 do
		local firstName, lastName
		repeat
			firstName = NameData.femaleFirstNames[math.random(#NameData.femaleFirstNames)]
			lastName = NameData.lastNames[math.random(#NameData.lastNames)]
		until not usedFemale[firstName .. lastName]
		usedFemale[firstName .. lastName] = true
		table.insert(NameData.currentFemaleNames, firstName .. " " .. lastName)
	end
end

for i = 1, 3 do
	local nameBtn = Instance.new("TextButton")
	nameBtn.Name = "NameBtn" .. i
	nameBtn.Size = UDim2.new(0.85, 0, 0, 54)
	nameBtn.BackgroundColor3 = NameData.nameColors[i]
	nameBtn.Font = F.Title
	nameBtn.TextSize = 18
	nameBtn.TextColor3 = C.White
	nameBtn.Text = ""
	nameBtn.AutoButtonColor = false
	nameBtn.LayoutOrder = i
	nameBtn.ZIndex = 72
	nameBtn.Parent = IntroUI.nameBtns
	pill(nameBtn)
	stroke(nameBtn, 2, 0.6, C.White)

	-- subtle size pulse is fine here
	nameBtn.MouseEnter:Connect(function()
		tween(nameBtn, TweenInfo.new(0.1), { Size = UDim2.new(0.88, 0, 0, 58) })
	end)
	nameBtn.MouseLeave:Connect(function()
		tween(nameBtn, TweenInfo.new(0.1), { Size = UDim2.new(0.85, 0, 0, 54) })
	end)

	nameBtn.MouseButton1Click:Connect(function()
		local chosenName = nameBtn.Text:match("^.-%s(.+)$") or nameBtn.Text
		-- CRITICAL FIX: Now include country in SetLifeInfo call
		SetLifeInfo:FireServer(chosenName, selectedGender, selectedCountry)

		-- Store gender and country in currentState immediately
		currentState.Gender = selectedGender
		currentState.Name = chosenName
		-- Country is already set when selecting

		introComplete = true
		hideIntro()

		-- Update avatar immediately (defer to ensure function exists)
		task.defer(function()
			if updateFromState then
				updateFromState()
			end
		end)
	end)
end

-- REMOVED: Duplicate Customize button - now only on gender selection screen

updateNameButtons = function()
	local names = selectedGender == "Male" and NameData.currentMaleNames or NameData.currentFemaleNames
	local emoji = selectedGender == "Male" and "ğŸ‘¨" or "ğŸ‘©"
	for _, child in ipairs(IntroUI.nameBtns:GetChildren()) do
		if child:IsA("TextButton") and child.Name:match("^NameBtn") then
			local idx = tonumber(child.Name:match("%d+"))
			if idx and names[idx] then
				child.Text = emoji .. " " .. names[idx]
			end
		end
	end
end

local genderData = {
	{ gender = "Male",   icon = "â™‚", color = C.Male   },
	{ gender = "Female", icon = "â™€", color = C.Female },
}

for _, g in ipairs(genderData) do
	local btn = Instance.new("TextButton")
	btn.Size = UDim2.new(0.85, 0, 0, 48) -- Slightly bigger for better touch targets
	btn.BackgroundColor3 = g.color
	btn.Font = F.Title or Enum.Font.GothamBold
	btn.TextSize = 18
	btn.TextScaled = true
	btn.TextColor3 = C.White
	btn.Text = g.icon .. " " .. g.gender
	btn.AutoButtonColor = false
	btn.ZIndex = 72
	btn.Parent = IntroUI.genderBtns
	pill(btn)
	stroke(btn, 2, 0.5, C.White)
	
	-- Text size constraint for mobile
	local textConstraint = Instance.new("UITextSizeConstraint")
	textConstraint.MaxTextSize = 20
	textConstraint.MinTextSize = 12
	textConstraint.Parent = btn

	btn.MouseEnter:Connect(function()
		tween(btn, TweenInfo.new(0.1), { Size = UDim2.new(0.88, 0, 0, 52) })
	end)
	btn.MouseLeave:Connect(function()
		tween(btn, TweenInfo.new(0.1), { Size = UDim2.new(0.85, 0, 0, 48) })
	end)

	btn.MouseButton1Click:Connect(function()
		selectedGender = g.gender
		IntroUI.genderTitle.Text = "Where were you born?"

		-- Smooth fade transition from gender to country selection
		for _, genderBtn in ipairs(IntroUI.genderBtns:GetChildren()) do
			if genderBtn:IsA("TextButton") then
				tween(genderBtn, TweenInfo.new(0.15), { BackgroundTransparency = 1, TextTransparency = 1 })
			end
		end

		task.delay(0.15, function()
			IntroUI.genderBtns.Visible = false
			IntroUI.countryBtns.Visible = true

			-- Reset gender buttons for next time
			for _, genderBtn in ipairs(IntroUI.genderBtns:GetChildren()) do
				if genderBtn:IsA("TextButton") then
					genderBtn.BackgroundTransparency = 0
					genderBtn.TextTransparency = 0
				end
			end

			-- Fade in country buttons
			for _, countryBtn in ipairs(IntroUI.countryBtns:GetChildren()) do
				if countryBtn:IsA("TextButton") then
					countryBtn.BackgroundTransparency = 1
					countryBtn.TextTransparency = 1
					tween(countryBtn, TweenInfo.new(0.2), { BackgroundTransparency = 0, TextTransparency = 0 })
				end
			end
		end)
	end)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: Add "Customize Character" button to GENDER selection screen
-- This appears alongside Male/Female buttons at the initial screen
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
do
	local customizeGenderBtn = Instance.new("TextButton")
	customizeGenderBtn.Name = "CustomizeGenderBtn"
	customizeGenderBtn.Size = UDim2.new(0.85, 0, 0, 42) -- Slightly bigger for touch
	customizeGenderBtn.BackgroundColor3 = Color3.fromRGB(253, 230, 138) -- Gold
	customizeGenderBtn.Font = F.Title or Enum.Font.GothamBold
	customizeGenderBtn.TextSize = 14
	customizeGenderBtn.TextScaled = true
	customizeGenderBtn.TextColor3 = C.Gray900
	customizeGenderBtn.Text = "âš¡ Customize Character"
	customizeGenderBtn.AutoButtonColor = false
	customizeGenderBtn.LayoutOrder = 10 -- After gender buttons
	customizeGenderBtn.ZIndex = 72
	customizeGenderBtn.Parent = IntroUI.genderBtns
	pill(customizeGenderBtn)
	stroke(customizeGenderBtn, 2, 0, Color3.fromRGB(217, 119, 6))
	
	-- Text size constraint for mobile
	local customizeTextConstraint = Instance.new("UITextSizeConstraint")
	customizeTextConstraint.MaxTextSize = 16
	customizeTextConstraint.MinTextSize = 10
	customizeTextConstraint.Parent = customizeGenderBtn
	
	IntroUI.customizeGenderBtn = customizeGenderBtn
	
	customizeGenderBtn.MouseEnter:Connect(function()
		tween(customizeGenderBtn, TweenInfo.new(0.1), { Size = UDim2.new(0.88, 0, 0, 46) })
	end)
	customizeGenderBtn.MouseLeave:Connect(function()
		tween(customizeGenderBtn, TweenInfo.new(0.1), { Size = UDim2.new(0.85, 0, 0, 42) })
	end)
	
	customizeGenderBtn.MouseButton1Click:Connect(function()
		-- Check for God Mode ownership
		refreshGodModeStatus()
		if hasGodMode then
			showGodModeIntroCustomize()
		else
			-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			-- CRITICAL FIX #512: Use direct client-side prompt instead of server!
			-- This bypasses the server's cooldown and ALWAYS shows the Roblox purchase popup!
			-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			promptGamepassDirect("GOD_MODE")
		end
	end)
	
	-- Update button appearance based on God Mode status
	local function updateCustomizeGenderBtn()
		refreshGodModeStatus()
		if hasGodMode then
			-- CRITICAL FIX: Show unlocked gold color when gamepass owned
			customizeGenderBtn.Text = "âš¡ Customize Character"
			customizeGenderBtn.BackgroundColor3 = Color3.fromRGB(253, 230, 138)
			customizeGenderBtn.TextColor3 = C.Gray900
		else
			-- CRITICAL FIX: Show ğŸ”’ locked style (was ğŸ”“ which looks unlocked)
			customizeGenderBtn.Text = "ğŸ”’ Customize (God Mode)"
			customizeGenderBtn.BackgroundColor3 = C.Gray300
			customizeGenderBtn.TextColor3 = C.Gray600
		end
	end
	
	-- CRITICAL FIX: Store the update function globally so it can be called on gamepass purchase
	IntroUI.updateCustomizeGenderBtn = updateCustomizeGenderBtn
	
	-- Update on show
	task.defer(updateCustomizeGenderBtn)
end

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX #103: Add "Born Royal" button to GENDER selection screen
-- This allows Royalty gamepass owners to be born as royalty WITHOUT needing God Mode
-- CRITICAL FIX: Split into multiple do-blocks to stay under 200 register limit
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

-- Royal birth shared state (module level to avoid register issues)
IntroUI.RoyalBirthData = {
	gender = "Male",
	name = "",
	ethnicity = "Random",
	overlay = nil,
}

IntroUI.RoyalCountries = {
	{ id = "uk", name = "United Kingdom", emoji = "ğŸ‡¬ğŸ‡§" },
	{ id = "spain", name = "Spain", emoji = "ğŸ‡ªğŸ‡¸" },
	{ id = "sweden", name = "Sweden", emoji = "ğŸ‡¸ğŸ‡ª" },
	{ id = "japan", name = "Japan", emoji = "ğŸ‡¯ğŸ‡µ" },
	{ id = "monaco", name = "Monaco", emoji = "ğŸ‡²ğŸ‡¨" },
	{ id = "saudi", name = "Saudi Arabia", emoji = "ğŸ‡¸ğŸ‡¦" },
	{ id = "thailand", name = "Thailand", emoji = "ğŸ‡¹ğŸ‡­" },
	{ id = "morocco", name = "Morocco", emoji = "ğŸ‡²ğŸ‡¦" },
	{ id = "jordan", name = "Jordan", emoji = "ğŸ‡¯ğŸ‡´" },
	{ id = "belgium", name = "Belgium", emoji = "ğŸ‡§ğŸ‡ª" },
	{ id = "netherlands", name = "Netherlands", emoji = "ğŸ‡³ğŸ‡±" },
	{ id = "norway", name = "Norway", emoji = "ğŸ‡³ğŸ‡´" },
	{ id = "denmark", name = "Denmark", emoji = "ğŸ‡©ğŸ‡°" },
}

IntroUI.EthnicityOptions = {
	{ id = "Random", label = "ğŸ² Random" },
	{ id = "Caucasian", label = "ğŸ§‘â€ğŸ¦± Caucasian" },
	{ id = "African", label = "ğŸ‘¨ğŸ¿ African" },
	{ id = "Asian", label = "ğŸ§‘ğŸ» Asian" },
	{ id = "Hispanic", label = "ğŸ§‘ğŸ½ Hispanic" },
	{ id = "Middle Eastern", label = "ğŸ§”ğŸ½ Middle Eastern" },
	{ id = "Mixed", label = "ğŸŒˆ Mixed" },
}

-- Helper to check Royalty gamepass ownership (module level)
-- CRITICAL FIX #413: Use cached hasRoyalty for immediate response after purchase
local function checkRoyaltyGamepass()
	-- First check cached value (set immediately on purchase)
	if hasRoyalty then
		return true
	end
	-- Then verify with server (updates cache)
	if CheckGamepass then
		local success, owns = pcall(function()
			return CheckGamepass:InvokeServer("ROYALTY")
		end)
		if success and owns == true then
			hasRoyalty = true
			return true
		end
	end
	return false
end

-- Forward declare Royal UI functions at module level
IntroUI.showRoyalCountrySelection = nil
IntroUI.showRoyalGenderSelection = nil

-- Royal button setup block
do
	local royaltyBtn = Instance.new("TextButton")
	royaltyBtn.Name = "RoyaltyGenderBtn"
	royaltyBtn.Size = UDim2.new(0.85, 0, 0, 42) -- Slightly bigger for touch
	royaltyBtn.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
	royaltyBtn.Font = F.Title or Enum.Font.GothamBold
	royaltyBtn.TextSize = 14
	royaltyBtn.TextScaled = true
	royaltyBtn.TextColor3 = C.Gray900
	royaltyBtn.Text = "ğŸ‘‘ Born Royal"
	royaltyBtn.AutoButtonColor = false
	royaltyBtn.LayoutOrder = 9
	royaltyBtn.ZIndex = 72
	royaltyBtn.Parent = IntroUI.genderBtns
	pill(royaltyBtn)
	stroke(royaltyBtn, 2, 0, Color3.fromRGB(180, 140, 0))
	
	-- Text size constraint for mobile
	local royaltyTextConstraint = Instance.new("UITextSizeConstraint")
	royaltyTextConstraint.MaxTextSize = 16
	royaltyTextConstraint.MinTextSize = 10
	royaltyTextConstraint.Parent = royaltyBtn
	
	IntroUI.royaltyGenderBtn = royaltyBtn
	
	royaltyBtn.MouseEnter:Connect(function()
		tween(royaltyBtn, TweenInfo.new(0.1), { Size = UDim2.new(0.88, 0, 0, 46) })
	end)
	royaltyBtn.MouseLeave:Connect(function()
		tween(royaltyBtn, TweenInfo.new(0.1), { Size = UDim2.new(0.85, 0, 0, 42) })
	end)
	
	royaltyBtn.MouseButton1Click:Connect(function()
		if checkRoyaltyGamepass() then
			if IntroUI.showRoyalCountrySelection then
				IntroUI.showRoyalCountrySelection()
			end
		else
			-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			-- CRITICAL FIX #510: Use direct client-side prompt instead of server!
			-- This bypasses the server's cooldown and ALWAYS shows the Roblox purchase popup!
			-- User complaint: "clicking royalty button only pops up once then never again"
			-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
			promptGamepassDirect("ROYALTY")
		end
	end)
	
	IntroUI.updateRoyaltyGenderBtn = function()
		local hasRoyal = checkRoyaltyGamepass()
		if hasRoyal then
			-- CRITICAL FIX: Show unlocked gold color when gamepass owned
			royaltyBtn.Text = "ğŸ‘‘ Born Royal"
			royaltyBtn.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
			royaltyBtn.TextColor3 = C.Gray900
			stroke(royaltyBtn, 2, 0, Color3.fromRGB(180, 140, 0))
		else
			-- CRITICAL FIX: Show ğŸ”’ locked style like God Mode button
			royaltyBtn.Text = "ğŸ”’ Born Royal"
			royaltyBtn.BackgroundColor3 = C.Gray300
			royaltyBtn.TextColor3 = C.Gray600
			stroke(royaltyBtn, 1, 0.5, C.Gray400)
		end
	end
	
	task.defer(IntroUI.updateRoyaltyGenderBtn)
end

-- Royal Country Selection function block
do
	IntroUI.showRoyalCountrySelection = function()
		if IntroUI.RoyalBirthData.overlay then return end
		
		-- Reset royal birth data
		IntroUI.RoyalBirthData.gender = "Male"
		IntroUI.RoyalBirthData.name = ""
		IntroUI.RoyalBirthData.ethnicity = "Random"
		
		-- Create overlay
		local overlay = Instance.new("Frame")
		overlay.Name = "RoyalCountryOverlay"
		overlay.Size = UDim2.fromScale(1, 1)
		overlay.BackgroundColor3 = C.Black
		overlay.BackgroundTransparency = 0.4
		overlay.ZIndex = 80
		overlay.Parent = screenGui
		IntroUI.RoyalBirthData.overlay = overlay
		
		-- Card with slide animation
		local card = Instance.new("Frame")
		card.Name = "Card"
		card.Size = UDim2.new(0.9, 0, 0, 0)
		card.AutomaticSize = Enum.AutomaticSize.Y
		card.AnchorPoint = Vector2.new(0.5, 0.5)
		card.Position = UDim2.fromScale(-0.5, 0.5) -- Start off-screen left
		card.BackgroundColor3 = C.White
		card.ZIndex = 81
		card.Parent = overlay
		
		-- Slide in animation
		tween(card, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
			Position = UDim2.fromScale(0.5, 0.5)
		})
		corner(card, 16)
		pad(card, 16, 16, 16, 16)
		
		local layout = Instance.new("UIListLayout")
		layout.Padding = UDim.new(0, 8)
		layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		layout.Parent = card
		
		-- Title
		local title = Instance.new("TextLabel")
		title.Size = UDim2.new(1, 0, 0, 40)
		title.BackgroundTransparency = 1
		title.Text = "ğŸ‘‘ Choose Your Kingdom"
		title.TextColor3 = C.Gray900
		title.TextSize = 20
		title.Font = F.Title
		title.ZIndex = 82
		title.Parent = card
		
		-- Subtitle
		local subtitle = Instance.new("TextLabel")
		subtitle.Size = UDim2.new(1, 0, 0, 28)
		subtitle.BackgroundTransparency = 1
		subtitle.Text = "Select a royal family to be born into"
		subtitle.TextColor3 = C.Gray500
		subtitle.TextSize = 14
		subtitle.Font = F.Body
		subtitle.ZIndex = 82
		subtitle.Parent = card
		
		-- Scroll frame for countries
		local scroll = Instance.new("ScrollingFrame")
		scroll.Size = UDim2.new(1, 0, 0, 280)
		scroll.BackgroundTransparency = 1
		scroll.ScrollBarThickness = 4
		scroll.ScrollBarImageColor3 = Color3.fromRGB(255, 215, 0)
		scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
		scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
		scroll.ZIndex = 82
		scroll.Parent = card
		
		local scrollLayout = Instance.new("UIListLayout")
		scrollLayout.Padding = UDim.new(0, 6)
		scrollLayout.Parent = scroll
		
		for _, country in ipairs(IntroUI.RoyalCountries) do
			local countryBtn = Instance.new("TextButton")
			countryBtn.Size = UDim2.new(1, 0, 0, 44)
			countryBtn.BackgroundColor3 = Color3.fromRGB(255, 248, 220)
			countryBtn.Text = country.emoji .. " " .. country.name
			countryBtn.TextColor3 = C.Gray800
			countryBtn.TextSize = 15
			countryBtn.Font = F.Medium
			countryBtn.ZIndex = 83
			countryBtn.Parent = scroll
			corner(countryBtn, 8)
			stroke(countryBtn, 1, 0.8, Color3.fromRGB(255, 215, 0))
			
			countryBtn.MouseEnter:Connect(function()
				tween(countryBtn, TweenInfo.new(0.1), { BackgroundColor3 = Color3.fromRGB(255, 215, 0) })
			end)
			countryBtn.MouseLeave:Connect(function()
				tween(countryBtn, TweenInfo.new(0.1), { BackgroundColor3 = Color3.fromRGB(255, 248, 220) })
			end)
			
			countryBtn.MouseButton1Click:Connect(function()
				-- Slide out animation then show customization
				tween(card, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
					Position = UDim2.fromScale(-0.5, 0.5)
				})
				task.delay(0.25, function()
					if IntroUI.RoyalBirthData.overlay then
						IntroUI.RoyalBirthData.overlay:Destroy()
						IntroUI.RoyalBirthData.overlay = nil
					end
					if IntroUI.showRoyalGenderSelection then
						IntroUI.showRoyalGenderSelection(country)
					end
				end)
			end)
		end
		
		-- Random button
		local randomBtn = Instance.new("TextButton")
		randomBtn.Size = UDim2.new(1, 0, 0, 44)
		randomBtn.BackgroundColor3 = Color3.fromRGB(168, 85, 247) -- Purple
		randomBtn.Text = "ğŸ² Random Kingdom"
		randomBtn.TextColor3 = C.White
		randomBtn.TextSize = 15
		randomBtn.Font = F.Title
		randomBtn.ZIndex = 82
		randomBtn.Parent = card
		corner(randomBtn, 8)
		
		randomBtn.MouseButton1Click:Connect(function()
			local randomCountry = IntroUI.RoyalCountries[math.random(1, #IntroUI.RoyalCountries)]
			
			-- Slide out animation then show customization
			tween(card, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
				Position = UDim2.fromScale(-0.5, 0.5)
			})
			task.delay(0.25, function()
				if IntroUI.RoyalBirthData.overlay then
					IntroUI.RoyalBirthData.overlay:Destroy()
					IntroUI.RoyalBirthData.overlay = nil
				end
				if IntroUI.showRoyalGenderSelection then
					IntroUI.showRoyalGenderSelection(randomCountry)
				end
			end)
		end)
		
		-- Cancel button
		local cancelBtn = Instance.new("TextButton")
		cancelBtn.Size = UDim2.new(0.5, 0, 0, 36)
		cancelBtn.BackgroundColor3 = C.Gray200
		cancelBtn.Text = "â† Back"
		cancelBtn.TextColor3 = C.Gray600
		cancelBtn.TextSize = 14
		cancelBtn.Font = F.Medium
		cancelBtn.ZIndex = 82
		cancelBtn.Parent = card
		corner(cancelBtn, 8)
		
		cancelBtn.MouseButton1Click:Connect(function()
			-- Slide out animation then close
			tween(card, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
				Position = UDim2.fromScale(-0.5, 0.5)
			})
			task.delay(0.2, function()
				if IntroUI.RoyalBirthData.overlay then
					IntroUI.RoyalBirthData.overlay:Destroy()
					IntroUI.RoyalBirthData.overlay = nil
				end
			end)
		end)
	end
end

-- Royal Gender/Customization Selection function block
do
	IntroUI.showRoyalGenderSelection = function(country)
		-- Create overlay for customization
		local customOverlay = Instance.new("Frame")
		customOverlay.Name = "RoyalCustomizeOverlay"
		customOverlay.Size = UDim2.fromScale(1, 1)
		customOverlay.BackgroundColor3 = C.Black
		customOverlay.BackgroundTransparency = 0.4
		customOverlay.ZIndex = 80
		customOverlay.Parent = screenGui
		
		-- Main scrollable card
		local card = Instance.new("Frame")
		card.Name = "Card"
		card.Size = UDim2.new(0.92, 0, 0.8, 0)
		card.AnchorPoint = Vector2.new(0.5, 0.5)
		card.Position = UDim2.fromScale(1.5, 0.5) -- Start off-screen for slide
		card.BackgroundColor3 = C.White
		card.ZIndex = 81
		card.Parent = customOverlay
		corner(card, 16)
		
		-- Slide in animation
		tween(card, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
			Position = UDim2.fromScale(0.5, 0.5)
		})
		
		-- Scroll frame
		local scroll = Instance.new("ScrollingFrame")
		scroll.Size = UDim2.new(1, 0, 1, 0)
		scroll.BackgroundTransparency = 1
		scroll.ScrollBarThickness = 4
		scroll.ScrollBarImageColor3 = Color3.fromRGB(255, 215, 0)
		scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
		scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
		scroll.ZIndex = 82
		scroll.Parent = card
		
		local scrollPad = Instance.new("UIPadding")
		scrollPad.PaddingLeft = UDim.new(0, 16)
		scrollPad.PaddingRight = UDim.new(0, 16)
		scrollPad.PaddingTop = UDim.new(0, 16)
		scrollPad.PaddingBottom = UDim.new(0, 16)
		scrollPad.Parent = scroll
		
		local layout = Instance.new("UIListLayout")
		layout.Padding = UDim.new(0, 12)
		layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		layout.Parent = scroll
		
		-- Header
		local header = Instance.new("TextLabel")
		header.Size = UDim2.new(1, 0, 0, 44)
		header.BackgroundTransparency = 1
		header.Text = country.emoji .. " Royal Birth: " .. country.name
		header.TextColor3 = Color3.fromRGB(180, 140, 0)
		header.TextSize = 18
		header.Font = F.Title
		header.ZIndex = 83
		header.Parent = scroll
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- GENDER SELECTION
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		local genderSec = Instance.new("Frame")
		genderSec.Size = UDim2.new(1, 0, 0, 0)
		genderSec.AutomaticSize = Enum.AutomaticSize.Y
		genderSec.BackgroundColor3 = Color3.fromRGB(255, 248, 220)
		genderSec.ZIndex = 82
		genderSec.Parent = scroll
		corner(genderSec, 12)
		pad(genderSec, 12, 12, 12, 12)
		
		local genderLayout = Instance.new("UIListLayout")
		genderLayout.Padding = UDim.new(0, 8)
		genderLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		genderLayout.Parent = genderSec
		
		local genderTitle = Instance.new("TextLabel")
		genderTitle.Size = UDim2.new(1, 0, 0, 24)
		genderTitle.BackgroundTransparency = 1
		genderTitle.Text = "ğŸ‘‘ Choose Your Royal Title"
		genderTitle.TextColor3 = C.Gray800
		genderTitle.TextSize = 15
		genderTitle.Font = F.Title
		genderTitle.ZIndex = 83
		genderTitle.Parent = genderSec
		
		local genderBtnFrame = Instance.new("Frame")
		genderBtnFrame.Size = UDim2.new(1, 0, 0, 48)
		genderBtnFrame.BackgroundTransparency = 1
		genderBtnFrame.ZIndex = 83
		genderBtnFrame.Parent = genderSec
		
		local genderBtnLayout = Instance.new("UIListLayout")
		genderBtnLayout.FillDirection = Enum.FillDirection.Horizontal
		genderBtnLayout.Padding = UDim.new(0, 10)
		genderBtnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		genderBtnLayout.Parent = genderBtnFrame
		
		IntroUI.RoyalBirthData.gender = "Male"
		
		local princeBtn = Instance.new("TextButton")
		princeBtn.Size = UDim2.new(0, 120, 0, 48)
		princeBtn.BackgroundColor3 = C.Male
		princeBtn.Text = "ğŸ‘‘ Prince"
		princeBtn.TextColor3 = C.White
		princeBtn.TextSize = 15
		princeBtn.Font = F.Title
		princeBtn.ZIndex = 84
		princeBtn.Parent = genderBtnFrame
		corner(princeBtn, 10)
		stroke(princeBtn, 2, 0, Color3.fromRGB(30, 100, 180))
		
		local princessBtn = Instance.new("TextButton")
		princessBtn.Size = UDim2.new(0, 120, 0, 48)
		princessBtn.BackgroundColor3 = C.Gray200
		princessBtn.Text = "ğŸ‘¸ Princess"
		princessBtn.TextColor3 = C.Gray600
		princessBtn.TextSize = 15
		princessBtn.Font = F.Title
		princessBtn.ZIndex = 84
		princessBtn.Parent = genderBtnFrame
		corner(princessBtn, 10)
		
		princeBtn.MouseButton1Click:Connect(function()
			IntroUI.RoyalBirthData.gender = "Male"
			princeBtn.BackgroundColor3 = C.Male
			princeBtn.TextColor3 = C.White
			stroke(princeBtn, 2, 0, Color3.fromRGB(30, 100, 180))
			princessBtn.BackgroundColor3 = C.Gray200
			princessBtn.TextColor3 = C.Gray600
			local s = princessBtn:FindFirstChildOfClass("UIStroke")
			if s then s:Destroy() end
		end)
		
		princessBtn.MouseButton1Click:Connect(function()
			IntroUI.RoyalBirthData.gender = "Female"
			princessBtn.BackgroundColor3 = C.Female
			princessBtn.TextColor3 = C.White
			stroke(princessBtn, 2, 0, Color3.fromRGB(180, 50, 120))
			princeBtn.BackgroundColor3 = C.Gray200
			princeBtn.TextColor3 = C.Gray600
			local s = princeBtn:FindFirstChildOfClass("UIStroke")
			if s then s:Destroy() end
		end)
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- NAME INPUT
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		local nameSec = Instance.new("Frame")
		nameSec.Size = UDim2.new(1, 0, 0, 0)
		nameSec.AutomaticSize = Enum.AutomaticSize.Y
		nameSec.BackgroundColor3 = C.White
		nameSec.ZIndex = 82
		nameSec.Parent = scroll
		corner(nameSec, 12)
		stroke(nameSec, 1, 0.5, C.Gray200)
		pad(nameSec, 12, 12, 12, 12)
		
		local nameLayout = Instance.new("UIListLayout")
		nameLayout.Padding = UDim.new(0, 6)
		nameLayout.Parent = nameSec
		
		local nameTitle = Instance.new("TextLabel")
		nameTitle.Size = UDim2.new(1, 0, 0, 22)
		nameTitle.BackgroundTransparency = 1
		nameTitle.Text = "ğŸ‘¤ Royal Name (Optional)"
		nameTitle.TextColor3 = C.Gray800
		nameTitle.TextSize = 14
		nameTitle.Font = F.Title
		nameTitle.TextXAlignment = Enum.TextXAlignment.Left
		nameTitle.ZIndex = 83
		nameTitle.Parent = nameSec
		
		local nameInput = Instance.new("TextBox")
		nameInput.Size = UDim2.new(1, 0, 0, 40)
		nameInput.BackgroundColor3 = C.Gray100
		nameInput.Text = ""
		nameInput.PlaceholderText = "Leave blank for random royal name..."
		nameInput.TextColor3 = C.Gray900
		nameInput.PlaceholderColor3 = C.Gray400
		nameInput.TextSize = 14
		nameInput.Font = F.Medium
		nameInput.ClearTextOnFocus = false
		nameInput.ZIndex = 83
		nameInput.Parent = nameSec
		corner(nameInput, 8)
		
		nameInput:GetPropertyChangedSignal("Text"):Connect(function()
			IntroUI.RoyalBirthData.name = nameInput.Text
		end)
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- ETHNICITY SELECTION
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		local ethSec = Instance.new("Frame")
		ethSec.Size = UDim2.new(1, 0, 0, 0)
		ethSec.AutomaticSize = Enum.AutomaticSize.Y
		ethSec.BackgroundColor3 = C.White
		ethSec.ZIndex = 82
		ethSec.Parent = scroll
		corner(ethSec, 12)
		stroke(ethSec, 1, 0.5, C.Gray200)
		pad(ethSec, 12, 12, 12, 12)
		
		local ethLayout = Instance.new("UIListLayout")
		ethLayout.Padding = UDim.new(0, 6)
		ethLayout.Parent = ethSec
		
		local ethTitle = Instance.new("TextLabel")
		ethTitle.Size = UDim2.new(1, 0, 0, 22)
		ethTitle.BackgroundTransparency = 1
		ethTitle.Text = "ğŸŒ Ethnicity"
		ethTitle.TextColor3 = C.Gray800
		ethTitle.TextSize = 14
		ethTitle.Font = F.Title
		ethTitle.TextXAlignment = Enum.TextXAlignment.Left
		ethTitle.ZIndex = 83
		ethTitle.Parent = ethSec
		
		local ethGrid = Instance.new("Frame")
		ethGrid.Size = UDim2.new(1, 0, 0, 0)
		ethGrid.AutomaticSize = Enum.AutomaticSize.Y
		ethGrid.BackgroundTransparency = 1
		ethGrid.ZIndex = 83
		ethGrid.Parent = ethSec
		
		local ethGridLayout = Instance.new("UIGridLayout")
		ethGridLayout.CellSize = UDim2.new(0, 90, 0, 32)
		ethGridLayout.CellPadding = UDim2.new(0, 6, 0, 6)
		ethGridLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		ethGridLayout.Parent = ethGrid
		
		local ethBtns = {}
		for _, eth in ipairs(IntroUI.EthnicityOptions) do
			local btn = Instance.new("TextButton")
			btn.Name = eth.id
			btn.Size = UDim2.new(0, 90, 0, 32)
			btn.BackgroundColor3 = eth.id == "Random" and C.Purple or C.Gray200
			btn.Text = eth.label
			btn.TextColor3 = eth.id == "Random" and C.White or C.Gray600
			btn.TextSize = 10
			btn.Font = F.Medium
			btn.TextTruncate = Enum.TextTruncate.AtEnd
			btn.ZIndex = 84
			btn.Parent = ethGrid
			corner(btn, 6)
			ethBtns[eth.id] = btn
			
			btn.MouseButton1Click:Connect(function()
				IntroUI.RoyalBirthData.ethnicity = eth.id
				for id, b in pairs(ethBtns) do
					b.BackgroundColor3 = id == eth.id and C.Purple or C.Gray200
					b.TextColor3 = id == eth.id and C.White or C.Gray600
				end
			end)
		end
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- ACTION BUTTONS
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		local btnFrame = Instance.new("Frame")
		btnFrame.Size = UDim2.new(1, 0, 0, 52)
		btnFrame.BackgroundTransparency = 1
		btnFrame.ZIndex = 82
		btnFrame.Parent = scroll
		
		local btnLayout = Instance.new("UIListLayout")
		btnLayout.FillDirection = Enum.FillDirection.Horizontal
		btnLayout.Padding = UDim.new(0, 10)
		btnLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		btnLayout.Parent = btnFrame
		
		local backBtn = Instance.new("TextButton")
		backBtn.Size = UDim2.new(0, 90, 0, 46)
		backBtn.BackgroundColor3 = C.Gray200
		backBtn.Text = "â† Back"
		backBtn.TextColor3 = C.Gray600
		backBtn.TextSize = 14
		backBtn.Font = F.Medium
		backBtn.ZIndex = 83
		backBtn.Parent = btnFrame
		corner(backBtn, 10)
		
		local startBtn = Instance.new("TextButton")
		startBtn.Size = UDim2.new(0, 160, 0, 46)
		startBtn.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
		startBtn.Text = "ğŸ‘‘ Begin Royal Life"
		startBtn.TextColor3 = C.Gray900
		startBtn.TextSize = 15
		startBtn.Font = F.Title
		startBtn.ZIndex = 83
		startBtn.Parent = btnFrame
		corner(startBtn, 10)
		stroke(startBtn, 2, 0, Color3.fromRGB(180, 140, 0))
		
		-- Back button - slide back to kingdom selection
		backBtn.MouseButton1Click:Connect(function()
			tween(card, TweenInfo.new(0.25, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
				Position = UDim2.fromScale(1.5, 0.5)
			})
			task.delay(0.25, function()
				customOverlay:Destroy()
				IntroUI.showRoyalCountrySelection()
			end)
		end)
		
		-- Start Royal Life
		startBtn.MouseButton1Click:Connect(function()
			-- Get final name
			local finalName = IntroUI.RoyalBirthData.name:gsub("^%s+", ""):gsub("%s+$", "")
			if finalName == "" then
				local maleNames = {"William", "Charles", "Henry", "Edward", "George", "Philip", "James", "Alexander"}
				local femaleNames = {"Elizabeth", "Victoria", "Charlotte", "Catherine", "Diana", "Margaret", "Anne", "Alexandra"}
				local names = IntroUI.RoyalBirthData.gender == "Male" and maleNames or femaleNames
				finalName = names[math.random(1, #names)]
			end
			
			-- Animate out
			tween(card, TweenInfo.new(0.2, Enum.EasingStyle.Back, Enum.EasingDirection.In), {
				Position = UDim2.fromScale(0.5, 1.5)
			})
			
			task.delay(0.2, function()
				customOverlay:Destroy()
				
				-- CRITICAL FIX: Set selectedGender
				selectedGender = IntroUI.RoyalBirthData.gender
				
				-- CRITICAL FIX: Set currentState properly
				currentState.Gender = IntroUI.RoyalBirthData.gender
				currentState.Name = finalName
				currentState.Flags = currentState.Flags or {}
				currentState.Flags.is_royalty = true
				currentState.Flags.royal_birth = true
				currentState.Flags.royal_country = country.id
				currentState.Flags.royal_country_name = country.name
				
				-- CRITICAL FIX: Send proper format to server
				if SetLifeInfo then
					pcall(function()
						SetLifeInfo:FireServer(finalName, IntroUI.RoyalBirthData.gender)
					end)
				end
				
				-- Send detailed royal info if GodModeEdit available
				if GodModeEdit then
					pcall(function()
						GodModeEdit:InvokeServer({
							name = finalName,
							gender = IntroUI.RoyalBirthData.gender,
							isRoyalBirth = true,
							royalCountry = country.id,
							royalCountryName = country.name,
							ethnicity = IntroUI.RoyalBirthData.ethnicity,
							familyWealth = "Royal",
						})
					end)
				end
				
				-- CRITICAL FIX: Complete intro properly
				introComplete = true
				hideIntro()
				
				task.defer(function()
					if updateFromState then updateFromState() end
				end)
			end)
		end)
	end
end

showIntro = function()
	if introComplete then return end

	-- Generate fresh random names each time intro is shown
	generateRandomNames()

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Reset ALL intro UI states for clean new life experience
	-- This ensures God Mode customization UI is hidden when starting fresh
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	IntroUI.overlay.Visible = true
	IntroUI.overlay.BackgroundTransparency = 0.5
	IntroUI.content.Position = UDim2.fromScale(0.5, 0.5)
	
	-- CRITICAL FIX: Reset God Mode container and all customization state
	if IntroUI.godModeContainer then
		IntroUI.godModeContainer.Visible = false
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Clean up any Royal Birth overlay that might be lingering
	-- User bug report: "countries IS VISIBLE LIKE ITS BUGGED SHOWING THE COUNTRIES 
	-- AND MALE FEMALE LIKE ITS STACKED ON TOP"
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	if IntroUI.RoyalBirthData and IntroUI.RoyalBirthData.overlay then
		IntroUI.RoyalBirthData.overlay:Destroy()
		IntroUI.RoyalBirthData.overlay = nil
	end
	
	-- CRITICAL FIX: Restore content to auto-size mode
	IntroUI.content.AutomaticSize = Enum.AutomaticSize.Y
	IntroUI.content.Size = UDim2.new(0.9, 0, 0, 0)
	
	-- Reset God Mode data for new life
	if GodModeCreateData then
		GodModeCreateData.customName = ""
		GodModeCreateData.gender = "Male"
		GodModeCreateData.ethnicity = "Random"
		GodModeCreateData.familyWealth = "Middle Class"
		GodModeCreateData.country = "United States"
		-- CRITICAL FIX: Reset stats to defaults
		GodModeCreateData.stats = { Happiness = 50, Health = 100, Smarts = 50, Looks = 50 }
		-- CRITICAL FIX #28: Reset royal birth flags
		GodModeCreateData.isRoyalBirth = false
		GodModeCreateData.royalCountry = nil
	end
	
	-- CRITICAL FIX: Reset God Mode UI elements to default states
	if IntroUI.customNameInput then
		IntroUI.customNameInput.Text = ""
	end
	if IntroUI.countryDropdown then
		IntroUI.countryDropdown.Text = "ğŸ‡ºğŸ‡¸ United States"
	end

	showBlur()
	IntroUI.genderTitle.Text = "Start by picking a gender"
	IntroUI.genderBtns.Visible = true
	IntroUI.nameBtns.Visible = false
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Hide country selection buttons when showing intro!
	-- User bug report: "countries IS VISIBLE LIKE ITS BUGGED SHOWING THE COUNTRIES 
	-- AND MALE FEMALE LIKE ITS STACKED ON TOP"
	-- The countryBtns frame was NOT being hidden, causing it to stack with genderBtns!
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	IntroUI.countryBtns.Visible = false

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #643-645: Reset gender button transparency after death/new life
	-- The buttons may have been faded out in a previous animation and need to be
	-- fully visible again for the new life selection screen
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	for _, child in ipairs(IntroUI.genderBtns:GetChildren()) do
		if child:IsA("TextButton") then
			child.BackgroundTransparency = 0
			child.TextTransparency = 0
			child.Visible = true
			-- CRITICAL FIX #644: Reset button size in case it was mid-animation
			if child.Name ~= "CustomizeGenderBtn" and child.Name ~= "RoyaltyGenderBtn" then
				child.Size = UDim2.new(0.85, 0, 0, 58)
			end
		end
	end
	
	-- CRITICAL FIX #645: Also reset name buttons in case they were in a bad state
	for _, child in ipairs(IntroUI.nameBtns:GetChildren()) do
		if child:IsA("TextButton") then
			child.BackgroundTransparency = 0
			child.TextTransparency = 0
			child.Visible = true
			child.Size = UDim2.new(0.85, 0, 0, 54)
		end
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Reset country buttons transparency in case animation was interrupted
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	for _, child in ipairs(IntroUI.countryBtns:GetChildren()) do
		if child:IsA("TextButton") then
			child.BackgroundTransparency = 0
			child.TextTransparency = 0
			child.Visible = true
		end
	end

	-- CRITICAL FIX #104: Update Royalty button appearance on intro show
	if IntroUI.updateRoyaltyGenderBtn then
		IntroUI.updateRoyaltyGenderBtn()
	end
	
	-- CRITICAL FIX #432: Update God Mode button appearance on intro show
	-- This was MISSING - causing God Mode button to stay grey even after purchase!
	if IntroUI.updateCustomizeGenderBtn then
		IntroUI.updateCustomizeGenderBtn()
	end

	-- Fade in animation
	IntroUI.content.Position = UDim2.new(0.5, 0, 0.55, 0)
	tween(IntroUI.content, TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
		Position = UDim2.fromScale(0.5, 0.5)
	})
end

hideIntro = function()
	-- CRITICAL FIX: Restore content to auto-size mode before hiding
	IntroUI.content.AutomaticSize = Enum.AutomaticSize.Y
	IntroUI.content.Size = UDim2.new(0.9, 0, 0, 0)
	IntroUI.godModeContainer.Visible = false
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Explicitly hide all intro sub-screens to prevent stacking bug!
	-- User bug report: "countries IS VISIBLE LIKE ITS BUGGED"
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	IntroUI.genderBtns.Visible = false
	IntroUI.countryBtns.Visible = false
	IntroUI.nameBtns.Visible = false
	
	-- Smooth fade out animation
	local fadeTime = 0.25

	tween(IntroUI.content, TweenInfo.new(fadeTime, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {
		Position = UDim2.new(0.5, 0, 0.45, 0)
	})
	tween(IntroUI.overlay, TweenInfo.new(fadeTime), {
		BackgroundTransparency = 1
	})

	hideBlur()

	task.delay(fadeTime, function()
		IntroUI.overlay.Visible = false
		if not hasShownAgeHint then
			task.delay(0.3, showTutorial)
		end
	end)
end

----------------------------------------------------------------
-- UPDATE UI FROM STATE
----------------------------------------------------------------

function updateFromState()
	if not currentState then return end

	nameLabel.Text = currentState.Name or "New Life"
	ageYearLabel.Text = string.format(
		"Age %d â€¢ %d",
		currentState.Age or 0,
		getCurrentYear(currentState.Age)
	)
	moneyLabel.Text = formatMoney(currentState.Money or 0)

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX: Gender AND Ethnicity-aware avatar emoji selection
	-- Uses skin tone modifiers based on player's ethnicity from God Mode
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local gender = currentState.Gender or selectedGender or "Male"
	local isFemale = (gender:lower() == "female")
	
	-- Get ethnicity from player flags for skin-tone modifiers
	local ethnicity = ""
	if currentState.Flags and currentState.Flags.ethnicity then
		ethnicity = currentState.Flags.ethnicity
	end
	
	-- Skin tone modifiers based on ethnicity
	-- CRITICAL FIX: Proper skin tone assignments
	local skinTone = "" -- Default (yellow/no modifier)
	if ethnicity == "Caucasian" then
		skinTone = "ğŸ¼" -- Medium-light skin (NOT yellow)
	elseif ethnicity == "African" then
		skinTone = "ğŸ¿" -- Dark skin
	elseif ethnicity == "Hispanic" then
		skinTone = "ğŸ½" -- Medium skin
	elseif ethnicity == "Middle Eastern" then
		skinTone = "ğŸ½" -- Medium skin
	elseif ethnicity == "Asian" then
		skinTone = "ğŸ»" -- Light skin (East Asian)
	elseif ethnicity == "Indian" then
		skinTone = "ğŸ¾" -- Medium-dark skin (South Asian)
	elseif ethnicity == "Pacific Islander" then
		skinTone = "ğŸ½" -- Medium skin
	elseif ethnicity == "Indigenous" then
		skinTone = "ğŸ½" -- Medium skin
	elseif ethnicity == "Mixed" then
		skinTone = "ğŸ¼" -- Medium-light skin
	end
	-- Random = no modifier (yellow default)
	
	-- CRITICAL FIX: Avatar emoji based on age, gender, AND ethnicity
	local age = currentState.Age or 0
	if age < 2 then
		-- Baby
		avatarEmoji.Text = isFemale and "ğŸ‘¶" .. skinTone .. "ğŸ€" or "ğŸ‘¶" .. skinTone
	elseif age < 5 then
		-- Toddler
		avatarEmoji.Text = isFemale and "ğŸ‘§" .. skinTone or "ğŸ‘¦" .. skinTone
	elseif age < 13 then
		-- Child
		avatarEmoji.Text = isFemale and "ğŸ‘§" .. skinTone or "ğŸ‘¦" .. skinTone
	elseif age < 20 then
		-- Teen
		avatarEmoji.Text = isFemale and "ğŸ‘©" .. skinTone or "ğŸ‘¨" .. skinTone
	elseif age < 40 then
		-- Young Adult
		avatarEmoji.Text = isFemale and "ğŸ‘©" .. skinTone or "ğŸ‘¨" .. skinTone
	elseif age < 60 then
		-- Middle Aged Adult
		avatarEmoji.Text = isFemale and "ğŸ‘©" .. skinTone or "ğŸ‘¨" .. skinTone
	elseif age < 75 then
		-- Senior
		avatarEmoji.Text = isFemale and "ğŸ‘µ" .. skinTone or "ğŸ‘´" .. skinTone
	else
		-- Elderly
		avatarEmoji.Text = isFemale and "ğŸ‘µ" .. skinTone or "ğŸ‘´" .. skinTone
	end

	for key, card in pairs(statCards) do
		-- CRITICAL FIX: Check BOTH locations for stat values
		-- Server sends state.Health, activities update state.Stats.Health - check both!
		local val = currentState[key]
		if val == nil and currentState.Stats then
			val = currentState.Stats[key]
		end
		if val == nil then
			val = 50  -- Default fallback
		end
		card.percentLabel.Text = math.floor(val) .. "%"
		tween(card.barFill, TweenInfo.new(0.3), {
			Size = UDim2.new(math.clamp(val/100, 0, 1), 0, 1, 0),
		})
	end

	refreshGodModeStatus()
	updateGodModeButtonAppearance()
end

----------------------------------------------------------------
-- REMOTE HANDLERS
----------------------------------------------------------------

-- Track previous state for change detection
local previousState = {}
local firstSync = true

SyncState.OnClientEvent:Connect(function(state, lastFeedText, resultData)
	if not state then return end

	-- Only log significant state changes, not every sync (reduces spam)
	local ageChanged = currentState and currentState.Age ~= state.Age
	local moneyChanged = currentState and currentState.Money ~= state.Money

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- STEP 1: DETECT IF THIS IS A NEW LIFE (BEFORE updating currentState)
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	local isNewLife = false

	-- CRITICAL: Check if data was RESTORED from save - if so, NEVER treat as new life!
	local dataRestored = state.Flags and state.Flags.data_restored

	-- Method 1: Explicit "new life" message from server (resetPlayerLife sends this)
	if lastFeedText == "A new life begins..." then
		isNewLife = true
	end

	-- Method 2: Old state had a name, new state doesn't -> this is a restart
	if not isNewLife and currentState and currentState.Name and (not state.Name or state.Name == "") then
		isNewLife = true
	end

	-- Method 3: First sync with no name = new life
	if firstSync then
		firstSync = false
		if not state.Name or state.Name == "" then
			isNewLife = true
		end
	end

	-- Method 4: Age is 0 and no name = definitely new life
	if (state.Age == 0 or state.Age == nil) and (not state.Name or state.Name == "") then
		isNewLife = true
	end

	-- CRITICAL OVERRIDE: If data was restored from save, this is NOT a new life!
	-- This takes precedence over all other checks
	if dataRestored and state.Name and state.Name ~= "" then
		isNewLife = false
		if not introComplete then
			introComplete = true  -- Skip intro entirely
			-- Only print once on actual data restore, not every sync
			print("[LifeClient] ğŸ“‚ Data restored from save - NOT a new life. Name:", state.Name, "Age:", state.Age)
		end
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- STEP 2: HANDLE NEW LIFE RESET
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	if isNewLife then

		-- Reset all intro/game flags
		introComplete = false
		selectedGender = nil
		awaitingEvent = false
		hasShownAgeHint = false
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX: Reset selectedCountry on new life!
		-- User bug report: "countries IS VISIBLE LIKE ITS BUGGED SHOWING THE COUNTRIES 
		-- AND MALE FEMALE LIKE ITS STACKED ON TOP"
		-- This ensures country selection state is reset for new lives
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		selectedCountry = "usa" -- Reset to default

		-- Clear pending minigame state
		pendingMinigameEventId = nil
		pendingMinigameChoiceIndex = nil

		-- Clear feed entries
		feedEntryCount = 0
		for _, child in ipairs(feedScroll:GetChildren()) do
			if child:IsA("Frame") then
				child:Destroy()
			end
		end

		-- Reset previous state tracking
		previousState = {}

		-- Update currentState with new state (include all fields from server)
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX #20: Explicitly set CurrentJob to nil for new life
		-- This ensures no stale job data from previous life is carried over
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		currentState = {
			Name = nil,
			Age = state.Age or 0,
			Money = state.Money or 0,
			Happiness = state.Happiness or 50,
			Health = state.Health or 100,
			Smarts = state.Smarts or 50,
			Looks = state.Looks or 50,
			Gender = nil,
			-- CRITICAL: Include Assets and other fields from server state
			Assets = state.Assets or { Properties = {}, Vehicles = {}, Items = {} },
			Relationships = state.Relationships or {},
			Flags = state.Flags or {},
			-- CRITICAL FIX: Explicitly set job to nil for new life (prevents stale job showing)
			CurrentJob = nil,
			CareerInfo = nil,
			Career = nil,
			Education = state.Education or "none",
			EducationData = state.EducationData,
			-- CRITICAL: Include MobState for Mafia screen
			MobState = state.MobState or { inMob = false },
			-- CRITICAL FIX #429: Include GamepassOwnership
			GamepassOwnership = state.GamepassOwnership or {},
			-- CRITICAL: Prison state should be reset for new life
			InJail = false,
			JailYearsLeft = 0,
		}
		
		-- CRITICAL FIX #430: Initialize gamepass caches from server state
		-- This ensures gamepasses are recognized even on new life
		if state.GamepassOwnership then
			if state.GamepassOwnership.godMode then hasGodMode = true end
			if state.GamepassOwnership.royalty then hasRoyalty = true end
			if state.GamepassOwnership.mafia then hasMafia = true end
			if state.GamepassOwnership.celebrity then hasCelebrity = true end
			if state.GamepassOwnership.timeMachine then hasTimeMachine = true end
		end
		-- Also check Flags as fallback
		if state.Flags then
			if state.Flags.god_mode_gamepass then hasGodMode = true end
			if state.Flags.royalty_gamepass then hasRoyalty = true end
			if state.Flags.mafia_gamepass then hasMafia = true end
			if state.Flags.celebrity_gamepass then hasCelebrity = true end
			if state.Flags.time_machine_gamepass then hasTimeMachine = true end
		end

		-- Reset header UI
		nameLabel.Text = "New Life"
		ageYearLabel.Text = string.format("Age %d â€¢ %d", state.Age or 0, getCurrentYear(state.Age))
		moneyLabel.Text = formatMoney(state.Money or 0)
		avatarEmoji.Text = "ğŸ‘¶"

		-- Reset stats UI
		for key, card in pairs(statCards) do
			local val = state[key] or (state.Stats and state.Stats[key]) or 50
			card.percentLabel.Text = val .. "%"
			card.barFill.Size = UDim2.new(math.clamp(val/100, 0, 1), 0, 1, 0)
		end

		-- Hide any lingering modals
		if hideResultPopup then 
			pcall(hideResultPopup) 
		end
		if hideEvent then 
			pcall(hideEvent) 
		end
		hideTutorial()
		hideDeathOverlay()
		
		-- CRITICAL FIX: Hide ALL screens when starting new life!
		-- This prevents screens like ProgressScreen from staying visible after death
		for screenName, screenInstance in pairs(ScreenInstances) do
			if screenInstance and screenInstance.hide then
				pcall(function() screenInstance:hide() end)
			end
		end

		-- Update all screen instances with the new state (even during reset)
		-- This ensures screens have proper initial state
		if ScreenInstances.occupation and ScreenInstances.occupation.updateState then
			ScreenInstances.occupation:updateState(currentState)
		end
		if ScreenInstances.assets and ScreenInstances.assets.updateState then
			ScreenInstances.assets:updateState(currentState)
		end
		if ScreenInstances.relationships and ScreenInstances.relationships.updateState then
			ScreenInstances.relationships:updateState(currentState)
		end
		if ScreenInstances.activities and ScreenInstances.activities.updateState then
			ScreenInstances.activities:updateState(currentState)
		end
		if ScreenInstances.mafia and ScreenInstances.mafia.updateState then
			ScreenInstances.mafia:updateState(currentState)
		end
		-- CRITICAL FIX: Update storypaths screen state
		if ScreenInstances.storypaths and ScreenInstances.storypaths.updateState then
			ScreenInstances.storypaths:updateState(currentState)
		end
		-- CRITICAL FIX: Update progress screen state
		if ScreenInstances.progress and ScreenInstances.progress.updateState then
			ScreenInstances.progress:updateState(currentState)
		end

		-- SHOW INTRO MODAL
		showIntro()
		
		-- CRITICAL FIX #434: Update gamepass buttons after new life starts
		-- The gamepass caches were just updated from server state, so update UI
		task.defer(function()
			if IntroUI and IntroUI.updateCustomizeGenderBtn then
				IntroUI.updateCustomizeGenderBtn()
			end
			if IntroUI and IntroUI.updateRoyaltyGenderBtn then
				IntroUI.updateRoyaltyGenderBtn()
			end
		end)

		-- Early return - don't process as normal sync
		return
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- STEP 3: NORMAL (NON-RESET) SYNC HANDLING
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

	-- Calculate deltas for result popup
	local deltas = {}
	if previousState.Happiness and state.Happiness then
		deltas.happiness = state.Happiness - previousState.Happiness
	end
	if previousState.Health and state.Health then
		deltas.health = state.Health - previousState.Health
	end
	if previousState.Smarts and state.Smarts then
		deltas.smarts = state.Smarts - previousState.Smarts
	end
	if previousState.Looks and state.Looks then
		deltas.looks = state.Looks - previousState.Looks
	end
	if previousState.Money and state.Money then
		deltas.money = state.Money - previousState.Money
	end

	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #18: Proper state update that handles nil values
	-- The issue was: pairs() doesn't iterate over nil values, so CurrentJob = nil
	-- from server wouldn't clear the client's cached CurrentJob, causing stale job display!
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	-- Update values from server state
	for k, v in pairs(state) do
		currentState[k] = v
		previousState[k] = v
	end
	if state.Stats then
		for k, v in pairs(state.Stats) do
			currentState[k] = v
			previousState[k] = v
		end
	end

	-- Also copy Age directly if it's in the state
	if state.Age then
		currentState.Age = state.Age
	end
	
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	-- CRITICAL FIX #19: Explicitly handle fields that CAN be nil but need to be cleared
	-- This is essential for fields like CurrentJob that disappear when unemployed
	-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
	
	-- Job state - MUST explicitly clear if server doesn't send it
	-- (since pairs() won't iterate over nil keys)
	if state.CurrentJob == nil then
		currentState.CurrentJob = nil
		previousState.CurrentJob = nil
	end
	
	-- Also check if CurrentJob was explicitly sent as empty/invalid
	if currentState.CurrentJob and type(currentState.CurrentJob) == "table" then
		-- Validate the job has required fields, otherwise clear it
		if not currentState.CurrentJob.id and not currentState.CurrentJob.title and not currentState.CurrentJob.name then
			currentState.CurrentJob = nil
			previousState.CurrentJob = nil
		end
	end
	
	-- Career track can also be nil
	if state.Career then
		currentState.Career = state.Career
		previousState.Career = state.Career
	end
	
	-- CareerInfo should be updated properly
	if state.CareerInfo then
		currentState.CareerInfo = state.CareerInfo
		previousState.CareerInfo = state.CareerInfo
	end
	
	-- Education status
	if state.Education then
		currentState.Education = state.Education
	end
	if state.EducationData then
		currentState.EducationData = state.EducationData
	end
	
	-- Prison status
	currentState.InJail = state.InJail or false
	currentState.JailYearsLeft = state.JailYearsLeft or 0
	
	-- CRITICAL FIX #431: Update gamepass caches from server state on every sync
	-- ONLY upgrade to true, never downgrade (server might have stale data)
	if state.GamepassOwnership then
		if state.GamepassOwnership.godMode then hasGodMode = true end
		if state.GamepassOwnership.royalty then hasRoyalty = true end
		if state.GamepassOwnership.mafia then hasMafia = true end
		if state.GamepassOwnership.celebrity then hasCelebrity = true end
		if state.GamepassOwnership.timeMachine then hasTimeMachine = true end
	end
	if state.Flags then
		if state.Flags.god_mode_gamepass then hasGodMode = true end
		if state.Flags.royalty_gamepass then hasRoyalty = true end
		if state.Flags.mafia_gamepass then hasMafia = true end
		if state.Flags.celebrity_gamepass then hasCelebrity = true end
		if state.Flags.time_machine_gamepass then hasTimeMachine = true end
	end

	-- Update all screen instances with latest state
	if ScreenInstances.occupation and ScreenInstances.occupation.updateState then
		ScreenInstances.occupation:updateState(currentState)
	end
	if ScreenInstances.assets and ScreenInstances.assets.updateState then
		ScreenInstances.assets:updateState(currentState)
	end
	if ScreenInstances.relationships and ScreenInstances.relationships.updateState then
		ScreenInstances.relationships:updateState(currentState)
	end
	if ScreenInstances.activities and ScreenInstances.activities.updateState then
		ScreenInstances.activities:updateState(currentState)
	end
	if ScreenInstances.mafia and ScreenInstances.mafia.updateState then
		ScreenInstances.mafia:updateState(currentState)
	end
	-- CRITICAL FIX #435: Ensure storypaths gets proper updateState call
	if ScreenInstances.storypaths then
		if ScreenInstances.storypaths.updateState then
			ScreenInstances.storypaths:updateState(currentState)
		elseif ScreenInstances.storypaths.visible then
			ScreenInstances.storypaths:updateUI()
		end
	end
	-- CRITICAL FIX: Update progress screen state
	if ScreenInstances.progress and ScreenInstances.progress.updateState then
		ScreenInstances.progress:updateState(currentState)
	end

	-- CRITICAL FIX: Check for death FIRST before showing any popups
	-- This prevents the DOUBLE DEATH SCREEN bug where both result popup and death overlay show
	local isDead = (resultData and resultData.fatal) or (currentState.Health and currentState.Health <= 0)
	
	-- Show result popup if we have result data from server (but NOT if player is dead!)
	-- CRITICAL FIX: Also check skipClientPopup flag for minigame results!
	-- User complaint: "RESULT LIKE FROM MINIGAMES THE CARD POP UPS TWO TYPES POPUP"
	-- Minigames already show their own result (VICTORY!/YOU LOST) so we skip the extra popup
	local shouldShowPopup = resultData and resultData.showPopup and not isDead and not resultData.skipClientPopup
	
	-- Also skip popup if this was a minigame (minigames show their own results)
	if resultData and resultData.wasMinigame then
		shouldShowPopup = false
	end
	
	if shouldShowPopup then
		showResultPopup({
			emoji = resultData.emoji or "ğŸ“‹",
			title = resultData.title or "Result",
			body = resultData.body or lastFeedText or "Life continues...",
			happiness = resultData.happiness or deltas.happiness,
			health = resultData.health or deltas.health,
			smarts = resultData.smarts or deltas.smarts,
			looks = resultData.looks or deltas.looks,
			money = resultData.money or deltas.money,
			wasSuccess = resultData.wasSuccess, -- IMPORTANT: Pass through success flag for minigames
		})
	elseif deltas.health and deltas.health < -15 and not isDead then
		-- Auto-shake for MAJOR negative health (15+ drop)
		shakeScreen(10, 0.35)
		flashScreen(C.Red, 0.5, 0.35)
	elseif deltas.health and deltas.health < -5 then
		-- Smaller health drop - just flash, no shake
		flashScreen(C.Red, 0.7, 0.25)
	-- CRITICAL FIX: Only flash green for UNEXPECTED money gains (windfalls, lottery, etc.)
	-- Regular salary shouldn't cause a flash - it's expected and boring
	-- Threshold raised to $100,000 to make flashes feel special and rare
	elseif deltas.money and deltas.money > 100000 then
		-- Flash green for massive money windfall (lottery, inheritance, etc.)
		flashScreen(C.Green, 0.7, 0.3)
	-- CRITICAL FIX: Only flash red for big LOSSES, not normal expenses
	elseif deltas.money and deltas.money < -50000 then
		-- Flash red for major money losses (lawsuit, major purchase shouldn't flash)
		flashScreen(C.Red, 0.7, 0.25)
	end

	-- Check for death (from result data or health hitting 0)
	if resultData and resultData.fatal then
		local causeText = resultData.cause or resultData.body or lastFeedText or "You passed away."
		-- CRITICAL FEATURE: Pass continue as kid data to death overlay
		showDeathOverlay(causeText, state.Age, resultData.canContinueAsKid, resultData.continueAsKidData)
	elseif currentState.Health and currentState.Health <= 0 then
		showDeathOverlay("Health depleted.", state.Age, false, nil)
	else
		hideDeathOverlay()
	end

	-- Update UI from state
	updateFromState()

	-- Add feed entry
	if lastFeedText and lastFeedText ~= "" and not (resultData and resultData.showPopup) then
		addFeedEntry(lastFeedText)
	end

	-- Check if intro should be shown (shouldn't normally happen here, but safety check)
	-- CRITICAL: Skip intro if data was restored from save!
	local dataRestored = currentState.Flags and currentState.Flags.data_restored
	if dataRestored and currentState.Name and currentState.Name ~= "" then
		-- Data was restored - skip intro entirely (only log once)
		if not introComplete then
			introComplete = true
			print("[LifeClient] âœ… Restored from save - skipping intro. Name:", currentState.Name)
		end
		if IntroUI.overlay.Visible then
			hideIntro()
		end
	elseif not introComplete and (not currentState.Name or currentState.Name == "") then
		showIntro()
	elseif currentState.Name and IntroUI.overlay.Visible then
		hideIntro()
	end
end)

-- New: ShowResult remote for explicit result popups
local ShowResult = remotesFolder:FindFirstChild("ShowResult")
if ShowResult then
	ShowResult.OnClientEvent:Connect(function(data)
		showResultPopup({
			emoji = data.emoji or "ğŸ“‹",
			title = data.title or "Result",
			body = data.body or "Something happened...",
			happiness = data.happiness,
			health = data.health,
			smarts = data.smarts,
			looks = data.looks,
			money = data.money,
		}, function()
			-- Callback when popup closed
			if data.feedText then
				addFeedEntry(data.feedText)
			end
		end)
	end)
end

PresentEvent.OnClientEvent:Connect(function(eventData, ageFeedText)
	-- Validate event data
	if not eventData then
		warn("[LifeClient] âŒ PresentEvent received with nil eventData!")
		return
	end

	hideTutorial()
	if ageFeedText then
		addFeedEntry(ageFeedText)
	end

	-- Flash effect when event appears
	flashScreen(C.Blue, 0.85, 0.2)

	showEvent({
		id               = eventData.id,
		text             = eventData.text,
		choices          = eventData.choices,
		emoji            = eventData.emoji or "ğŸ™‚",
		title            = eventData.title or "Life Event",
		showRelationship = eventData.showRelationship or false,
		relationName     = eventData.relationName,
		relationship     = eventData.relationship,
		question         = eventData.question,
	})
end)

----------------------------------------------------------------
-- MINIGAME START HANDLER (Server triggers minigame)
----------------------------------------------------------------

if MinigameStart then
	MinigameStart.OnClientEvent:Connect(function(config)
		-- CRITICAL FIX: Hide event overlay if visible when minigame starts
		if EventUI.overlay.Visible then
			hideEvent()
		end

		pendingMinigameEventId = config.eventId
		pendingMinigameChoiceIndex = config.choiceIndex

		-- CRITICAL FIX: Server sends "type" not "id"! This was causing nil minigame errors.
		local minigameType = config.type or config.id
		print("[LifeClient] ğŸ® Minigame requested from event:", minigameType, "for event:", config.eventId)
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX #CONTEXT-1: Pass minigame options including CONTEXT from server!
		-- User complaint: "argument minigame has the wording mixed up allways like weirdly 
		-- could be a relashonship argument and its a presidental questions"
		-- The server sends context in config, we need to pass it to the minigame!
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		local minigameOptions = {
			context = config.context or config.minigameContext or "general",
			title = config.title or config.minigameTitle,
			difficulty = config.difficulty or "medium",
		}
		print("[LifeClient] ğŸ® Minigame options:", minigameOptions.context, minigameOptions.title)

		if minigamesInstance and minigamesInstance.play then
			-- CRITICAL FIX: Pass minigameOptions as 3rd argument to get correct question bank!
			minigamesInstance:play(minigameType, function(won, data)

				-- Send result back to server
				if MinigameResult then
					MinigameResult:FireServer(won, {
						eventId = config.eventId,
						choiceIndex = config.choiceIndex,
						score = data and data.score or 0,
					})
				end

				-- Clear pending
				pendingMinigameEventId = nil
				pendingMinigameChoiceIndex = nil

				-- Visual feedback
				if won then
					flashScreen(C.Green, 0.7, 0.3)
				else
					flashScreen(C.Red, 0.6, 0.3)
					shakeScreen(6, 0.2)
				end
			end, minigameOptions)
		else
			-- No minigame module - just auto-complete as failure
			warn("[LifeClient] âš ï¸ No minigame module available, auto-failing")
			if MinigameResult then
				MinigameResult:FireServer(false, {
					eventId = config.eventId,
					choiceIndex = config.choiceIndex,
				})
			end
			pendingMinigameEventId = nil
			pendingMinigameChoiceIndex = nil
		end
	end)
end

----------------------------------------------------------------
-- AGE BUTTON LOGIC
----------------------------------------------------------------

local function pulseAge()
	local ti = TweenInfo.new(0.08, Enum.EasingStyle.Quad)
	tween(ageButton, ti, { Size = UDim2.new(1, -2, 1, -2) }).Completed:Wait()
	tween(ageButton, ti, { Size = UDim2.new(1, -6, 1, -6) })
end

ageButton.MouseButton1Click:Connect(function()
	-- Safety check: if awaitingEvent is true but the event overlay is NOT visible,
	-- something went wrong - reset the flag
	if awaitingEvent and not EventUI.overlay.Visible then
		awaitingEvent = false
		EventUI.currentEventId = nil
	end

	-- Block age up if waiting for event choice
	if awaitingEvent then
		return
	end

	-- Block if no name set yet (intro not complete)
	if not currentState.Name then
		return
	end

	hideTutorial()
	pulseAge()
	RequestAgeUp:FireServer()
end)

ageButton.MouseEnter:Connect(function()
	tween(ageOuterRing, TweenInfo.new(0.15), { Size = UDim2.new(1, 12, 1, 12) })
end)
ageButton.MouseLeave:Connect(function()
	tween(ageOuterRing, TweenInfo.new(0.15), { Size = UDim2.new(1, 8, 1, 8) })
end)

----------------------------------------------------------------
-- SCREEN MODULE INIT
----------------------------------------------------------------

local function safeNew(mod, name, ...)
	if not mod then
		warn("[LifeClient] âŒ Module " .. tostring(name) .. " is nil - failed to require")
		return nil
	end
	-- CRITICAL DEBUG: Detailed module inspection
	print("[LifeClient] ğŸ” safeNew checking", name, "- type:", type(mod))
	if type(mod) == "table" then
		local count = 0
		for k, v in pairs(mod) do
			count = count + 1
			if count <= 5 then
				print("[LifeClient] ğŸ”  ", name, "has key:", tostring(k), "type:", type(v))
			end
		end
		print("[LifeClient] ğŸ” ", name, "total keys:", count)
	end
	if not mod.new then
		warn("[LifeClient] âŒ Module " .. tostring(name) .. " has no .new function")
		warn("[LifeClient] âŒ mod.new is:", tostring(mod.new), "type:", type(mod.new))
		return nil
	end
	local s, r = pcall(mod.new, ...)
	if s and r then 
		print("[LifeClient] âœ… Created " .. tostring(name) .. " successfully")
		return r 
	elseif not s then
		warn("[LifeClient] âŒ Failed to create " .. tostring(name) .. ":", tostring(r))
	else
		warn("[LifeClient] âŒ " .. tostring(name) .. ".new returned nil")
	end
	return nil
end

ScreenInstances.occupation   = safeNew(OccupationScreen,    "OccupationScreen",    screenGui, blurOverlay, showBlur, hideBlur, currentState)
ScreenInstances.assets       = safeNew(AssetsScreen,        "AssetsScreen",        screenGui, blurOverlay, showBlur, hideBlur, currentState)
ScreenInstances.storypaths   = safeNew(StoryPathsScreen,    "StoryPathsScreen",    screenGui, currentState)
ScreenInstances.progress     = safeNew(ProgressScreen,      "ProgressScreen",      screenGui, blurOverlay, showBlur, hideBlur, currentState)

-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- CRITICAL FIX: Create RelationshipsScreen with onShowEventCard callback
-- This allows relationship interactions to show proper BitLife-style event cards!
-- User feedback: "I want actual card thingy like activities do"
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
local function onRelationshipShowEventCard(eventCard, onChoiceCallback)
	-- Hide the RelationshipsScreen first
	if ScreenInstances.relationships and ScreenInstances.relationships.hide then
		ScreenInstances.relationships:hide()
	end
	hideBlur()
	
	-- Show the event card on the main UI using LifeClient's proper event system!
	if showEvent then
		showEvent({
			id = eventCard.id or "relationship_event",
			title = eventCard.title or "ğŸ’• Relationship",
			emoji = eventCard.emoji or "ğŸ’•",
			text = eventCard.text or "Something happened...",
			question = eventCard.question or "What will you do?",
			choices = eventCard.choices or {{text = "Continue", index = 1}},
			category = eventCard.category,
			isActivityEvent = true, -- Use activity event handler for callbacks
			onActivityChoice = onChoiceCallback,
		})
	end
end

ScreenInstances.relationships= safeNew(RelationshipsScreen, "RelationshipsScreen", screenGui, blurOverlay, showBlur, hideBlur, currentState, onRelationshipShowEventCard)

-- CRITICAL FIX: Create ActivitiesScreen with onShowEventCard callback
-- This allows activities to show proper BitLife-style event cards in the main UI
local function onActivityShowEventCard(eventCard, onChoiceCallback)
	-- Hide the ActivitiesScreen first
	if ScreenInstances.activities and ScreenInstances.activities.hide then
		ScreenInstances.activities:hide()
	end
	hideBlur()
	
	-- Show the event card on the main UI
	if showEvent then
		showEvent({
			id = eventCard.id or "activity_event",
			title = eventCard.title or "ğŸ“‹ Activity",
			emoji = eventCard.emoji or "âœ¨",
			text = eventCard.text or "Something happened...",
			question = eventCard.question or "What happened?",
			choices = eventCard.choices or {{text = "Continue", index = 1}},
			category = eventCard.category,
			isActivityEvent = true,
			onActivityChoice = onChoiceCallback,
		})
	end
end
-- CRITICAL FIX: Callback to refresh main UI stats after activities change stats locally
-- User bug: "stats don't change after I complete activities"
-- This is called by ActivitiesScreen after applying stat changes to currentState
local function onActivityStatsChanged()
	updateFromState()
end

ScreenInstances.activities   = safeNew(ActivitiesScreen,    "ActivitiesScreen",    screenGui, blurOverlay, showBlur, hideBlur, currentState, onActivityShowEventCard, onActivityStatsChanged)

-- CRITICAL FIX #443: Create MafiaScreen with onShowEventCard callback
-- This allows mafia operations to close the MafiaScreen and show an event card in main UI
local function onMafiaShowEventCard(eventCard, onChoiceCallback)
	-- Hide the MafiaScreen first
	if ScreenInstances.mafia and ScreenInstances.mafia.hide then
		ScreenInstances.mafia:hide()
	end
	hideBlur()
	
	-- Show the event card on the main UI
	if showEvent then
		showEvent({
			id = eventCard.id or "mafia_operation",
			title = eventCard.title or "ğŸ”« Operation",
			emoji = eventCard.emoji or "ğŸ”«",
			text = eventCard.text or "A risky operation...",
			question = eventCard.question or "What do you do?",
			choices = eventCard.choices or {{text = "Continue", index = 1}},
			isMafiaOperation = true,
			onMafiaChoice = onChoiceCallback,
		})
	end
end
ScreenInstances.mafia        = safeNew(MafiaScreen,         "MafiaScreen",         screenGui, blurOverlay, showBlur, hideBlur, currentState, onMafiaShowEventCard)

if MinigamesModule then
	local ok, mg = pcall(function() return MinigamesModule.new(screenGui) end)
	if ok and mg then 
		minigamesInstance = mg
		print("[LifeClient] ğŸ® Minigames instance created successfully!")
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX: Verify the minigames instance has the play function
		-- Without this, we silently fail when trying to play minigames
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		if mg.play then
			print("[LifeClient] ğŸ® Minigames 'play' function is available!")
		else
			warn("[LifeClient] âŒ Minigames instance missing 'play' function!")
		end
		
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		-- CRITICAL FIX: Enable rare auto Purge event (0.5% chance every 90 seconds)
		-- The Purge is an ultra-rare survival event that can happen at any time!
		-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
		if mg.enableRareAutoPurge then
			mg:enableRareAutoPurge({
				chance = 0.005,      -- 0.5% chance
				interval = 90,       -- Check every 90 seconds (1.5 min)
				totalScenarios = 10, -- 10 survival scenarios
				onComplete = function(won, stats)
					print("[LifeClient] ğŸ˜ˆ Purge event completed! Won:", won, "Stats:", stats and stats.died or "nil")
					
					-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
					-- CRITICAL FIX: Purge should ACTUALLY KILL the player if they die
					-- User feedback: "WHEN THE PURGE HAPPENED I DIDN'T DIE HAVE IT ACTUALLY KILL YOU"
					-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
					
					if currentState then
						if won then
							-- Survived! Bonus stats
							currentState.Health = math.clamp((currentState.Health or 50) + 10, 0, 100)
							currentState.Happiness = math.clamp((currentState.Happiness or 50) + 15, 0, 100)
							
							-- Add feed message
							currentState.Feed = currentState.Feed or {}
							table.insert(currentState.Feed, "ğŸ‰ You survived The Purge! You're stronger now! (+Health, +Happiness)")
							-- CRITICAL FIX: Use updateFromState() instead of undefined refreshInfo()
							if updateFromState then
								updateFromState()
							end
						else
							-- DIED IN THE PURGE - Trigger actual death!
							currentState.Health = 0  -- Set health to 0
							currentState.Feed = currentState.Feed or {}
							table.insert(currentState.Feed, "ğŸ’€ You perished in The Purge...")
							
							-- Trigger death overlay
							local deathCause = "Killed during The Purge"
							if stats and stats.completed then
								deathCause = "Killed during The Purge (Survived " .. stats.completed .. " scenarios)"
							end
							
							-- Show death screen
							showDeathOverlay(deathCause, currentState.Age)
						end
					end
				end,
			})
		end
	else
		-- CRITICAL FIX: Log the error if MinigamesModule.new failed
		if not ok then
			warn("[LifeClient] âŒ Failed to create minigames instance:", tostring(mg))
		else
			warn("[LifeClient] âš ï¸ MinigamesModule.new returned nil or false")
		end
	end
else
	warn("[LifeClient] âš ï¸ MinigamesModule not available - minigames will not work!")
end

----------------------------------------------------------------
-- INITIAL STATE
----------------------------------------------------------------

ageBtnContainer.Visible = false

task.delay(0.5, function()
	ageBtnContainer.Visible = true
	-- Check if this is a returning player with saved data
	local dataRestored = currentState.Flags and currentState.Flags.data_restored
	local isFirstTime = not currentState.Name or currentState.Name == ""

	if dataRestored and currentState.Name and currentState.Name ~= "" then
		-- RETURNING PLAYER: Skip intro, show updates popup
		introComplete = true
		print("[LifeClient] âœ… Returning player - showing updates!")
		showWelcomeScreen(false) -- false = show updates, not welcome
	elseif isFirstTime then
		-- FIRST TIME PLAYER: Show welcome screen first, then intro!
		print("[LifeClient] ğŸ‰ First-time player detected - showing welcome screen!")
		showWelcomeScreen(true) -- true = show welcome message
		-- Wait for welcome screen to close before showing intro
		task.spawn(function()
			while WelcomeUI.overlay.Visible do
				task.wait(0.1)
			end
			showIntro()
		end)
	end
end)

----------------------------------------------------------------
-- STUCK STATE WATCHDOG
-- Periodically check if awaitingEvent is stuck and auto-recover
----------------------------------------------------------------

local lastAwaitingEventTime = nil
local STUCK_THRESHOLD = 30 -- seconds before considering it stuck

task.spawn(function()
	while true do
		task.wait(5) -- Check every 5 seconds

		if awaitingEvent then
			if not lastAwaitingEventTime then
				lastAwaitingEventTime = tick()
			elseif tick() - lastAwaitingEventTime > STUCK_THRESHOLD then
				-- Check if the event overlay is actually visible
				if not EventUI.overlay.Visible then
					awaitingEvent = false
					EventUI.currentEventId = nil
					lastAwaitingEventTime = nil
				end
			end
		else
			lastAwaitingEventTime = nil
		end
	end
end)

print("[LifeClient] âœ… Loaded in " .. string.format("%.1fs", tick() - startTime))
